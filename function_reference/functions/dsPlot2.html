<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsPlot2</title>
  <meta name="keywords" content="dsPlot2">
  <meta name="description" content="% handles=dsPlot(data,'option',value)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>

<a name="_top"></a>
<div><a href="../menu.html">Home</a> &gt;  <a href="menu.html">functions</a> &gt; dsPlot2.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../menu.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for functions&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>dsPlot2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% handles=dsPlot(data,'option',value)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [handles,xp] = dsPlot2(data,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% handles=dsPlot(data,'option',value)
 Purpose: plot data in various ways depending on what data was provided
 and what options are defined. this function is wrapped by dsPlotWaveforms,
 PlotPower, ... to provide a single function for organizing and displaying
 data.
 Inputs:
   data: DynaSim data structure (see dsCheckData)
   Accepts the following name/value pairs:
     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot
     'population' - name of population to plot (default: 'all'); accepts
                    regexp strings
     'variable' - name of variable to plot for each population (default: state variable, X or V);
                      accepts regexp strings
     'varied1' - Indices of 1st varied model parameter to plot. If the parameter
                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd
                 varied values. If the parameter is a char array, uses
                 regular expressions. Instead of 'varied1', can also use
                 the actual parameter name (e.g. 'E_Iapp')
     'varied2' - As varied 1, for 2nd varied parameter
     ....
     'variedN' - As varied 1, for 2nd varied parameter
     'num_embedded_subplots' - maximum # of waveforms to overlay per plot
     'max_num_overlaid' - maximum # of waveforms to overlay per plot
     'do_mean' - {false, true} - Turn on/off averaging across all units
                 in a population
     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}
                       If there is only one cell in a population, this forces
                       dsPlot2 to add other information to the overlay.
     'xlims' - [XMIN XMAX], x-axis limits (default: all data)
     'ylims' - [YMIN YMAX], y-axis limits (default: all data)
     'lock_axes' - {false, true}, locks abscissa and ordinate to be
                                  the same across all subplots
     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid
     'yscale' {'linear','log','log10'}, whether to plot linear or log scale
     'visible' {'on','off'}
     NOTE: analysis options available depending on plot_type
       see see dsCalcFR options for plot_type 'rastergram' or 'rates'
       see dsCalcPower options for plot_type 'power'
 Outputs:
   handles: graphic handles to figures

 See also: dsCalcFR, dsCalcPower, dsPlotWaveforms, dsCheckData, <a href="dsPlot.html" class="code" title="function handles = dsPlot(data,varargin)">dsPlot</a>, MDD,
           MDD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li><li><a href="../functions/internal/dsAll2mdd.html" class="code" title="function [xp,is_image] = dsAll2mdd(data,varargin)">dsAll2mdd</a>	</li><li><a href="../functions/internal/dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="../functions/internal/dsGet_variables_from_meta.html" class="code" title="function varlabels = dsGet_variables_from_meta(xp)">dsGet_variables_from_meta</a>	</li><li><a href="../functions/internal/dsImportPlots.html" class="code" title="function [data,studyinfo] = dsImportPlots(file,varargin)">dsImportPlots</a>	IMPORTPLOTS - load info about saved images (generated by SimulateMode or dsAnalyze) alongwith corresponding varied model components.</li><li><a href="../functions/internal/dsPlotFR.html" class="code" title="function handles = dsPlotFR(data,varargin)">dsPlotFR</a>	PLOTFR - plot spike rates in various ways depending on what data was provided.</li><li><a href="../functions/internal/xp_libraries/xp_PlotData.html" class="code" title="function hxp = xp_PlotData (xp, op)">xp_PlotData</a>	xp must be 1x1 (e.g. 0 dimensional)</li><li><a href="../functions/internal/xp_libraries/xp_PlotFR2.html" class="code" title="function hxp = xp_PlotFR2 (xp, op)">xp_PlotFR2</a>	xp must be 1x1 (e.g. 0 dimensional)</li><li><a href="../functions/internal/xp_libraries/xp_PlotFRpanel.html" class="code" title="function hxp = xp_PlotFRpanel (xp, op)">xp_PlotFRpanel</a>	xp must be 1x1 (e.g. 0 dimensional)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_handles = {@xp_handles_newfig, data_plothandle};</a></li><li><a href="#_sub2" class="code">function_args = {{figure_options},{plot_options}};</a></li><li><a href="#_sub3" class="code">function_handles = {@xp_handles_newfig, subplot_handle,data_plothandle};</a></li><li><a href="#_sub4" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub5" class="code">function_handles = {@xp_handles_newfig, subplot_handle,data_plothandle};</a></li><li><a href="#_sub6" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub7" class="code">function_handles = {@xp_handles_newfig, subplot_handle, subplot_handle,data_plothandle};</a></li><li><a href="#_sub8" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub9" class="code">function_handles = {@xp_handles_newfig, subplot_handle, subplot_handle,data_plothandle};</a></li><li><a href="#_sub10" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub11" class="code">function_handles = function_handles(available_dims);</a></li><li><a href="#_sub12" class="code">function_args = function_args(available_dims);</a></li><li><a href="#_sub13" class="code">function var_out = getdefaultstatevar(xp)</a></li><li><a href="#_sub14" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a></li><li><a href="#_sub15" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a></li><li><a href="#_sub16" class="code">function ax_ind_varied = findaxis_varied(xp)</a></li><li><a href="#_sub17" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a></li><li><a href="#_sub18" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a></li><li><a href="#_sub19" class="code">function varied_names = only_varieds(xp)</a></li><li><a href="#_sub20" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a></li><li><a href="#_sub21" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a></li><li><a href="#_sub22" class="code">function leg1 = setup_legends(xp2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [handles,xp] = dsPlot2(data,varargin)</a>
0002 <span class="comment">%% handles=dsPlot(data,'option',value)</span>
0003 <span class="comment">% Purpose: plot data in various ways depending on what data was provided</span>
0004 <span class="comment">% and what options are defined. this function is wrapped by dsPlotWaveforms,</span>
0005 <span class="comment">% PlotPower, ... to provide a single function for organizing and displaying</span>
0006 <span class="comment">% data.</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   data: DynaSim data structure (see dsCheckData)</span>
0009 <span class="comment">%   Accepts the following name/value pairs:</span>
0010 <span class="comment">%     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot</span>
0011 <span class="comment">%     'population' - name of population to plot (default: 'all'); accepts</span>
0012 <span class="comment">%                    regexp strings</span>
0013 <span class="comment">%     'variable' - name of variable to plot for each population (default: state variable, X or V);</span>
0014 <span class="comment">%                      accepts regexp strings</span>
0015 <span class="comment">%     'varied1' - Indices of 1st varied model parameter to plot. If the parameter</span>
0016 <span class="comment">%                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd</span>
0017 <span class="comment">%                 varied values. If the parameter is a char array, uses</span>
0018 <span class="comment">%                 regular expressions. Instead of 'varied1', can also use</span>
0019 <span class="comment">%                 the actual parameter name (e.g. 'E_Iapp')</span>
0020 <span class="comment">%     'varied2' - As varied 1, for 2nd varied parameter</span>
0021 <span class="comment">%     ....</span>
0022 <span class="comment">%     'variedN' - As varied 1, for 2nd varied parameter</span>
0023 <span class="comment">%     'num_embedded_subplots' - maximum # of waveforms to overlay per plot</span>
0024 <span class="comment">%     'max_num_overlaid' - maximum # of waveforms to overlay per plot</span>
0025 <span class="comment">%     'do_mean' - {false, true} - Turn on/off averaging across all units</span>
0026 <span class="comment">%                 in a population</span>
0027 <span class="comment">%     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}</span>
0028 <span class="comment">%                       If there is only one cell in a population, this forces</span>
0029 <span class="comment">%                       dsPlot2 to add other information to the overlay.</span>
0030 <span class="comment">%     'xlims' - [XMIN XMAX], x-axis limits (default: all data)</span>
0031 <span class="comment">%     'ylims' - [YMIN YMAX], y-axis limits (default: all data)</span>
0032 <span class="comment">%     'lock_axes' - {false, true}, locks abscissa and ordinate to be</span>
0033 <span class="comment">%                                  the same across all subplots</span>
0034 <span class="comment">%     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid</span>
0035 <span class="comment">%     'yscale' {'linear','log','log10'}, whether to plot linear or log scale</span>
0036 <span class="comment">%     'visible' {'on','off'}</span>
0037 <span class="comment">%     NOTE: analysis options available depending on plot_type</span>
0038 <span class="comment">%       see see dsCalcFR options for plot_type 'rastergram' or 'rates'</span>
0039 <span class="comment">%       see dsCalcPower options for plot_type 'power'</span>
0040 <span class="comment">% Outputs:</span>
0041 <span class="comment">%   handles: graphic handles to figures</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also: dsCalcFR, dsCalcPower, dsPlotWaveforms, dsCheckData, dsPlot, MDD,</span>
0044 <span class="comment">%           MDD</span>
0045 
0046 <span class="comment">%% Set Master parameters</span>
0047 
0048 <span class="comment">% Flag for returning error if the user specifies name/value pairs that are not in the</span>
0049 <span class="comment">% dsCheckOptions list</span>
0050 strict_mode = 0;        <span class="comment">% Should be set to zero for this to work within simulate model</span>
0051 
0052 <span class="comment">%% Convert data input to appropriate form</span>
0053 
0054 <span class="comment">% If data is path to studyinfo...</span>
0055 <span class="keyword">if</span> ischar(data)
0056     study_dir = data;
0057 
0058     <span class="comment">% Import plot files</span>
0059     data_img = <a href="../functions/internal/dsImportPlots.html" class="code" title="function [data,studyinfo] = dsImportPlots(file,varargin)">dsImportPlots</a>(study_dir);
0060 
0061     [handles, xp] = <a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>(data_img,varargin{:});
0062     <span class="keyword">return</span>;
0063 <span class="keyword">end</span>
0064 
0065 <span class="comment">% Convert the incoming DynaSim data structure to an MDD object</span>
0066 <span class="keyword">if</span> ~isa(data,<span class="string">'MDD'</span>)
0067     [xp,is_image] = <a href="../functions/internal/dsAll2mdd.html" class="code" title="function [xp,is_image] = dsAll2mdd(data,varargin)">dsAll2mdd</a>(data);
0068 <span class="keyword">else</span>
0069     xp = data;
0070     <span class="keyword">if</span> iscell(xp.data{1})
0071         is_image = 1;
0072     <span class="keyword">else</span>
0073         is_image = 0;
0074     <span class="keyword">end</span>
0075 <span class="keyword">end</span>
0076 
0077 <span class="comment">%% Convert varargin to appropriate forms</span>
0078 <span class="comment">% Find out names of varied variables</span>
0079 varied_names = <a href="#_sub19" class="code" title="subfunction varied_names = only_varieds(xp)">only_varieds</a>(xp);  <span class="comment">% Returns only the names of the varied variables</span>
0080 
0081 <span class="comment">% Convert 'varied1'...'variedN' values in varargin to the names of the</span>
0082 <span class="comment">% actual varied parameters</span>
0083 myargin = varargin;
0084 <span class="keyword">for</span> i = 1:length(myargin)
0085     <span class="comment">% Char entries</span>
0086     <span class="keyword">if</span> ischar(myargin{i})
0087         myargin{i} = <a href="#_sub15" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i},varied_names);
0088     <span class="keyword">end</span>
0089 
0090     <span class="comment">% Nested char entries within cell array entries</span>
0091     <span class="keyword">if</span> iscell(myargin{i})
0092         <span class="keyword">for</span> j = 1:length(myargin{i})
0093             <span class="keyword">if</span> ischar(myargin{i}{j})
0094                 myargin{i}{j} = <a href="#_sub15" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i}{j},varied_names);
0095             <span class="keyword">end</span>
0096         <span class="keyword">end</span>
0097     <span class="keyword">end</span>
0098 <span class="keyword">end</span>
0099 
0100 <span class="comment">% %% Add dummy axes as needed. Having these greatly simplifies the code below.</span>
0101 <span class="comment">% if isempty(xp.findaxis('populations'))</span>
0102 <span class="comment">%     Na=length(xp.axis);</span>
0103 <span class="comment">%     xp.axis(Na+1).name = 'populations';</span>
0104 <span class="comment">%     xp.axis(Na+1).values = 'Pop1';</span>
0105 <span class="comment">% end</span>
0106 <span class="comment">%</span>
0107 <span class="comment">% if isempty(xp.findaxis('variables'))</span>
0108 <span class="comment">%     Na=length(xp.axis);</span>
0109 <span class="comment">%     xp.axis(Na+1).name = 'variables';</span>
0110 <span class="comment">%     xp.axis(Na+1).values = 'X';</span>
0111 <span class="comment">% end</span>
0112 <span class="comment">%</span>
0113 <span class="comment">% if isempty(findaxis_varied(xp))  % If no varied axes</span>
0114 <span class="comment">%     Na=length(xp.axis);</span>
0115 <span class="comment">%     xp.axis(Na+1).name = 'Varied1';</span>
0116 <span class="comment">%     xp.axis(Na+1).values = 1;</span>
0117 <span class="comment">% end</span>
0118 
0119 <span class="comment">%% Parse varargin and set up defaults</span>
0120 [options, options_extras0] = <a href="../functions/internal/dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>(myargin,{<span class="keyword">...</span>
0121   <span class="string">'population'</span>,[],[],<span class="keyword">...</span>
0122   <span class="string">'variable'</span>,[],[],<span class="keyword">...</span>
0123   <span class="string">'num_embedded_subplots'</span>,2,{1,2,3,4},<span class="keyword">...</span>
0124   <span class="string">'max_num_overlaid'</span>,50,[],<span class="keyword">...</span>
0125   <span class="string">'do_mean'</span>,false,[false true],<span class="keyword">...</span>
0126   <span class="string">'force_last'</span>,[],[],<span class="keyword">...</span>
0127   <span class="string">'do_overlay_shift'</span>,false,[false true],<span class="keyword">...</span>
0128   <span class="string">'overlay_shift_val'</span>,[],[],<span class="keyword">...</span>
0129   <span class="string">'do_zscore'</span>,[false],[false true],<span class="keyword">...</span>
0130   <span class="string">'plot_type'</span>,<span class="string">'waveform'</span>,{<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>,<span class="string">'imagesc'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>,<span class="string">'power'</span>,<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>,<span class="string">'FRpanel'</span>},<span class="keyword">...</span>
0131   <span class="string">'xlims'</span>,[],[],<span class="keyword">...</span>
0132   <span class="string">'ylims'</span>,[],[],<span class="keyword">...</span>
0133   <span class="string">'zlims'</span>,[],[],<span class="keyword">...</span>
0134   <span class="string">'LineWidth'</span>,[],[],<span class="keyword">...</span>
0135   <span class="string">'plotargs'</span>,[],[],<span class="keyword">...</span>
0136   <span class="string">'figwidth'</span>,[1],[],<span class="keyword">...</span>
0137   <span class="string">'figheight'</span>,[1],[],<span class="keyword">...</span>
0138   <span class="string">'crop_range'</span>,[],[],<span class="keyword">...</span>
0139   <span class="string">'lock_axes'</span>,true,[false true],<span class="keyword">...</span>
0140   <span class="string">'saved_fignum'</span>,[1],[],<span class="keyword">...</span>
0141   <span class="string">'max_num_newfigs'</span>,[10],[],<span class="keyword">...</span>
0142   <span class="string">'plot_options'</span>,struct,[],<span class="keyword">...</span>
0143   <span class="string">'subplot_options'</span>,struct,[],<span class="keyword">...</span>
0144   <span class="string">'figure_options'</span>,struct,[],<span class="keyword">...</span>
0145   <span class="string">'do_zoom'</span>,false,[false true],<span class="keyword">...</span>
0146   <span class="string">'yscale'</span>,<span class="string">'linear'</span>,{<span class="string">'linear'</span>,<span class="string">'log'</span>,<span class="string">'log10'</span>,<span class="string">'log2'</span>},<span class="keyword">...</span>
0147   <span class="string">'visible'</span>,<span class="string">'on'</span>,{<span class="string">'on'</span>,<span class="string">'off'</span>},<span class="keyword">...</span>
0148   <span class="string">'show_colorbar'</span>,false,[false true],<span class="keyword">...</span>
0149   <span class="string">'ColorMap'</span>,[],[],<span class="keyword">...</span>
0150   <span class="string">'save_figures'</span>,false,[false true],<span class="keyword">...</span>
0151   <span class="string">'save_figname_prefix'</span>,[],[],<span class="keyword">...</span>
0152   <span class="string">'save_figname_path'</span>,[],[],<span class="keyword">...</span>
0153   <span class="string">'prepend_date_time'</span>,true,[false true],<span class="keyword">...</span>
0154   <span class="string">'supersize_me'</span>,false,[false true],<span class="keyword">...</span>
0155   <span class="string">'save_res'</span>,[],[],<span class="keyword">...</span>
0156   <span class="string">'Ndims_per_subplot'</span>,[],[],<span class="keyword">...</span>
0157   <span class="string">'dim_stacking'</span>,[],[],<span class="keyword">...</span>
0158   <span class="string">'subplot_handle'</span>,@xp_subplot_grid,[],<span class="keyword">...</span>
0159   <span class="string">'plot_handle'</span>,[],[],<span class="keyword">...</span>
0160   <span class="string">'plotFR_override'</span>,[],[false true],<span class="keyword">...</span>
0161   },false);
0162 handles=[];
0163 
0164 <span class="comment">% If plotFR_override is true, then go directly to dsPlotFR</span>
0165 <span class="keyword">if</span> options.plotFR_override
0166     handles = <a href="../functions/internal/dsPlotFR.html" class="code" title="function handles = dsPlotFR(data,varargin)">dsPlotFR</a>(data,varargin{:});
0167     <span class="keyword">return</span>;
0168 <span class="keyword">end</span>
0169 
0170 <span class="comment">% Pull out fields from options struct</span>
0171 plot_type = options.plot_type;
0172 plot_options = options.plot_options;
0173 subplot_options = options.subplot_options;
0174 figure_options = options.figure_options;
0175 num_embedded_subplots = options.num_embedded_subplots;
0176 do_mean = options.do_mean;
0177 force_last = options.force_last;
0178 crop_range = options.crop_range;
0179 lock_axes = options.lock_axes;
0180 Ndims_per_subplot = options.Ndims_per_subplot;
0181 subplot_handle = options.subplot_handle;
0182 plot_handle = options.plot_handle;
0183 
0184 <span class="comment">% Add default options to structures</span>
0185 <span class="comment">% Plot_options</span>
0186 <span class="comment">% Used when running xp_matrix_advancedplot3D</span>
0187     plot_options = struct_addDef(plot_options,<span class="string">'ylims'</span>,options.ylims);
0188     plot_options = struct_addDef(plot_options,<span class="string">'xlims'</span>,options.xlims);
0189     plot_options = struct_addDef(plot_options,<span class="string">'zlims'</span>,options.zlims);
0190     plot_options = struct_addDef(plot_options,<span class="string">'LineWidth'</span>,options.LineWidth);
0191     plot_options = struct_addDef(plot_options,<span class="string">'plotargs'</span>,options.plotargs);
0192 <span class="comment">% Used when running xp_plotimage</span>
0193     plot_options = struct_addDef(plot_options,<span class="string">'saved_fignum'</span>,options.saved_fignum);
0194 <span class="comment">% Used when running xp_PlotData or xp_PlotFR2</span>
0195     plot_options = struct_addDef(plot_options,<span class="string">'args'</span>,{});
0196 <span class="comment">% Used when running waveformErr</span>
0197     plot_options = struct_addDef(plot_options,<span class="string">'meanfunc'</span>,@(x) mean(x,2));
0198     plot_options = struct_addDef(plot_options,<span class="string">'errfunc'</span>,@(x) std(x,[],2) ./ (sqrt(size(x,2)) * ones(size(x,1),1)));
0199 <span class="comment">% Used when running xp_matrix_imagesc</span>
0200     plot_options = struct_addDef(plot_options,<span class="string">'ColorMap'</span>,options.ColorMap);
0201 
0202 <span class="comment">% Subplot_options</span>
0203 subplot_options = struct_addDef(subplot_options,<span class="string">'subplotzoom_enabled'</span>,options.do_zoom);
0204 subplot_options = struct_addDef(subplot_options,<span class="string">'force_rowvect'</span>,true);
0205 subplot_options = struct_addDef(subplot_options,<span class="string">'autosuppress_interior_tics'</span>,true);
0206 
0207 
0208 <span class="comment">% Figure options</span>
0209 figure_options = struct_addDef(figure_options,<span class="string">'visible'</span>,options.visible);
0210 figure_options = struct_addDef(figure_options,<span class="string">'save_figures'</span>,options.save_figures);
0211 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_path'</span>,options.save_figname_path);
0212 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_prefix'</span>,options.save_figname_prefix);
0213 figure_options = struct_addDef(figure_options,<span class="string">'prepend_date_time'</span>,options.prepend_date_time);
0214 figure_options = struct_addDef(figure_options,<span class="string">'supersize_me'</span>,options.supersize_me);
0215 figure_options = struct_addDef(figure_options,<span class="string">'save_res'</span>,options.save_res);
0216 figure_options = struct_addDef(figure_options,<span class="string">'max_num_newfigs'</span>,options.max_num_newfigs);
0217 figure_options = struct_addDef(figure_options,<span class="string">'figwidth'</span>,options.figwidth);
0218 figure_options = struct_addDef(figure_options,<span class="string">'figheight'</span>,options.figheight);
0219 
0220 <span class="comment">%% Pre-process raw data contained in xp.data (mean + downsample)</span>
0221 <span class="comment">% % Note: these options don't work if data are images</span>
0222 <span class="comment">% Apply max overlaid</span>
0223 MTPP = options.max_num_overlaid; <span class="comment">% max traces per plot</span>
0224 <span class="keyword">if</span> any(strcmp(options.plot_type,{<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>,<span class="string">'power'</span>})) &amp;&amp; all(cellfun(@isnumeric,xp.data(:))) &amp;&amp; ~do_mean &amp;&amp; ~is_image
0225     mydata = xp.data;
0226     mydata2 = cell(size(mydata));
0227     <span class="keyword">for</span> i = 1:numel(mydata)
0228         <span class="keyword">if</span> ~isempty(mydata{i})
0229             mydata2{i} = mydata{i}(:,1:min(size(mydata{i},2),MTPP));
0230         <span class="keyword">end</span>
0231     <span class="keyword">end</span>
0232 
0233     xp.data = mydata2;
0234     clear mydata mydata2
0235 
0236     <span class="comment">% Update cell numbers metadata</span>
0237     cell_names = [1:max(cellfun(@(x) size(x,2),xp.data(:)))];
0238     cell_names_str = cellfunu(@(s) [<span class="string">'Cell '</span> num2str(s)], num2cell(cell_names));
0239     xp.meta.datainfo(2).values = cell_names_str;
0240 <span class="keyword">end</span>
0241 
0242 <span class="comment">% Average across cells if necessary</span>
0243 <span class="keyword">if</span> do_mean &amp;&amp; ~is_image
0244     mydata = xp.data;
0245     mydata = cellfun(@(x) mean(x,2), mydata, <span class="string">'UniformOutput'</span>, 0);
0246     xp.data = mydata;
0247     xp.meta.datainfo(2).values = {<span class="string">'&lt;Cells&gt;'</span>};
0248 <span class="keyword">end</span>
0249 
0250 <span class="comment">%% Arrange dimensions of xp in appropriate order</span>
0251 <span class="comment">% % Should be variables x populations x varied1 x ... x variedN</span>
0252 
0253 <span class="comment">% Axis indices of populations</span>
0254 ax_ind_var = xp.findaxis(<span class="string">'variables'</span>);
0255 ax_ind_pop = xp.findaxis(<span class="string">'population'</span>);
0256 ax_ind_varied = <a href="#_sub16" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp);
0257 
0258 <span class="comment">% Permute to put varied variables last</span>
0259 myorder = [ax_ind_var, ax_ind_pop, ax_ind_varied(:)'];
0260 <span class="keyword">if</span> length(myorder) &gt; 1
0261     xp = permute(xp,myorder);
0262 <span class="keyword">end</span>
0263 
0264 <span class="comment">%% Identify user selections for populations, variables, etc., and convert xp to xp2</span>
0265 <span class="comment">% %  (xp2 contains only user selections)</span>
0266 <span class="comment">% User selection for populations</span>
0267 chosen_pop = options.population;
0268 <span class="keyword">if</span> isempty(chosen_pop)
0269     chosen_pop = <span class="string">':'</span>;
0270 <span class="keyword">end</span>
0271 
0272 <span class="comment">% User selection for state variables</span>
0273 chosen_vars = options.variable;
0274 <span class="keyword">if</span> isempty(chosen_vars)
0275     chosen_vars = <a href="#_sub13" class="code" title="subfunction var_out = getdefaultstatevar(xp)">getdefaultstatevar</a>(xp);
0276 <span class="keyword">end</span>
0277 
0278 <span class="comment">% User selection for varied parameters</span>
0279 options_extras = options_extras0;
0280 [chosen_varied , options_extras ]= <a href="#_sub14" class="code" title="subfunction [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)">get_chosen_varied</a>(varied_names,options_extras);
0281 
0282 <span class="comment">% If any options are still leftover, these are extraneous. Report an error</span>
0283 leftover_fields = fieldnames(options_extras);
0284 <span class="keyword">if</span> ~isempty(leftover_fields) &amp;&amp; strict_mode
0285     error(<span class="string">'The following unrecogized name/value pairs were passed in: %s'</span>, sprintf(<span class="string">'%s '</span>,leftover_fields{:}));
0286 <span class="keyword">end</span>
0287 
0288 <span class="comment">% Convert any &quot;all&quot; strings in chosen_varied to colon operators</span>
0289 inds = cellfun(@ischar,chosen_varied);
0290 chosen_varied(inds) = cellfun(@(s) strrep(s,<span class="string">'all'</span>,<span class="string">':'</span>),chosen_varied(inds),<span class="string">'UniformOutput'</span>,0);
0291 <span class="keyword">if</span> strcmp(chosen_vars,<span class="string">'all'</span>); chosen_vars = <span class="string">':'</span>; <span class="keyword">end</span>
0292 <span class="keyword">if</span> strcmp(chosen_pop,<span class="string">'all'</span>); chosen_pop = <span class="string">':'</span>; <span class="keyword">end</span>
0293 
0294 <span class="comment">% Select out chosen data</span>
0295 chosen_all = {};
0296 <span class="keyword">if</span> ~isempty(ax_ind_varied); chosen_all = [chosen_varied,chosen_all]; <span class="keyword">end</span>
0297 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'populations'</span>)); chosen_all = [chosen_pop,chosen_all]; <span class="keyword">end</span>
0298 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'variables'</span>)); chosen_all = [chosen_vars,chosen_all]; <span class="keyword">end</span>
0299 <span class="comment">%xp2 = xp(chosen_vars,chosen_pop,chosen_varied{:});</span>
0300 <span class="keyword">if</span> ndims(xp) == 2 &amp;&amp; ~isempty(strfind(xp.axis(2).name,<span class="string">'Dim'</span>)) &amp;&amp; length(chosen_all) == 1
0301     chosen_all = [chosen_all {<span class="string">':'</span>}];        <span class="comment">% If xp is a column vector and only 1 varied entry present, fill out chosen_all to be size 2.</span>
0302 <span class="keyword">end</span>
0303 xp2 = xp(chosen_all{:});
0304 
0305 
0306 <span class="comment">%% Squeeze out unused dimensions</span>
0307 <span class="comment">% Squeeze to eliminate superfluous dimensions</span>
0308 xp2 = xp2.squeeze;
0309 Nd = ndims(xp2);
0310 
0311 <span class="comment">% Rearrange dimensions of xp2 for stacking</span>
0312 <span class="keyword">if</span> ~isempty(options.dim_stacking)
0313     ax_names = xp2.exportAxisNames;
0314     <span class="keyword">if</span> length(options.dim_stacking) ~= length(ax_names) -1
0315         error(<span class="string">'Incorrect number of dimensions specified. dim_stacking must be some permutation of the following: %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0316     <span class="keyword">end</span>
0317     xp2.permute(options.dim_stacking);
0318 <span class="keyword">end</span>
0319 
0320 
0321 
0322 <span class="comment">%% If doing force overlay, move overlay population to the end</span>
0323 <span class="keyword">if</span> ~isempty(force_last)
0324 
0325     <span class="comment">% If it's a stand-alone string, convert to cell array</span>
0326     <span class="keyword">if</span> ischar(force_last)
0327         force_last = {force_last};
0328     <span class="keyword">end</span>
0329 
0330     <span class="comment">% Functionalize this at some point... building list of requested axes</span>
0331     ax_names = xp2.exportAxisNames;
0332     ax_ind = zeros(1,length(force_last));
0333     <span class="keyword">for</span> i = 1:length(force_last)
0334         temp = xp2.findaxis(force_last{i});
0335         <span class="keyword">if</span> isempty(temp)
0336             error(<span class="string">'Requested axis not found. force_last must be one of the following: : %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0337         <span class="keyword">end</span>
0338         ax_ind(i) = temp;
0339     <span class="keyword">end</span>
0340 
0341 <span class="comment">%     % % Note: I am disabling this for now, because it is messing up</span>
0342 <span class="comment">%     certain plotting options. % %</span>
0343 <span class="comment">%     % Dims per subplot should be at least 2 if we're forcing last...</span>
0344 <span class="comment">%     % perhaps change this later</span>
0345 <span class="comment">%     if isempty(Ndims_per_subplot)</span>
0346 <span class="comment">%         Ndims_per_subplot = 2;</span>
0347 <span class="comment">%     end</span>
0348 <span class="comment">%     if Ndims_per_subplot == 1</span>
0349 <span class="comment">%         Ndims_per_subplot = 2;</span>
0350 <span class="comment">%     end</span>
0351 
0352     others_ind = true(1,ndims(xp2));
0353     others_ind(ax_ind) = false;
0354     xp2 = xp2.permute([find(others_ind), ax_ind]);        <span class="comment">% Move chosen axis to the back!</span>
0355     xp2 = xp2.fixAxes;                                   <span class="comment">% This permute can create naming issues if using default axis names (Dim 1, Dim 2, etc. For example, Dim2 can end up associated with xp2.axis(1)).</span>
0356 
0357 <span class="keyword">end</span>
0358 
0359 
0360 <span class="comment">%% If only one cell</span>
0361 
0362 <span class="comment">% If only 1 cell, move in 2nd cell</span>
0363 <span class="keyword">if</span> length(xp2.meta.datainfo(2).values) &lt;= 1 &amp;&amp; ~is_image
0364     <span class="comment">% Move populations axis to the end if it exists</span>
0365 
0366     ax2overlay = [];
0367     <span class="keyword">if</span> isempty(force_last) &amp;&amp; isempty(options.dim_stacking)
0368         ax2overlay = xp2.findaxis(<span class="string">'populations'</span>);           <span class="comment">% If force_last or dim_stacking isn't specified, then choose populations</span>
0369     <span class="keyword">end</span>
0370 
0371     <span class="keyword">if</span> isempty(ax2overlay)
0372         ax2overlay = xp2.ndims;     <span class="comment">% If can't find populations, use last axis on the stack</span>
0373     <span class="keyword">end</span>
0374 
0375     <span class="comment">% Save variables associated with this axis</span>
0376     packed_vars = xp2.axis(ax2overlay).values;
0377     packed_name = xp2.axis(ax2overlay).name;
0378 
0379     <span class="comment">% Add &lt;average&gt; symbols if necessary to packed_vars</span>
0380     cellnames = xp2.meta.datainfo(2).values;
0381     temp = cellfun(@isempty,strfind(cellnames,<span class="string">'&lt;'</span>));    <span class="comment">% Check if originals were averages!</span>
0382     <span class="keyword">if</span> any(~temp)
0383         <span class="keyword">if</span> isnumeric(packed_vars); packed_vars = cellfunu(@(s) [strrep(packed_name,<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> num2str(s)],num2cell(packed_vars)); <span class="keyword">end</span>
0384         packed_vars = cellfunu(@(s) [<span class="string">'&lt;'</span> s <span class="string">'&gt;'</span>], packed_vars);
0385     <span class="keyword">end</span>
0386 
0387     xp2.meta.datainfo(2).name = packed_name;
0388     xp2.meta.datainfo(2).values = packed_vars(:)';
0389 
0390     xp2 = xp2.packDim(ax2overlay,2);
0391     xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0392 <span class="keyword">end</span>
0393 
0394 <span class="comment">%% Set up do z-score &amp; overlay shift</span>
0395 <span class="keyword">if</span> options.do_zscore &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0396 
0397     <span class="comment">% xp2 = recursivePlot({@xp_parfor, @xpzscore}</span>
0398     mydata = xp2.data;
0399     <span class="keyword">for</span> i = 1:numel(mydata)
0400         mydata{i} = zscore(mydata{i});
0401     <span class="keyword">end</span>
0402     xp2.data = mydata;
0403 <span class="keyword">end</span>
0404 
0405 <span class="comment">% Shift the overlay by a certain amount</span>
0406     <span class="keyword">if</span> options.do_overlay_shift &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0407         <span class="keyword">if</span> isempty(Ndims_per_subplot) || Ndims_per_subplot &lt;= 1
0408             <span class="comment">% If xp2.data is going to be NxM, shift each column</span>
0409             mydata = xp2.data;
0410             <span class="keyword">for</span> i = 1:numel(mydata)
0411                 mydata{i} = <a href="#_sub21" class="code" title="subfunction mydata_out = do_shift_lastdim (mydata,shift)">do_shift_lastdim</a> (mydata{i},options.overlay_shift_val);
0412             <span class="keyword">end</span>
0413             xp2.data = mydata;
0414         <span class="keyword">else</span>
0415             <span class="comment">% If Ndims_per_subplot &gt; 1, then this means we're going to be</span>
0416             <span class="comment">% packing an additional dim into xp2.data. Therefore, shift the</span>
0417             <span class="comment">% last dimension in xp2. We'll do this by temporarily packing</span>
0418             <span class="comment">% it into xp2.data (e.g. along dim 4, which is unused) and then</span>
0419             <span class="comment">% unpacking it later.</span>
0420             sz = size(xp2);
0421             ind = find(sz &gt; 1, 1, <span class="string">'last'</span>);
0422             <span class="keyword">if</span> ~isempty(ind)
0423                 xp2 = xp2.packDim(ind,4);
0424             <span class="keyword">end</span>
0425             mydata = xp2.data;
0426             <span class="keyword">for</span> i = 1:numel(mydata)
0427                 mydata{i} = <a href="#_sub21" class="code" title="subfunction mydata_out = do_shift_lastdim (mydata,shift)">do_shift_lastdim</a> (mydata{i},options.overlay_shift_val);
0428             <span class="keyword">end</span>
0429             xp2.data = mydata;
0430             <span class="keyword">if</span> ~isempty(ind)
0431                 xp2 = xp2.unpackDim(4,ind);
0432                 xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0433             <span class="keyword">end</span>
0434         <span class="keyword">end</span>
0435     <span class="keyword">end</span>
0436 
0437 <span class="comment">%% Crop data</span>
0438 <span class="comment">% This is inserted here because apparently the operation is slow and it's</span>
0439 <span class="comment">% faster to do this after we've already squeezed / selected.</span>
0440 <span class="keyword">if</span> ~isempty(crop_range) &amp;&amp;  all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0441     t_temp = xp2.meta.datainfo(1).values;
0442     ind = (t_temp &gt; crop_range(1) &amp; t_temp &lt;= crop_range(2));
0443     <span class="keyword">for</span> i = 1:numel(xp2.data)
0444         <span class="keyword">if</span> ~isempty(xp2.data{i}); xp2.data{i} = xp2.data{i}(ind,:); <span class="keyword">end</span>
0445     <span class="keyword">end</span>
0446     xp2.meta.datainfo(1).values = t_temp(ind);
0447 
0448     <span class="comment">% Also crop DynaSim metadata info about time.</span>
0449     t_temp2 = xp2.meta.dynasim.time;
0450     ind = (t_temp2 &gt; crop_range(1) &amp; t_temp2 &lt;= crop_range(2));
0451     t_temp2 = t_temp2(ind);
0452     xp2.meta.dynasim.time = t_temp2;
0453 
0454 <span class="keyword">end</span>
0455 
0456 <span class="comment">%% Set up legend entries and axis limits</span>
0457 <span class="comment">% Set up legend entries</span>
0458 subplot_options.legend1 = <a href="#_sub22" class="code" title="subfunction leg1 = setup_legends(xp2)">setup_legends</a>(xp2);
0459 
0460 <span class="comment">% Get axis lims</span>
0461 <span class="keyword">if</span> isempty(plot_options.xlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0462         xdat = xp2.meta.datainfo(1).values;
0463         plot_options.xlims = [min(xdat) max(xdat)];
0464 <span class="keyword">end</span>
0465 <span class="keyword">if</span> isempty(plot_options.ylims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0466     <span class="keyword">switch</span> plot_type
0467         <span class="keyword">case</span> {<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>}
0468             <span class="comment">% Merge all data into one single huge column</span>
0469             data_all = xp2.data(:);
0470             data_all = cellfunu(@(x) x(:), data_all);
0471             data_all = vertcat(data_all{:});
0472             <span class="comment">% Find the max and minima - these are the largest and smallest</span>
0473             <span class="comment">% values we could ever see.</span>
0474             data_lims = [min(data_all) max(data_all)];
0475             plot_options.ylims = data_lims;
0476     <span class="keyword">end</span>
0477 <span class="keyword">end</span>
0478 
0479 <span class="keyword">if</span> isempty(plot_options.zlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0480     <span class="keyword">switch</span> plot_type
0481         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0482             data_all = xp2.data(:);
0483             data_all = cellfunu(@(x) x(:), data_all);
0484             data_all = vertcat(data_all{:});
0485             data_lims = [min(data_all) max(data_all)];
0486             plot_options.zlims = data_lims;
0487     <span class="keyword">end</span>
0488 <span class="keyword">end</span>
0489 
0490 <span class="comment">%% Prepare plotting handles for specific plot types</span>
0491 <span class="keyword">if</span> is_image
0492     <span class="comment">% Is an image</span>
0493     data_plothandle = @xp_plotimage;
0494     plot_options.scale = .5;           <span class="comment">% Scale of .5 enforces some anti-aliasing</span>
0495 <span class="keyword">else</span>
0496     <span class="keyword">switch</span> plot_type
0497         <span class="keyword">case</span> <span class="string">'waveform'</span>
0498             <span class="comment">% Is data</span>
0499             data_plothandle = @xp1D_matrix_plot;
0500             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0501         <span class="keyword">case</span> <span class="string">'waveformErr'</span>
0502             data_plothandle = @xp1D_matrix_boundedline;
0503             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0504         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0505             data_plothandle = @xp_matrix_imagesc;
0506             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0507             <span class="comment">% Disable legend when using imagesc</span>
0508             subplot_options.legend1 = [];
0509             <span class="comment">% Add time information</span>
0510             plot_options.xdat = xp2.meta.datainfo(1).values;
0511             <span class="comment">% Control colorbar</span>
0512             <span class="keyword">if</span> lock_axes
0513                 <span class="comment">% If axes are locked, only need to show 1 colorbar across</span>
0514                 <span class="comment">% all subplots</span>
0515                 subplot_options.do_colorbar = options.show_colorbar;
0516                 plot_options.do_colorbar = false;
0517 <span class="comment">%                 subplot_options.do_colorbar = false;</span>
0518 <span class="comment">%                 plot_options.do_colorbar = true;</span>
0519             <span class="keyword">else</span>
0520                 subplot_options.do_colorbar = false;
0521                 plot_options.do_colorbar = options.show_colorbar;
0522             <span class="keyword">end</span>
0523 
0524         <span class="keyword">case</span> {<span class="string">'power'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}
0525             <span class="comment">% Disable legend when using dsPlot</span>
0526             subplot_options.legend1 = [];
0527 
0528             <span class="comment">% Setup call to xp_PlotData</span>
0529             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0530             data_plothandle = @<a href="../functions/internal/xp_libraries/xp_PlotData.html" class="code" title="function hxp = xp_PlotData (xp, op)">xp_PlotData</a>;
0531             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0532 
0533             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>})) &amp;&amp; isempty(force_last) &amp;&amp; isempty(options.dim_stacking)
0534                 <span class="comment">% Move populations axis to the end of xp2. (Only do this if</span>
0535                 <span class="comment">% we're not already overwriting dims stacking order).</span>
0536                 ax_names = xp2.exportAxisNames;
0537                 ind_pop = false(1,length(ax_names));
0538                 ind_pop(xp2.findaxis(<span class="string">'populations'</span>)) = true;
0539                 ind_rest = ~ind_pop;
0540                 order = [find(ind_rest) find(ind_pop)];
0541                 xp2 = xp2.permute(order);
0542             <span class="keyword">end</span>
0543             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}))
0544                 <span class="comment">% Force Ndims_per_subplot to 2 fro rastergram.</span>
0545                 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0546                     <span class="keyword">if</span> ~isempty(xp2.findaxis(<span class="string">'populations'</span>))
0547                         Ndims_per_subplot = 2;                 <span class="comment">% Overwrite Ndims_per_subplot to 2. This ensures</span>
0548                                                                <span class="comment">% that multiple populations can be stacked in a</span>
0549                                                                <span class="comment">% single subplot.</span>
0550                     <span class="keyword">else</span>
0551                         Ndims_per_subplot = 1;                 <span class="comment">% Only do this if population axis is still present!</span>
0552                     <span class="keyword">end</span>
0553                 <span class="keyword">end</span>
0554 
0555             <span class="keyword">end</span>
0556 
0557         <span class="keyword">case</span> {<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>}
0558             <span class="comment">% Disable legend when using dsPlotFR2</span>
0559             subplot_options.legend1 = [];
0560             <span class="comment">% Remove FR suffix from heatmap and heatmap_sorted plot types</span>
0561             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>}))
0562                 plot_type = strrep(plot_type,<span class="string">'FR'</span>,<span class="string">''</span>);
0563             <span class="keyword">end</span>
0564 
0565             <span class="comment">% Setup call to xp_PlotFR2</span>
0566             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0567             data_plothandle = @<a href="../functions/internal/xp_libraries/xp_PlotFR2.html" class="code" title="function hxp = xp_PlotFR2 (xp, op)">xp_PlotFR2</a>;
0568             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0569             
0570         <span class="keyword">case</span> {<span class="string">'FRpanel'</span>}
0571             data_plothandle = @<a href="../functions/internal/xp_libraries/xp_PlotFRpanel.html" class="code" title="function hxp = xp_PlotFRpanel (xp, op)">xp_PlotFRpanel</a>;
0572             
0573             <span class="comment">% Axis indices of populations</span>
0574             ax_ind_var = xp2.findaxis(<span class="string">'variables'</span>);
0575             ax_ind_pop = xp2.findaxis(<span class="string">'population'</span>);
0576             <span class="comment">%ax_ind_varied = findaxis_varied(xp2);</span>
0577             ax_ind_other = setdiff(1:ndims(xp2),[ax_ind_var, ax_ind_pop]);
0578 
0579             <span class="comment">% Permute to put varied variables last</span>
0580             myorder = [ax_ind_other(:)', ax_ind_var, ax_ind_pop];
0581             <span class="keyword">if</span> length(myorder) &gt; 1
0582                 xp2 = permute(xp2,myorder);
0583             <span class="keyword">end</span>
0584             
0585             Ndims_per_subplot = 1 + ~isempty(ax_ind_pop) + ~isempty(ax_ind_var);    <span class="comment">% Allows for multiple populations to get passed to dsPlotFR to produce the panel</span>
0586             num_embedded_subplots = 0;                                              <span class="comment">% No subplotting</span>
0587     <span class="keyword">end</span>
0588 <span class="keyword">end</span>
0589 
0590 <span class="comment">% If Ndims_per_subplot has not been set yet, set it now!</span>
0591 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0592     Ndims_per_subplot = 1;
0593 <span class="keyword">end</span>
0594 
0595 <span class="comment">%% Prepare plotting structure depending on number of embedded subplots</span>
0596 <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0597 <span class="comment">% axis handle</span>
0598 <span class="keyword">switch</span> num_embedded_subplots
0599     <span class="keyword">case</span> 0
0600         <span class="comment">% Ordering of axis handles</span>
0601         <a name="_sub1" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0602         dims_per_function_handle = [1,Ndims_per_subplot];
0603         <a name="_sub2" href="#_subfunctions" class="code">function_args = {{figure_options},{plot_options}};</a>
0604     <span class="keyword">case</span> 1
0605         <span class="comment">% Ordering of axis handles</span>
0606         <a name="_sub3" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, subplot_handle,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0607         dims_per_function_handle = [1,1,Ndims_per_subplot];
0608         <a name="_sub4" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0609 
0610     <span class="keyword">case</span> 2
0611         <span class="comment">% Ordering of axis handles</span>
0612         <a name="_sub5" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, subplot_handle,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0613         dims_per_function_handle = [1,2,Ndims_per_subplot];
0614         <a name="_sub6" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0615 
0616     <span class="keyword">case</span> 3
0617         <span class="comment">% Ordering of axis handles</span>
0618         <a name="_sub7" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, subplot_handle, subplot_handle,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0619         dims_per_function_handle = [1,2,1,Ndims_per_subplot];
0620         subplot_options2 = subplot_options;
0621         subplot_options2.legend1 = [];
0622         subplot_options.display_mode = 1;
0623         <a name="_sub8" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0624     <span class="keyword">case</span> 4
0625         <span class="comment">% Ordering of axis handles</span>
0626         <a name="_sub9" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, subplot_handle, subplot_handle,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0627         dims_per_function_handle = [1,2,2,Ndims_per_subplot];
0628         subplot_options2 = subplot_options;
0629         subplot_options2.legend1 = [];
0630         subplot_options.display_mode = 1;
0631         <a name="_sub10" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0632 <span class="keyword">end</span>
0633 
0634 <span class="comment">%% Auto trim dimensions as needed</span>
0635 <span class="comment">% Linearize dimensions of xp2 that are in excess of the total number we can</span>
0636 <span class="comment">% plot</span>
0637 maxNplotdims = sum(dims_per_function_handle)-1;
0638 xp2 = <a href="#_sub18" class="code" title="subfunction xp2 = reduce_dims(xp2,maxNplotdims)">reduce_dims</a>(xp2,maxNplotdims);
0639 
0640 <span class="comment">% Stack up available dimensions based on how much each axis handle can hold</span>
0641 ax_names = [xp2.exportAxisNames, <span class="string">'data'</span>];
0642 
0643 dimensions = <a href="#_sub17" class="code" title="subfunction dimensions = get_dimensions(ax_names,dims_per_function_handle)">get_dimensions</a>(ax_names,dims_per_function_handle);
0644 
0645 
0646 <span class="comment">% Remove any excess function handles that aren't needed</span>
0647 available_dims = ~cellfun(@isempty,dimensions);
0648 <a name="_sub11" href="#_subfunctions" class="code">function_handles = function_handles(available_dims);</a>
0649 dimensions = dimensions(available_dims);
0650 <a name="_sub12" href="#_subfunctions" class="code">function_args = function_args(available_dims);</a>
0651 
0652 <span class="comment">%% Run the plots!</span>
0653 <span class="comment">% Open new figure if necessary &amp; plot the data</span>
0654 <span class="keyword">if</span> ~isequal(@xp_handles_newfig, <a href="#_sub11" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>{1})
0655     <span class="comment">% Cheap hack to force it to create a new figure using our desired</span>
0656     <span class="comment">% parameters for instances when it wouldn't normally call</span>
0657     <span class="comment">% xp_handles_newfig.</span>
0658     xp3 = MDD;
0659     fhandle = @() recursivePlot(xp2,<a href="#_sub11" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub12" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0660     xp3 = xp3.importData({fhandle});
0661     handles = xp_handles_newfig(xp3,figure_options);
0662 <span class="keyword">else</span>
0663     handles = xp2.recursivePlot(<a href="#_sub11" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub12" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0664 <span class="keyword">end</span>
0665 
0666 
0667 <span class="keyword">end</span>
0668 
0669 
0670 <a name="_sub13" href="#_subfunctions" class="code">function var_out = getdefaultstatevar(xp)</a>
0671     <span class="comment">% search through and try to find the variable represnting voltage. If can't find</span>
0672     <span class="comment">% it, just return the first variable listed.</span>
0673 
0674     <span class="comment">% See if variables axis even exists</span>
0675     <span class="keyword">if</span> isempty(xp.findaxis(<span class="string">'variables'</span>))
0676         <span class="comment">% If reach here, it means variables is not used in the code. Just</span>
0677         <span class="comment">% return some dummy values and move on.</span>
0678         var_out = <span class="string">':'</span>;
0679         <span class="keyword">return</span>;
0680     <span class="keyword">end</span>
0681 
0682     vars_from_labels = <a href="../functions/internal/dsGet_variables_from_meta.html" class="code" title="function varlabels = dsGet_variables_from_meta(xp)">dsGet_variables_from_meta</a>(xp);
0683     <span class="keyword">if</span> ~isempty(vars_from_labels)
0684         vars_from_labels = vars_from_labels(1);   <span class="comment">% Best guess at default state variable. Usually its the 1st entry in labels</span>
0685     <span class="keyword">end</span>
0686 
0687     <span class="comment">% Pull out variables</span>
0688     vars_orig = xp.axis(<span class="string">'variables'</span>).values;
0689 
0690     <span class="comment">% Make everything uppercase to ensure</span>
0691     <span class="comment">% case-insensitive.</span>
0692     vars = upper(vars_orig);
0693     possibilities = upper({vars_from_labels{:},<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'Vm'</span>,<span class="string">'Xm'</span>,<span class="string">'Y'</span>,<span class="string">'Ym'</span>});
0694 
0695     ind = [];
0696     i=0;
0697     <span class="keyword">while</span> isempty(ind) &amp;&amp; i &lt; length(possibilities)
0698         i=i+1;
0699         ind = find(strcmpi(vars,possibilities{i}));
0700     <span class="keyword">end</span>
0701 
0702     <span class="keyword">if</span> ~isempty(ind)
0703         var_out = vars_orig{ind};
0704     <span class="keyword">else</span>
0705         var_out = vars_orig{1};
0706     <span class="keyword">end</span>
0707 <span class="keyword">end</span>
0708 
0709 <a name="_sub14" href="#_subfunctions" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a>
0710 
0711     <span class="comment">% Initialize output</span>
0712     chosen_varied = repmat({<span class="string">':'</span>},1,length(varied_names));
0713 
0714     <span class="comment">% Varied name-value pairs entered by user</span>
0715     varied_NVPs = fieldnames(options_varied);
0716 
0717     <span class="comment">% See if any of these match actual varied parameters</span>
0718     <span class="keyword">for</span> i =  1:length(varied_NVPs)
0719         ind = find(strcmp(varied_names,varied_NVPs{i}));
0720         <span class="keyword">if</span> length(ind) == 1
0721             chosen_varied{ind} = options_varied.(varied_NVPs{i});
0722 
0723             <span class="comment">% Optional (remove from options_varied)</span>
0724             options_varied = rmfield(options_varied,varied_NVPs{i});
0725         <span class="keyword">elseif</span> length(ind) &gt; 1
0726             error(<span class="string">'Multiple varied arguments found'</span>);
0727         <span class="keyword">else</span>
0728             <span class="comment">% Not a varied variable name</span>
0729         <span class="keyword">end</span>
0730 
0731 
0732     <span class="keyword">end</span>
0733 
0734 <span class="keyword">end</span>
0735 
0736 <a name="_sub15" href="#_subfunctions" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a>
0737 
0738         <span class="keyword">if</span> strcmp(str_in(1:min(6,end)),<span class="string">'varied'</span>)        <span class="comment">% User has entered variedX</span>
0739             <span class="comment">% fn is original fieldname (e.g. variedX)</span>
0740             <span class="comment">% fn2 is new field name of varied parameter (e.g. E_Iapp)</span>
0741             str_out = ax_names_varied{str2num(str_in(7:end))};
0742         <span class="keyword">else</span>
0743             str_out = str_in;
0744         <span class="keyword">end</span>
0745 
0746 <span class="keyword">end</span>
0747 
0748 <a name="_sub16" href="#_subfunctions" class="code">function ax_ind_varied = findaxis_varied(xp)</a>
0749     <span class="comment">% Uses metadata to identify a list of varied variables. Then validates</span>
0750     <span class="comment">% that they match the available axis names and returns their index.</span>
0751     varied = xp.meta.dynasim.varied;
0752     ax_names = xp.exportAxisNames;
0753     ax_ind_varied = false(1,length(ax_names));
0754     <span class="keyword">for</span> i = 1:length(varied)
0755         ind = strcmp(varied{i},ax_names);
0756         <span class="keyword">if</span> sum(ind) ~= 1; error(<span class="string">'Varied axis not found OR something wrong with varied label'</span>); <span class="keyword">end</span>
0757         ax_ind_varied = ax_ind_varied | ind;
0758     <span class="keyword">end</span>
0759 
0760     ax_ind_varied = find(ax_ind_varied);
0761 <span class="keyword">end</span>
0762 
0763 <a name="_sub17" href="#_subfunctions" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a>
0764     <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0765     <span class="comment">% axis handle</span>
0766 
0767     i = length(dims_per_function_handle);
0768     <span class="keyword">while</span> i &gt; 0 &amp;&amp; ~isempty(ax_names)
0769 
0770         Ndims_curr = dims_per_function_handle(i);
0771         dimensions{i} = ax_names(max(1,end-Ndims_curr+1):end);
0772         ax_names = ax_names(1:end-Ndims_curr);
0773         i=i-1;
0774     <span class="keyword">end</span>
0775 
0776 <span class="keyword">end</span>
0777 
0778 <a name="_sub18" href="#_subfunctions" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a>
0779     Nd = ndims(xp2);
0780     <span class="keyword">if</span> Nd &gt; maxNplotdims
0781         xp2 = xp2.mergeDims( [maxNplotdims:Nd] );
0782         xp2 = xp2.squeeze;
0783         Nd = ndims(xp2);
0784 
0785         <span class="keyword">if</span> Nd ~= maxNplotdims; error(<span class="string">'something wrong'</span>); <span class="keyword">end</span>
0786     <span class="keyword">end</span>
0787 <span class="keyword">end</span>
0788 
0789 <a name="_sub19" href="#_subfunctions" class="code">function varied_names = only_varieds(xp)</a>
0790     <span class="comment">% Get list of varied axis names</span>
0791     varied_names = xp.meta.dynasim.varied;
0792 
0793     <span class="comment">% Make sure that they are acutally in xp.axis.names.</span>
0794     <a href="#_sub16" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp); <span class="comment">% This function will return an error if they are missing!</span>
0795 
0796 <span class="keyword">end</span>
0797 
0798 <a name="_sub20" href="#_subfunctions" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a>
0799     warning(<span class="string">'update this command or possibly merge with findaxis_varied'</span>);
0800     inds = true(1,length(all_names));
0801     inds(strcmp(all_names,<span class="string">'populations'</span>)) = false;
0802     inds(strcmp(all_names,<span class="string">'variables'</span>)) = false;
0803     varied_names = all_names(inds);
0804 <span class="keyword">end</span>
0805 
0806 <a name="_sub21" href="#_subfunctions" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a>
0807     sz = size(mydata);
0808     nd = ndims(mydata);
0809 
0810     <span class="keyword">if</span> isempty(shift)
0811         <span class="comment">% Do adaptive shift</span>
0812         upscale_factor = 2;
0813         temp = reshape(mydata,prod(sz(1:nd-1)),sz(nd));
0814         <span class="keyword">if</span> ~strcmp(reportUI,<span class="string">'matlab'</span>) &amp;&amp; exist(<span class="string">'nanstd'</span>) ~= 2 <span class="comment">% 'nanstd is not in Octave's path</span>
0815           <span class="keyword">try</span>
0816             pkg load statistics; <span class="comment">% trying to load octave forge 'statistics' package before using nanstd function</span>
0817           <span class="keyword">catch</span>
0818             error(<span class="string">'nanstd function is needed, please install the statistics package from Octave Forge'</span>);
0819           <span class="keyword">end</span>
0820         <span class="keyword">end</span>
0821         stdevs = nanstd(temp)*upscale_factor;               <span class="comment">% STD ignoring NaNs</span>
0822         sh = [0, stdevs(1:end-1) + stdevs(2:end)]';
0823         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0824         sh = cumsum(sh);     <span class="comment">% Dave note - this seemed to be missing so added it for case of size(Nd)=2; not sure if it will mess up other cases.</span>
0825     <span class="keyword">else</span>
0826         sh = shift*[0:sz(end)-1]';      <span class="comment">% Fixed shift amount</span>
0827         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0828     <span class="keyword">end</span>
0829 
0830 
0831     sh = permute(sh, [2:nd,1]);
0832     <span class="keyword">if</span> length(sz(1:nd-1)) == 1
0833         sh2 = repmat(sh, sz(1:nd-1),1);     <span class="comment">% Special case for scalar input to repmat. When repmat receives a scalar, it repeats BOTH rows and columns instead of just rows</span>
0834     <span class="keyword">else</span>
0835         sh2 = repmat(sh, sz(1:nd-1));
0836     <span class="keyword">end</span>
0837 
0838     mydata_out = mydata + sh2;
0839 
0840 <span class="keyword">end</span>
0841 
0842 <a name="_sub22" href="#_subfunctions" class="code">function leg1 = setup_legends(xp2)</a>
0843 
0844     <span class="comment">% Pull out all metadata names and values</span>
0845     <span class="keyword">for</span> i = 1:length(xp2.meta.datainfo)
0846         mn{i} = xp2.meta.datainfo(i).name;
0847         mv{i} = xp2.meta.datainfo(i).values;
0848     <span class="keyword">end</span>
0849 
0850     <span class="comment">% Convert any numeric entries to cell strings as needed</span>
0851     <span class="keyword">for</span> i = 2:length(xp2.meta.datainfo)
0852         <span class="keyword">if</span> isnumeric(mv{i})
0853             <span class="comment">% If axis is numeric, as in the case with varied parameters, convert to</span>
0854             <span class="comment">% a cell array of strings</span>
0855             mv{i} = cellfun(@num2str,num2cell(mv{i}),<span class="string">'UniformOutput'</span>,0);
0856 
0857             <span class="comment">% Also pre-pend the name of the variable being varied</span>
0858             <span class="keyword">for</span> j = 1:length(mv{i})
0859                 mv{i}{j} = [strrep(mn{i},<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> mv{i}{j}];
0860             <span class="keyword">end</span>
0861         <span class="keyword">end</span>
0862     <span class="keyword">end</span>
0863 
0864     <span class="keyword">if</span> length(mv) == 2
0865         leg1 = mv{2};
0866     <span class="keyword">elseif</span> length(mv) == 3
0867         <span class="comment">%Cartesean product of mv{2} and mv{3}</span>
0868         k = 0;
0869         <span class="keyword">for</span> j = 1:length(mv{3})
0870             <span class="keyword">for</span> i = 1:length(mv{2})         <span class="comment">% We plot the 2nd dimension 1st; they are grouped together</span>
0871                 k=k+1;
0872                 leg1{k} = [mv{2}{i} <span class="string">' '</span> mv{3}{j}];
0873             <span class="keyword">end</span>
0874         <span class="keyword">end</span>
0875     <span class="keyword">else</span>
0876         error(<span class="string">'should not reach'</span>);
0877     <span class="keyword">end</span>
0878 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 12-Dec-2017 11:32:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>