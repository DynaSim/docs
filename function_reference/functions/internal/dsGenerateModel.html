<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsGenerateModel</title>
  <meta name="keywords" content="dsGenerateModel">
  <meta name="description" content="GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>

<a name="_top"></a>
<div><a href="../../menu.html">Home</a> &gt;  <a href="../menu.html">functions</a> &gt; <a href="menu.html">internal</a> &gt; dsGenerateModel.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../menu.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for functions/internal&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>dsGenerateModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [model,name_map] = dsGenerateModel(specification, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure

 Usage:
   [model,name_map]=dsGenerateModel(specification,'option',value,...)

 Inputs:
   - specification: one of:
     - DynaSim specification structure (see below and dsCheckSpecification for more details)
     - string with name of MAT-file containing DynaSim specification structure
     - string with equations
     - string with name of file containing equations (.eqns)
       note: .eqns files can also be converted into model structure using LoadModel()
   - options (with defaults): 'option1',value1,'option2',value2,...
     'modifications'  : specify modifications to apply to specification
                        before generating the model, see dsApplyModifications
                        for more details (default?: []).
     'open_link_flag' : whether to leave linker identifiers in place (default: 0)
     'auto_gen_test_data_flag': whether to save model for unit testing (default: 0)

 Outputs:
   - model: DynaSim model structure (see dsCheckModel for more details):
     .parameters      : substructure with model parameters
     .fixed_variables : substructure with fixed variable definitions
     .functions       : substructure with function definitions
     .monitors        : substructure with monitor definitions
     .state_variables : cell array listing state variables
     .ODEs            : substructure with one ordinary differential
                             equation (ODE) per state variable
     .ICs             : substructure with initial conditions (ICs) for
                             each state variable
     .conditionals(i) : structure array with each element indicating
                             conditional actions specified in subfields
                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in dsCheckModel)
     .linkers(i)      : structure array with each element indicating
                             an &quot;expression&quot; that should be inserted
                             (according to &quot;operation&quot;) into any equations
                             where the &quot;target&quot; appears. (see NOTE 2 in dsCheckModel)
       .target    : string giving the target where expression should be inserted
       .expression: string giving the expression to insert
       .operation : string giving the operation to use to insert expression
     .comments{i}     : cell array of comments found in model files
     .specification   : specification used to generate the model
     .namespaces      : (see NOTE 3 in dsCheckModel)
   - name_map: cell matrix mapping parameter, variable, and function names
       between the user-created specification (population equations and mechanism
       files) and the full model with automatically generated namespaces. It
       has four columns with: user-specified name, name with namespace prefix,
       namespace, and type ('parameters', 'fixed_variables', 'state_variables',
       'functions', or 'monitors') indicating the category to which the named
       element belongs.

 - DynaSim specification structure (see dsCheckSpecification for more details)
   .populations(i) (required): contains info for defining independent population models
       .name (default: 'pop1')      : name of population
       .size (default: 1)           : number of elements in population (i.e., # cells)
       .equations (required)        : string listing equations (see NOTE 1 in dsCheckSpecification)
       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2
                                      in dsCheckSpecification)
       .parameters (default: [])    : parameters to assign across all equations in
         the population. provide as cell array list of key/value pairs
         {'param1',value1,'param2',value2,...}
       .model (default: [])   : optional DynaSim model structure
   .connections(i) (default: []): contains info for linking population models
       .source (required if &gt;1 pops): name of OUT population
       .target (required if &gt;1 pops): name of target population
       .mechanism_list (required)   : list of mechanisms that link two populations
       .parameters (default: [])    : parameters to assign across all equations in
         mechanisms of this connection's mechanism_list.

 Examples:
   - Example 0:
     model=dsGenerateModel('db/dt=3')

   - Example 1: Lorenz equations
     eqns={
       's=10; r=27; b=2.666';
       'dx/dt=s*(y-x)';
       'dy/dt=r*x-y-x*z';
       'dz/dt=-b*z+x*y';
     };
     model=dsGenerateModel(eqns)

   - Example 2: Leaky integrate-and-fire neuron
     model=dsGenerateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')

   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive
     model=dsGenerateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')

   - Example 4: HH with self inhibition and sinusoidal drive
     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa','iK'};
     specification.connections(1).mechanism_list={'iGABAa'};
     specification.connections(1).parameters={'tauDx',15};
     model=dsGenerateModel(specification)

   - Example 5: using custom mechanism alias in equations (for modularization)
     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa@M','iK@M'};
     model=dsGenerateModel(specification)

     or:

     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';
     model=dsGenerateModel(specification)

   - Example 6: directly incorporating mechanism models from online repositories:

     model=dsGenerateModel('dv/dt=@M; {ib:57,iK}@M')

     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,
     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.
     note: currently not supported on *most* machines...

 See also: <a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>, <a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>, <a href="dsParseModelEquations.html" class="code" title="function [model,name_map] = dsParseModelEquations(text,varargin)">dsParseModelEquations</a>, dsSimulate

 Author: Jason Sherfey, PhD &lt;jssherfey@gmail.com&gt;
 Copyright (C) 2016 Jason Sherfey, Boston University, USA</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>	CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</li><li><a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>	COMBINEMODELS - combine subfields in two DynaSim model structures</li><li><a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>	IMPORTMODEL - import model from raw equations, other program source, etc.</li><li><a href="dsPropagateNamespaces.html" class="code" title="function model = dsPropagateNamespaces(model,map, varargin)">dsPropagateNamespaces</a>	PROPAGATENAMESPACES - namespace-establishing namespace substitutions.</li><li><a href="dsStrrep.html" class="code" title="function str = dsStrrep(str,oldstr,newstr,lpad,rpad, varargin)">dsStrrep</a>	STRREP - replace full words by new character strings, ignoring matches that appear as sub-strings.</li><li><a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>	Inputs:</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../functions/dynasim.html" class="code" title="function dynasim(spec)">dynasim</a>	DynaSim GUI</li><li><a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="dsProbeCellProperties.html" class="code" title="function data = dsProbeCellProperties(model,varargin)">dsProbeCellProperties</a>	data = dsProbeCellProperties(model,'option1',option1,...)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub2" class="code">function_names={};</a></li><li><a href="#_sub3" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a></li><li><a href="#_sub4" class="code">functions_to_monitor={};</a></li><li><a href="#_sub5" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a></li><li><a href="#_sub6" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a></li><li><a href="#_sub7" class="code">functions_to_monitor=unique_wrapper(functions_to_monitor);</a></li><li><a href="#_sub8" class="code">function add_keywords(src,dst,namespace)</a></li><li><a href="#_sub9" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub10" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,name_map] = dsGenerateModel(specification, varargin)</a>
0002 <span class="comment">%GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   [model,name_map]=dsGenerateModel(specification,'option',value,...)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   - specification: one of:</span>
0009 <span class="comment">%     - DynaSim specification structure (see below and dsCheckSpecification for more details)</span>
0010 <span class="comment">%     - string with name of MAT-file containing DynaSim specification structure</span>
0011 <span class="comment">%     - string with equations</span>
0012 <span class="comment">%     - string with name of file containing equations (.eqns)</span>
0013 <span class="comment">%       note: .eqns files can also be converted into model structure using LoadModel()</span>
0014 <span class="comment">%   - options (with defaults): 'option1',value1,'option2',value2,...</span>
0015 <span class="comment">%     'modifications'  : specify modifications to apply to specification</span>
0016 <span class="comment">%                        before generating the model, see dsApplyModifications</span>
0017 <span class="comment">%                        for more details (default?: []).</span>
0018 <span class="comment">%     'open_link_flag' : whether to leave linker identifiers in place (default: 0)</span>
0019 <span class="comment">%     'auto_gen_test_data_flag': whether to save model for unit testing (default: 0)</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% Outputs:</span>
0022 <span class="comment">%   - model: DynaSim model structure (see dsCheckModel for more details):</span>
0023 <span class="comment">%     .parameters      : substructure with model parameters</span>
0024 <span class="comment">%     .fixed_variables : substructure with fixed variable definitions</span>
0025 <span class="comment">%     .functions       : substructure with function definitions</span>
0026 <span class="comment">%     .monitors        : substructure with monitor definitions</span>
0027 <span class="comment">%     .state_variables : cell array listing state variables</span>
0028 <span class="comment">%     .ODEs            : substructure with one ordinary differential</span>
0029 <span class="comment">%                             equation (ODE) per state variable</span>
0030 <span class="comment">%     .ICs             : substructure with initial conditions (ICs) for</span>
0031 <span class="comment">%                             each state variable</span>
0032 <span class="comment">%     .conditionals(i) : structure array with each element indicating</span>
0033 <span class="comment">%                             conditional actions specified in subfields</span>
0034 <span class="comment">%                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in dsCheckModel)</span>
0035 <span class="comment">%     .linkers(i)      : structure array with each element indicating</span>
0036 <span class="comment">%                             an &quot;expression&quot; that should be inserted</span>
0037 <span class="comment">%                             (according to &quot;operation&quot;) into any equations</span>
0038 <span class="comment">%                             where the &quot;target&quot; appears. (see NOTE 2 in dsCheckModel)</span>
0039 <span class="comment">%       .target    : string giving the target where expression should be inserted</span>
0040 <span class="comment">%       .expression: string giving the expression to insert</span>
0041 <span class="comment">%       .operation : string giving the operation to use to insert expression</span>
0042 <span class="comment">%     .comments{i}     : cell array of comments found in model files</span>
0043 <span class="comment">%     .specification   : specification used to generate the model</span>
0044 <span class="comment">%     .namespaces      : (see NOTE 3 in dsCheckModel)</span>
0045 <span class="comment">%   - name_map: cell matrix mapping parameter, variable, and function names</span>
0046 <span class="comment">%       between the user-created specification (population equations and mechanism</span>
0047 <span class="comment">%       files) and the full model with automatically generated namespaces. It</span>
0048 <span class="comment">%       has four columns with: user-specified name, name with namespace prefix,</span>
0049 <span class="comment">%       namespace, and type ('parameters', 'fixed_variables', 'state_variables',</span>
0050 <span class="comment">%       'functions', or 'monitors') indicating the category to which the named</span>
0051 <span class="comment">%       element belongs.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% - DynaSim specification structure (see dsCheckSpecification for more details)</span>
0054 <span class="comment">%   .populations(i) (required): contains info for defining independent population models</span>
0055 <span class="comment">%       .name (default: 'pop1')      : name of population</span>
0056 <span class="comment">%       .size (default: 1)           : number of elements in population (i.e., # cells)</span>
0057 <span class="comment">%       .equations (required)        : string listing equations (see NOTE 1 in dsCheckSpecification)</span>
0058 <span class="comment">%       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2</span>
0059 <span class="comment">%                                      in dsCheckSpecification)</span>
0060 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0061 <span class="comment">%         the population. provide as cell array list of key/value pairs</span>
0062 <span class="comment">%         {'param1',value1,'param2',value2,...}</span>
0063 <span class="comment">%       .model (default: [])   : optional DynaSim model structure</span>
0064 <span class="comment">%   .connections(i) (default: []): contains info for linking population models</span>
0065 <span class="comment">%       .source (required if &gt;1 pops): name of OUT population</span>
0066 <span class="comment">%       .target (required if &gt;1 pops): name of target population</span>
0067 <span class="comment">%       .mechanism_list (required)   : list of mechanisms that link two populations</span>
0068 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0069 <span class="comment">%         mechanisms of this connection's mechanism_list.</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% Examples:</span>
0072 <span class="comment">%   - Example 0:</span>
0073 <span class="comment">%     model=dsGenerateModel('db/dt=3')</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%   - Example 1: Lorenz equations</span>
0076 <span class="comment">%     eqns={</span>
0077 <span class="comment">%       's=10; r=27; b=2.666';</span>
0078 <span class="comment">%       'dx/dt=s*(y-x)';</span>
0079 <span class="comment">%       'dy/dt=r*x-y-x*z';</span>
0080 <span class="comment">%       'dz/dt=-b*z+x*y';</span>
0081 <span class="comment">%     };</span>
0082 <span class="comment">%     model=dsGenerateModel(eqns)</span>
0083 <span class="comment">%</span>
0084 <span class="comment">%   - Example 2: Leaky integrate-and-fire neuron</span>
0085 <span class="comment">%     model=dsGenerateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive</span>
0088 <span class="comment">%     model=dsGenerateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')</span>
0089 <span class="comment">%</span>
0090 <span class="comment">%   - Example 4: HH with self inhibition and sinusoidal drive</span>
0091 <span class="comment">%     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';</span>
0092 <span class="comment">%     specification.populations(1).mechanism_list={'iNa','iK'};</span>
0093 <span class="comment">%     specification.connections(1).mechanism_list={'iGABAa'};</span>
0094 <span class="comment">%     specification.connections(1).parameters={'tauDx',15};</span>
0095 <span class="comment">%     model=dsGenerateModel(specification)</span>
0096 <span class="comment">%</span>
0097 <span class="comment">%   - Example 5: using custom mechanism alias in equations (for modularization)</span>
0098 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';</span>
0099 <span class="comment">%     specification.populations(1).mechanism_list={'iNa@M','iK@M'};</span>
0100 <span class="comment">%     model=dsGenerateModel(specification)</span>
0101 <span class="comment">%</span>
0102 <span class="comment">%     or:</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';</span>
0105 <span class="comment">%     model=dsGenerateModel(specification)</span>
0106 <span class="comment">%</span>
0107 <span class="comment">%   - Example 6: directly incorporating mechanism models from online repositories:</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%     model=dsGenerateModel('dv/dt=@M; {ib:57,iK}@M')</span>
0110 <span class="comment">%</span>
0111 <span class="comment">%     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,</span>
0112 <span class="comment">%     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.</span>
0113 <span class="comment">%     note: currently not supported on *most* machines...</span>
0114 <span class="comment">%</span>
0115 <span class="comment">% See also: dsCheckSpecification, dsCheckModel, dsParseModelEquations, dsSimulate</span>
0116 <span class="comment">%</span>
0117 <span class="comment">% Author: Jason Sherfey, PhD &lt;jssherfey@gmail.com&gt;</span>
0118 <span class="comment">% Copyright (C) 2016 Jason Sherfey, Boston University, USA</span>
0119 
0120 <span class="comment">% Check inputs</span>
0121 <span class="comment">% ------------------------------------------------------</span>
0122 <span class="keyword">if</span> nargin==0
0123   <span class="comment">% use default model</span>
0124   specification=[];
0125   specification.populations(1).equations=<span class="string">'dv/dt=10+@current/Cm; Cm=1; v(0)=-65'</span>;
0126   specification.populations(1).mechanism_list={<span class="string">'iNa'</span>,<span class="string">'iK'</span>};
0127   specification.populations(1).parameters={<span class="string">'Cm'</span>,1};
0128   specification.connections(1).mechanism_list={<span class="string">'iGABAa'</span>};
0129   varargin={<span class="string">'modifications'</span>,[]};
0130 <span class="keyword">end</span>
0131 <span class="comment">% ------------------------------------------------------</span>
0132 
0133 options=<a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>(varargin,{<span class="keyword">...</span>
0134   <span class="string">'modifications'</span>,[],[],<span class="keyword">...</span>
0135   <span class="string">'open_link_flag'</span>,0,{0,1},<span class="keyword">...</span>
0136   <span class="string">'auto_gen_test_data_flag'</span>,0,{0,1},<span class="keyword">...</span>
0137   },false);
0138 
0139 <span class="keyword">if</span> options.auto_gen_test_data_flag
0140   varargs = varargin;
0141   varargs{<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(strcmp(varargs, <span class="string">'auto_gen_test_data_flag'</span>))+1} = 0;
0142   varargs(end+1:end+2) = {<span class="string">'unit_test_flag'</span>,1};
0143   argin = [{specification}, varargs]; <span class="comment">% specific to this function</span>
0144 <span class="keyword">end</span>
0145 
0146 <span class="comment">% check if a model</span>
0147 <span class="keyword">if</span> isfield(specification,<span class="string">'state_variables'</span>)
0148   <span class="comment">% do nothing</span>
0149   model=specification;
0150   <span class="keyword">return</span>;
0151 <span class="comment">%   TODO: consider the following --</span>
0152 <span class="comment">%   if isfield(specification,'specification')</span>
0153 <span class="comment">%     % regenerate from specification</span>
0154 <span class="comment">%     specification=specification.specification;</span>
0155 <span class="comment">%   end</span>
0156 <span class="keyword">end</span>
0157 <span class="comment">% standardize specification</span>
0158 specification=<a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>(specification, varargin{:}); <span class="comment">% standardize &amp; auto-populate as needed</span>
0159 
0160 <span class="comment">% Apply modifications to specification before generating model</span>
0161 <span class="keyword">if</span> ~isempty(options.modifications)
0162   specification=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(specification,options.modifications, varargin{:});
0163 <span class="keyword">end</span>
0164 
0165 <span class="comment">% specification metadata:</span>
0166 npops=length(specification.populations); <span class="comment">% number of populations</span>
0167 ncons=length(specification.connections); <span class="comment">% number of connections</span>
0168 
0169 <span class="comment">%{</span>
0170 <span class="comment">% Dev notes on improving implementation:</span>
0171 <span class="comment">% Ideally (1.0)-(3.0) could be packaged into external functions and run as:</span>
0172 <span class="comment">% -------------------------------------------------------------------------</span>
0173 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0174 <span class="comment">% [model,name_map]=LoadModelSet(specification) % bug: disrupted subsequent namespace propagation (without raising an error)</span>
0175 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0176 <span class="comment">% model = dsPropagateNamespaces(model,name_map); % this works</span>
0177 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0178 <span class="comment">% model = LinkMechanisms(model,name_map);      % problem: unable to identify linker population from model.linkers; see notes below (3.0) for more details</span>
0179 <span class="comment">% -------------------------------------------------------------------------</span>
0180 <span class="comment">%}</span>
0181 
0182 <span class="comment">% support full modularization of mechanisms</span>
0183 <span class="comment">% (eg, dv/dt=@M; {Na,K}@M w/ Na.mech: @current += I(IN,m,h)).</span>
0184 <span class="comment">%     approach taken below:</span>
0185 <span class="comment">%     - add support for dv/dt=@M; {Na@M,K@M}</span>
0186 <span class="comment">%       have dsGenerateModel split mech_name on '@' and replace first</span>
0187 <span class="comment">%       linker in mech (e.g., @current) by what follows '@' (e.g., @M)</span>
0188 <span class="comment">%     - then have dsCheckSpecification convert {Na,K}@M into {Na@M,K@M}</span>
0189 
0190 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0191 <span class="comment">% use empty struct for Octave compatibility</span>
0192 model.parameters=struct(<span class="string">''</span>);
0193 model.fixed_variables=struct(<span class="string">''</span>);
0194 model.functions=struct(<span class="string">''</span>);
0195 model.monitors=struct(<span class="string">''</span>);
0196 model.state_variables={};
0197 model.ODEs=struct(<span class="string">''</span>);
0198 model.ICs=struct(<span class="string">''</span>);
0199 model.conditionals=struct(<span class="string">''</span>);
0200 model.linkers=struct(<span class="string">''</span>);
0201 model.comments={};
0202 name_map={}; <span class="comment">% {name, namespace_name, namespace, type}, used for namespacing</span>
0203 linker_pops={}; <span class="comment">% list of populations associated with mechanism linkers</span>
0204 
0205 <span class="comment">% 1.1 load and combine population sub-models from population equations and mechanisms</span>
0206 <span class="keyword">for</span> i=1:npops
0207   <span class="comment">% does the population model already exist?</span>
0208   <span class="keyword">if</span> ~isempty(specification.populations(i).model)
0209     tmpmodel=specification.populations(i).model; <span class="comment">% get model structure</span>
0210     tmpname=tmpmodel.specification.populations.name; <span class="comment">% assumes one population sub-model</span>
0211 
0212     <span class="comment">% adjust the name if necessary</span>
0213     <span class="keyword">if</span> ~strcmp(specification.populations(i).name,tmpname)
0214       <span class="comment">% use the name in the specification</span>
0215       tmpmodel=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,specification.populations(i).name}, varargin{:});
0216     <span class="keyword">elseif</span> strcmp(tmpname,<span class="string">'pop1'</span>) <span class="comment">% if default name</span>
0217       <span class="comment">% use default name for this population index</span>
0218       tmpmodel=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,sprintf(<span class="string">'pop%g'</span>,i)}, varargin{:});
0219     <span class="keyword">end</span>
0220 
0221     tmpmodel.linkers=[]; <span class="comment">% remove old linkers from original model construction</span>
0222     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0223     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmodel.namespaces);
0224     <span class="keyword">continue</span>;
0225   <span class="keyword">end</span>
0226   <span class="comment">% construct new population model</span>
0227   PopScope=specification.populations(i).name;
0228     <span class="comment">% NOTE: dsParseModelEquations adds a '_' suffix to the namespace; therefore,</span>
0229     <span class="comment">% a '_' suffix is added to PopScope when used below for consistency of</span>
0230     <span class="comment">% namespaces/namespaces. (this could be cleaned up by adding '_' to PopScope</span>
0231     <span class="comment">% here, removing it below, and removing the additional '_' from</span>
0232     <span class="comment">% dsParseModelEquations).</span>
0233 
0234   <span class="comment">% 1.1.1 parse population equations</span>
0235   equations=specification.populations(i).equations;
0236   parameters=specification.populations(i).parameters;
0237   nmechs=length(specification.populations(i).mechanism_list);
0238 
0239   <span class="comment">% parse population equations</span>
0240   <span class="keyword">if</span> ~isempty(equations)
0241     [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(equations,<span class="string">'namespace'</span>,PopScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0242     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0243     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0244   <span class="keyword">end</span>
0245 
0246   <span class="comment">% 1.1.2 parse population mechanisms</span>
0247   <span class="keyword">for</span> j=1:nmechs
0248     mechanism_=specification.populations(i).mechanism_list{j};
0249 
0250     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0251     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0252     mechanism=mechanism_{1};
0253 
0254     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0255 
0256     <span class="comment">% set mechanism namespace</span>
0257     [~,MechID]=fileparts2(mechanism);
0258     <span class="keyword">if</span> any(MechID==<span class="string">':'</span>)
0259       <span class="comment">% exclude host name from namespace</span>
0260       tmp=regexp(MechID,<span class="string">':'</span>,<span class="string">'split'</span>);
0261       MechScope=[specification.populations(i).name <span class="string">'_'</span> tmp{2}];
0262     <span class="keyword">else</span>
0263       <span class="comment">% extract mechanism file name without path</span>
0264       MechScope=[specification.populations(i).name <span class="string">'_'</span> MechID];
0265     <span class="keyword">end</span>
0266     <span class="comment">% use mechanism equations in specification if present</span>
0267     <span class="keyword">if</span> isfield(specification.populations,<span class="string">'mechanisms'</span>) &amp;&amp; ~isempty(specification.populations(i).mechanisms)
0268       <span class="keyword">if</span> ismember(MechID,{specification.populations(i).mechanisms.name})
0269         idx=ismember({specification.populations(i).mechanisms.name},MechID);
0270         mechanism=specification.populations(i).mechanisms(idx).equations;
0271       <span class="keyword">end</span>
0272       <span class="comment">% parse mechanism equations</span>
0273       <span class="keyword">if</span> ~isempty(mechanism)
0274         [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0275         <span class="comment">% replace 1st linker name by the one in specification</span>
0276         <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0277           <span class="comment">% first try to find 1st linker target starting with @</span>
0278           links_at=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp({tmpmodel.linkers.target},<span class="string">'^@'</span>,<span class="string">'once'</span>)));
0279           <span class="keyword">if</span> ~isempty(links_at)
0280             <span class="comment">% use first link with target prepended by '@'</span>
0281             link_ind=links_at(1);
0282           <span class="keyword">else</span>
0283             <span class="comment">% use first link</span>
0284             link_ind=1;
0285           <span class="keyword">end</span>
0286           tmpmodel.linkers(link_ind).target=[<span class="string">'@'</span> new_linker];
0287         <span class="keyword">end</span>
0288         <span class="comment">% combine sub-model with other sub-models</span>
0289         model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0290         name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0291         linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat({specification.populations(i).name},[1 length(tmpmodel.linkers)]));
0292       <span class="keyword">end</span>
0293     <span class="keyword">end</span>
0294   <span class="keyword">end</span>
0295   pop=specification.populations(i).name;
0296 
0297   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0298   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(pop,pop,[PopScope <span class="string">'_'</span>]);
0299   <span class="comment">%model.parameters.([pop '_Npop'])=num2str(specification.populations(i).size);</span>
0300   model.parameters(1).([pop <span class="string">'_Npop'</span>])=toString(specification.populations(i).size,0);
0301 <span class="keyword">end</span>
0302 
0303 <span class="comment">% 1.2 load and combine sub-models from connection mechanisms</span>
0304 <span class="keyword">for</span> i=1:ncons
0305   <span class="comment">% parse connection mechanisms</span>
0306   source=specification.connections(i).source;
0307   target=specification.connections(i).target;
0308   parameters=specification.connections(i).parameters;
0309   ConScope=[target <span class="string">'_'</span> source <span class="string">'_'</span>];
0310     <span class="comment">% NOTE: in contrast to PopScope above, ConScope is never passed to</span>
0311     <span class="comment">% dsParseModelEquations; thus the '_' should be added here for consistency</span>
0312     <span class="comment">% with mechanism namespaces (which are modified by dsParseModelEquations).</span>
0313   <span class="keyword">for</span> j=1:length(specification.connections(i).mechanism_list)
0314     mechanism_=specification.connections(i).mechanism_list{j};
0315 
0316     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0317     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0318     mechanism=mechanism_{1};
0319 
0320     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0321 
0322     <span class="comment">% extract mechanism file name without path</span>
0323     [~,MechID]=fileparts2(mechanism);
0324     MechScope=[target <span class="string">'_'</span> source <span class="string">'_'</span> MechID];
0325         <span class="comment">% NOTE: must use target_source_mechanism for connection mechanisms</span>
0326         <span class="comment">% to distinguish their parent namespaces from those of population mechanisms</span>
0327         <span class="comment">% see: dsGetParentNamespace</span>
0328 
0329     <span class="comment">% use mechanism equations in specification if present</span>
0330     <span class="keyword">if</span> ~isempty(specification.connections(i).mechanisms) &amp;&amp; ismember(MechID,{specification.connections(i).mechanisms.name})
0331       idx=ismember({specification.connections(i).mechanisms.name},MechID);
0332       mechanism=specification.connections(i).mechanisms(idx).equations;
0333     <span class="keyword">end</span>
0334 
0335     <span class="comment">% parse model equations</span>
0336     [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,source,<span class="string">'user_parameters'</span>,parameters);
0337 
0338     <span class="comment">% replace 1st linker name by the one in specification</span>
0339     <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0340       tmpmodel.linkers(1).target=[<span class="string">'@'</span> new_linker];
0341     <span class="keyword">end</span>
0342 
0343     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0344     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0345 
0346     <span class="comment">% link this mechanism to the target population</span>
0347     linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat(target,[1 length(tmpmodel.linkers)]));
0348 
0349     <span class="comment">% edit names of connection monitors specified in population equations</span>
0350     <span class="comment">% TODO: consider design changes to avoid specifying connection monitors</span>
0351     <span class="comment">%   in population equations; this is an undesirable hack:</span>
0352     <span class="comment">%     eg, convert E_iGABAa_functions -&gt; I_E_iGABAa_functions</span>
0353     <span class="keyword">if</span> ~isempty(model.monitors)
0354       <span class="comment">% get indices to all model.monitors that have incorrect connection namespace</span>
0355       con_mon_to_update=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp(<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors),[<span class="string">'^'</span> target <span class="string">'_'</span> mechanism])));
0356       <span class="keyword">if</span> any(con_mon_to_update)
0357         <span class="comment">% get list of current model.monitors</span>
0358         monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0359         <span class="keyword">for</span> m=1:length(con_mon_to_update)
0360           <span class="comment">% get name of monitor with incorrect connection namespace</span>
0361           old=monitor_names{con_mon_to_update(m)};
0362 
0363           <span class="comment">% get name of monitor with correct connection namespace</span>
0364           new=strrep(old,[target <span class="string">'_'</span> mechanism <span class="string">'_'</span>],[MechScope <span class="string">'_'</span>]);
0365 
0366           <span class="comment">% add new monitor with correct namespace</span>
0367           model.monitors.(new)=model.monitors.(old);
0368 
0369           <span class="comment">% remove old monitor with incorrect namespace</span>
0370           model.monitors=rmfield(model.monitors,old);
0371         <span class="keyword">end</span>
0372       <span class="keyword">end</span>
0373     <span class="keyword">end</span>
0374   <span class="keyword">end</span>
0375   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0376   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(source,target,ConScope);
0377 <span class="keyword">end</span>
0378 
0379 <span class="comment">% check for monitoring functions (e.g., 'monitor functions' or 'monitor Na.functions')</span>
0380 <span class="keyword">if</span> ~isempty(model.monitors)
0381   <span class="comment">% get list of functions</span>
0382   <span class="keyword">if</span> ~isempty(model.functions)
0383     <a name="_sub1" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0384   <span class="keyword">else</span>
0385     <a name="_sub2" href="#_subfunctions" class="code">function_names={};</a>
0386   <span class="keyword">end</span>
0387   <span class="comment">% get list of monitor names</span>
0388   monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0389 
0390   <span class="comment">% get indices to monitors with names ending in _functions</span>
0391   <a name="_sub3" href="#_subfunctions" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a><span class="string">'_functions$'</span>,<span class="string">'once'</span>)));
0392 
0393   <span class="comment">% create list of functions with namespaces matching monitors ending in _functions</span>
0394   <a name="_sub4" href="#_subfunctions" class="code">functions_to_monitor={};</a>
0395 
0396   <span class="keyword">for</span> i=1:length(function_monitor_index)
0397     <span class="comment">% get namespace of functions to monitor</span>
0398     monitor_name=monitor_names{function_monitor_index(i)};
0399     monitor_namespace=regexp(monitor_name,<span class="string">'(.*)_functions$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0400     monitor_namespace=monitor_namespace{1};
0401 
0402     <span class="comment">% get list of functions with matching namespace</span>
0403     <a name="_sub5" href="#_subfunctions" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a><span class="string">'^'</span> monitor_namespace],<span class="string">'once'</span>)));
0404 
0405     <span class="comment">% add functions to list</span>
0406     <a name="_sub6" href="#_subfunctions" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a>
0407 
0408     <span class="comment">% remove &quot;function&quot; monitor name</span>
0409     model.monitors=rmfield(model.monitors,monitor_name);
0410   <span class="keyword">end</span>
0411 
0412   <span class="comment">% eliminate duplicate function names</span>
0413   <a name="_sub7" href="#_subfunctions" class="code">functions_to_monitor=unique_wrapper(functions_to_monitor);</a>
0414 
0415   <span class="comment">% add functions to monitor list</span>
0416   <span class="keyword">for</span> i=1:length(functions_to_monitor)
0417     model.monitors.(functions_to_monitor{i})=[];
0418   <span class="keyword">end</span>
0419 <span class="keyword">end</span>
0420 
0421   <span class="comment">% ----------------------------------</span>
0422   <span class="comment">% NESTED FUNCTIONS</span>
0423   <span class="comment">% ----------------------------------</span>
0424   <a name="_sub8" href="#_subfunctions" class="code">function add_keywords(src,dst,namespace)</a>
0425     <span class="comment">% NOTE: this needs to be coordinated with update_keywords() in dsSimulate()</span>
0426     <span class="comment">%   for parameters</span>
0427     Nsrc=[src <span class="string">'_Npop'</span>];
0428     Ndst=[dst <span class="string">'_Npop'</span>];
0429 
0430     old={<span class="string">'Npre'</span>,<span class="string">'N[1]'</span>,<span class="string">'N_pre'</span>,<span class="string">'Npost'</span>,<span class="string">'N_post'</span>,<span class="string">'N[0]'</span>,<span class="string">'Npop'</span>,<span class="string">'N_pop'</span>,<span class="string">'tspike_pre'</span>,<span class="string">'tspike_post'</span>,<span class="string">'tspike'</span>};
0431     new={Nsrc,Nsrc,Nsrc,Ndst,Ndst,Ndst,Ndst,Ndst,[src <span class="string">'_tspike'</span>],[dst <span class="string">'_tspike'</span>],[dst <span class="string">'_tspike'</span>]};
0432     <span class="keyword">for</span> p=1:length(old)
0433       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'parameters'</span>};
0434     <span class="keyword">end</span>
0435 
0436     <span class="comment">% for state variables</span>
0437     new={};
0438     old={};
0439     src_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'pre'</span> <span class="string">'$'</span>]));
0440     dst_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'post'</span> <span class="string">'$'</span>]));
0441     excluded=src_excluded|dst_excluded;
0442 
0443     PopScope=[src <span class="string">'_'</span>];
0444     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0445     <span class="keyword">if</span> any(var_idx)
0446       Xsrc_old_vars=name_map(var_idx,1);
0447       Xsrc_new_vars=name_map(var_idx,2);
0448       <span class="comment">% default for IN is first Xsrc state var</span>
0449       Xsrc=Xsrc_new_vars{1};
0450       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'IN'</span>,<span class="string">'Xpre'</span>,<span class="string">'X_pre'</span>});
0451       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xsrc,Xsrc,Xsrc});
0452     <span class="keyword">else</span>
0453       Xsrc_old_vars=[];
0454       Xsrc_new_vars=[];
0455       Xsrc=[];
0456     <span class="keyword">end</span>
0457 
0458     PopScope=[dst <span class="string">'_'</span>];
0459     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0460     <span class="keyword">if</span> any(var_idx)
0461       Xdst_old_vars=name_map(var_idx,1);
0462       Xdst_new_vars=name_map(var_idx,2);
0463       <span class="comment">% default for OUT and X is first Xdst state var</span>
0464       Xdst=Xdst_new_vars{1};
0465       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'OUT'</span>,<span class="string">'X'</span>,<span class="string">'Xpost'</span>,<span class="string">'X_post'</span>});
0466       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xdst,Xdst,Xdst,Xdst});
0467     <span class="keyword">else</span>
0468       Xdst_old_vars=[];
0469       Xdst_new_vars=[];
0470       Xdst=[];
0471     <span class="keyword">end</span>
0472 
0473     <span class="comment">% add variants [var_pre,var_post,varpre,varpost]</span>
0474     <span class="keyword">if</span> ~isempty(Xsrc_old_vars)
0475       [Xsrc_old_vars,IA]=setdiff(Xsrc_old_vars,old);
0476       Xsrc_new_vars=Xsrc_new_vars(IA);
0477     <span class="keyword">end</span>
0478 
0479     <span class="keyword">if</span> ~isempty(Xdst_old_vars)
0480       [Xdst_old_vars,IA]=setdiff(Xdst_old_vars,old);
0481       Xdst_new_vars=Xdst_new_vars(IA);
0482     <span class="keyword">end</span>
0483 
0484     <span class="keyword">for</span> p=1:length(Xsrc_old_vars)
0485       old{end+1}=[Xsrc_old_vars{p} <span class="string">'_pre'</span>];
0486       new{end+1}=Xsrc_new_vars{p};
0487       old{end+1}=[Xsrc_old_vars{p} <span class="string">'pre'</span>];
0488       new{end+1}=Xsrc_new_vars{p};
0489     <span class="keyword">end</span>
0490 
0491     <span class="keyword">for</span> p=1:length(Xdst_old_vars)
0492       old{end+1}=[Xdst_old_vars{p} <span class="string">'_post'</span>];
0493       new{end+1}=Xdst_new_vars{p};
0494       old{end+1}=[Xdst_old_vars{p} <span class="string">'post'</span>];
0495       new{end+1}=Xdst_new_vars{p};
0496     <span class="keyword">end</span>
0497 
0498     <span class="keyword">for</span> p=1:length(old)
0499       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'state_variables'</span>};
0500     <span class="keyword">end</span>
0501   <span class="keyword">end</span>
0502 
0503 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0504 <span class="comment">%      i.e., to establish uniqueness of names by adding namespace/namespace prefixes)</span>
0505 model.specification=specification;
0506 model = <a href="dsPropagateNamespaces.html" class="code" title="function model = dsPropagateNamespaces(model,map, varargin)">dsPropagateNamespaces</a>(model,name_map, varargin{:});
0507 
0508 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0509 <span class="comment">% purpose: expand population equations according to linkers</span>
0510 <span class="comment">% - link populations.equations to mechanism sub-models</span>
0511 <span class="comment">% - link mechanism functions and state variables across mechanisms in a given population</span>
0512 
0513 <span class="comment">% store indices to all expressions and conditionals that are linked (this</span>
0514 <span class="comment">% is necessary for efficiently removing linker targets from expressions after linking)</span>
0515 all_expression_inds=[];
0516 all_expression_targets={};
0517 all_conditionals_inds=[];
0518 all_conditionals_targets={};
0519 
0520 <span class="comment">% add variables to linked expression if its a function without ()</span>
0521 <span class="keyword">if</span> ~isempty(model.functions) &amp;&amp; ~isempty(model.linkers)
0522   <a name="_sub9" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0523   expressions={model.linkers.expression};
0524   [~,I,J]=intersect(function_names,expressions);
0525   <span class="keyword">for</span> i=1:length(I)
0526     e=model.functions.(function_names{I(i)}); <span class="comment">% function expression (eg,'@(x,y,z)x-(y-z)')</span>
0527     v=regexp(e,<span class="string">'@(\([\w,]+\))'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% function input list (eg, '(x,y,z)')</span>
0528     <span class="keyword">if</span> ~isempty(v)
0529       model.linkers(J(i)).expression=[model.linkers(J(i)).expression v{1}];
0530     <span class="keyword">end</span>
0531   <span class="keyword">end</span>
0532 <span class="keyword">end</span>
0533 
0534 <span class="comment">% loop over linkers</span>
0535 <span class="keyword">for</span> i=1:length(model.linkers)
0536   <span class="comment">% determine how to link</span>
0537   operation=model.linkers(i).operation;
0538   oldstr=model.linkers(i).target;
0539   newstr=model.linkers(i).expression;
0540   <span class="keyword">switch</span> operation <span class="comment">% see dsClassifyEquation and dsParseModelEquations   % ('((\+=)|(-=)|(\*=)|(/=)|(=&gt;))')</span>
0541     <span class="keyword">case</span> <span class="string">'+='</span>
0542       operator=<span class="string">'+'</span>;
0543     <span class="keyword">case</span> <span class="string">'-='</span>
0544       operator=<span class="string">'-'</span>;
0545     <span class="keyword">case</span> <span class="string">'*='</span>
0546       operator=<span class="string">'.*'</span>;
0547     <span class="keyword">case</span> <span class="string">'/='</span>
0548       operator=<span class="string">'./'</span>;
0549     <span class="keyword">otherwise</span>
0550       operator=<span class="string">'+'</span>;
0551   <span class="keyword">end</span>
0552   <span class="comment">% determine what to link (ie, link across everything belonging to the linker population)</span>
0553   <span class="comment">% explicitly constrain to linker population</span>
0554   expressions_in_pop=~cellfun(@isempty,regexp(name_map(:,3),[<span class="string">'^'</span> linker_pops{i}]));
0555 
0556   <span class="keyword">if</span> ~isempty(model.conditionals)
0557     conditionals_in_pop=~cellfun(@isempty,regexp({model.conditionals.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0558   <span class="keyword">end</span>
0559 
0560   <span class="keyword">if</span> ~isempty(model.linkers)
0561     linkers_in_pop=~cellfun(@isempty,regexp({model.linkers.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0562   <span class="keyword">end</span>
0563 
0564   <span class="comment">% constrain to namespace</span>
0565   names_in_namespace=cellfun(@(x,y)strncmp(y,x,length(y)),name_map(:,2),name_map(:,3));
0566 
0567   <span class="comment">% get list of (functions,monitors,ODEs) belonging to the linker population</span>
0568   eqn_types={<span class="string">'ODEs'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','ODEs'};</span>
0569   search_types={<span class="string">'state_variables'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','state_variables'};</span>
0570 
0571   <span class="comment">% indices to expressions in the linker population with the correct search_types and namespace</span>
0572   inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(expressions_in_pop&amp;names_in_namespace&amp;ismember(name_map(:,4),search_types));
0573 
0574   <span class="comment">% eliminate duplicates (e.g., state_variables replacing OUT and X)</span>
0575   [jnk,ia,ib]=<a href="#_sub7" class="code" title="subfunctions_to_monitor=unique_wrapper(functions_to_monitor);">unique_wrapper</a>(name_map(inds,2),<span class="string">'stable'</span>);
0576   inds=inds(ia);
0577   all_expression_inds=[all_expression_inds inds'];
0578   all_expression_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_expression_targets,repmat({oldstr},[1 length(inds)]));
0579 
0580   <span class="comment">% substitute link</span>
0581   <span class="keyword">for</span> j=1:length(inds)
0582     name=name_map{inds(j),2}; <span class="comment">% name of variable as stored in model structure</span>
0583     type=name_map{inds(j),4}; <span class="comment">% search_types</span>
0584     eqn_type=eqn_types{strcmp(type,search_types)}; <span class="comment">% corresponding equation type</span>
0585 
0586     <span class="comment">% update expression with the current link</span>
0587     <span class="keyword">if</span> isfield(model.(eqn_type),name)
0588       <span class="comment">% note: name will not be a field of eqn_type for special monitors</span>
0589       <span class="comment">% (e.g., monitor functions)</span>
0590       model.(eqn_type).(name)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.(eqn_type).(name),oldstr,newstr,operator);
0591     <span class="keyword">end</span>
0592   <span class="keyword">end</span>
0593 
0594   <span class="keyword">if</span> ~isempty(model.conditionals)
0595     fields={<span class="string">'condition'</span>,<span class="string">'action'</span>,<span class="string">'else'</span>};
0596 
0597     <span class="comment">% get list of conditionals belonging to the linker population</span>
0598     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(conditionals_in_pop);
0599     all_conditionals_inds=[all_conditionals_inds inds];
0600     all_conditionals_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_conditionals_targets,repmat({oldstr},[1 length(inds)]));
0601 
0602     <span class="comment">% substitute link</span>
0603     <span class="keyword">for</span> j=1:length(inds)
0604       <span class="keyword">for</span> field_index=1:length(fields)
0605         field=fields{field_index};
0606         model.conditionals(inds(j)).(field)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.conditionals(inds(j)).(field),oldstr,newstr,operator);
0607       <span class="keyword">end</span>
0608     <span class="keyword">end</span>
0609   <span class="keyword">end</span>
0610 
0611   <span class="keyword">if</span> ~isempty(model.linkers)
0612     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(linkers_in_pop);
0613     <span class="keyword">for</span> j=1:length(inds)
0614       model.linkers(inds(j)).expression=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.linkers(inds(j)).expression,oldstr,newstr,operator);
0615     <span class="keyword">end</span>
0616   <span class="keyword">end</span>
0617 <span class="keyword">end</span>
0618 
0619 <span class="keyword">if</span> options.open_link_flag==0
0620   <span class="comment">% remove target placeholders from expressions and conditionals</span>
0621   <span class="keyword">for</span> i=1:length(all_expression_inds)
0622     oldstr=all_expression_targets{i};
0623     newstr=<span class="string">''</span>;
0624     name=name_map{all_expression_inds(i),2};
0625     type=name_map{all_expression_inds(i),4};
0626     eqn_type=eqn_types{strcmp(type,search_types)};
0627     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0628     replace = [newstr <span class="string">'))'</span>];
0629     <span class="keyword">if</span> isfield(model.(eqn_type),name) &amp;&amp; ischar(model.(eqn_type).(name))
0630         <span class="comment">% NOTE: name will not be a field of eqn_type for special monitors</span>
0631         <span class="comment">% (e.g., monitor functions)</span>
0632       model.(eqn_type).(name)=regexprep(model.(eqn_type).(name),pattern,replace);
0633     <span class="keyword">end</span>
0634   <span class="keyword">end</span>
0635 <span class="keyword">end</span>
0636 
0637 <span class="keyword">if</span> ~isempty(model.conditionals)
0638   <span class="keyword">for</span> i=1:length(all_conditionals_inds)
0639     oldstr=all_conditionals_targets{i};
0640     newstr=<span class="string">''</span>;
0641     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0642     replace = [newstr <span class="string">'))'</span>];
0643     <span class="keyword">for</span> field_index=1:length(fields)
0644       field=fields{field_index};
0645       <span class="keyword">if</span> model.conditionals(all_conditionals_inds(i)).(field)
0646         model.conditionals(all_conditionals_inds(i)).(field)=regexprep(model.conditionals(all_conditionals_inds(i)).(field),pattern,replace);
0647       <span class="keyword">end</span>
0648     <span class="keyword">end</span>
0649   <span class="keyword">end</span>
0650 <span class="keyword">end</span>
0651 
0652 <span class="comment">% ------------------------------------------</span>
0653 <span class="comment">% NOTE on non-ideal implementation of 3.0: model.linkers does not contain enough</span>
0654 <span class="comment">% information to determine the population to which it belongs in all cases</span>
0655 <span class="comment">% (due to namespace format differences for population vs connection mechanisms &amp; models</span>
0656 <span class="comment">% with one vs more populations). consequently, had to perform linking in this</span>
0657 <span class="comment">% function using info stored above while parsing the model; ideally, the</span>
0658 <span class="comment">% linking could occur independently of this function, informed by info in</span>
0659 <span class="comment">% model.linkers, and be packaged in its own external function LinkMechanisms().</span>
0660 <span class="comment">% ------------------------------------------</span>
0661 
0662 <span class="comment">%% 4.0 finalize</span>
0663 
0664 <span class="comment">% 4.1 sort .ODEs and .ICs wrt .state_variables</span>
0665 <span class="keyword">if</span> ~isempty(model.ODEs)
0666   model.ODEs = orderfields(model.ODEs,model.state_variables);
0667   model.ICs = orderfields(model.ICs,model.state_variables);
0668 <span class="keyword">end</span>
0669 
0670 <span class="comment">% 4.2 convert to numeric parameters</span>
0671 c = struct2cell(model.parameters);
0672 
0673 <span class="comment">% get index of strings</span>
0674 idx1=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@ischar,c));
0675 
0676 <span class="comment">% which strings contain numeric values?</span>
0677 idx2=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@isempty,regexp(c(idx1),<span class="string">'[a-z_A-Z]'</span>)) | ~cellfun(@isempty,regexp(c(idx1),<span class="string">'^\s*\[*\s*\+?inf\s*\]*\s*$'</span>,<span class="string">'ignorecase'</span>)));
0678 
0679 <span class="comment">% convert those strings which contain numeric values</span>
0680 c(idx1(idx2)) = cellfun(@eval,c(idx1(idx2)),<span class="string">'uni'</span>,0);
0681 f = <a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.parameters);
0682 model.parameters = cell2struct(c,f,1);
0683 
0684 <span class="comment">% 4.3 store original specification</span>
0685 model.specification = specification; <span class="comment">% store specification to enable modifications to be applied later</span>
0686 model.namespaces = name_map; <span class="comment">% store name_map for transparency</span>
0687 
0688 model=<a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>(model, varargin{:});
0689 
0690 <span class="comment">%% auto_gen_test_data_flag argout</span>
0691 <span class="keyword">if</span> options.auto_gen_test_data_flag
0692   argout = {model, name_map}; <span class="comment">% specific to this function</span>
0693 
0694   <a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>(argin, argout);
0695 <span class="keyword">end</span>
0696 
0697 <span class="keyword">end</span> <span class="comment">% main function</span>
0698 
0699 
0700 <span class="comment">%% SUBFUNCTIONS</span>
0701 <a name="_sub10" href="#_subfunctions" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a>
0702   <span class="keyword">if</span> isempty(str)
0703     <span class="keyword">return</span>;
0704   <span class="keyword">end</span>
0705   <span class="comment">% if inserting one word (e.g., a state variable), just replace it</span>
0706   <span class="comment">% WARNING: could cause problems in future if there is an additive</span>
0707   <span class="comment">% substitution of different state variables into the same place followed</span>
0708   <span class="comment">% by non-additive operations (e.g., @cai+=cai1 and @cai+=cai2 into</span>
0709   <span class="comment">% v'=f(v)*cai where cai1 &amp; cai2 are defined in mechanisms for the same v;</span>
0710   <span class="comment">% workaround: insert into v'=f(v)*(cai)).</span>
0711 
0712   <span class="comment">% check if anything besides a single variable:</span>
0713   <span class="keyword">if</span> isempty(regexp(newstr,<span class="string">'[^a-z_A-Z\d]+'</span>,<span class="string">'once'</span>))
0714     str=<a href="dsStrrep.html" class="code" title="function str = dsStrrep(str,oldstr,newstr,lpad,rpad, varargin)">dsStrrep</a>(str,oldstr,newstr);
0715   <span class="keyword">else</span>
0716     <span class="comment">% otherwise do substitution with operator and parenthesis</span>
0717     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'([^\w]+)'</span>]; <span class="comment">% in the middle</span>
0718     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$2'</span>];
0719     str=regexprep(str,pat,rep);
0720     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'$'</span>];        <span class="comment">% at the end</span>
0721     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0722     str=regexprep(str,pat,rep);
0723     pat=[<span class="string">'^'</span> oldstr <span class="string">'([^\w]+)'</span>];        <span class="comment">% at the beginning</span>
0724     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$1'</span>];
0725     str=regexprep(str,pat,rep);
0726     pat=[<span class="string">'^'</span> oldstr <span class="string">'$'</span>];               <span class="comment">% all there is</span>
0727     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0728     str=regexprep(str,pat,rep);
0729   <span class="keyword">end</span>
0730 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 12-Dec-2017 11:32:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>