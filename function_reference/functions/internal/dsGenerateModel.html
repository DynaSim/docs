<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsGenerateModel</title>
  <meta name="keywords" content="dsGenerateModel">
  <meta name="description" content="GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html functions --><!-- menu.html internal -->
<h1>dsGenerateModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [model,name_map] = dsGenerateModel(specification, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure

 Usage:
   [model,name_map]=dsGenerateModel(specification,'option',value,...)

 Inputs:
   - specification: one of:
     - DynaSim specification structure (see below and dsCheckSpecification for more details)
     - string with name of MAT-file containing DynaSim specification structure
     - string with equations
     - string with name of file containing equations (.eqns)
       note: .eqns files can also be converted into model structure using LoadModel()
   - options (with defaults): 'option1',value1,'option2',value2,...
     'modifications'  : specify modifications to apply to specification
                        before generating the model, see dsApplyModifications
                        for more details (default?: []).
     'open_link_flag' : whether to leave linker identifiers in place (default: 0)

 Outputs:
   - model: DynaSim model structure (see dsCheckModel for more details):
     .parameters      : substructure with model parameters
     .fixed_variables : substructure with fixed variable definitions
     .functions       : substructure with function definitions
     .monitors        : substructure with monitor definitions
     .state_variables : cell array listing state variables
     .ODEs            : substructure with one ordinary differential
                             equation (ODE) per state variable
     .ICs             : substructure with initial conditions (ICs) for
                             each state variable
     .conditionals(i) : structure array with each element indicating
                             conditional actions specified in subfields
                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in dsCheckModel)
     .linkers(i)      : structure array with each element indicating
                             an &quot;expression&quot; that should be inserted
                             (according to &quot;operation&quot;) into any equations
                             where the &quot;target&quot; appears. (see NOTE 2 in dsCheckModel)
       .target    : string giving the target where expression should be inserted
       .expression: string giving the expression to insert
       .operation : string giving the operation to use to insert expression
     .comments{i}     : cell array of comments found in model files
     .specification   : specification used to generate the model
     .namespaces      : (see NOTE 3 in dsCheckModel)
   - name_map: cell matrix mapping parameter, variable, and function names
       between the user-created specification (population equations and mechanism
       files) and the full model with automatically generated namespaces. It
       has four columns with: user-specified name, name with namespace prefix,
       namespace, and type ('parameters', 'fixed_variables', 'state_variables',
       'functions', or 'monitors') indicating the category to which the named
       element belongs.

 - DynaSim specification structure (see dsCheckSpecification for more details)
   .populations(i) (required): contains info for defining independent population models
       .name (default: 'pop1')      : name of population
       .size (default: 1)           : number of elements in population (i.e., # cells)
       .equations (required)        : string listing equations (see NOTE 1 in dsCheckSpecification)
       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2
                                      in dsCheckSpecification)
       .parameters (default: [])    : parameters to assign across all equations in
         the population. provide as cell array list of key/value pairs
         {'param1',value1,'param2',value2,...}
       .model (default: [])   : optional DynaSim model structure
   .connections(i) (default: []): contains info for linking population models
       .source (required if &gt;1 pops): name of source population
       .target (required if &gt;1 pops): name of target population
       .mechanism_list (required)   : list of mechanisms that link two populations
       .parameters (default: [])    : parameters to assign across all equations in
         mechanisms of this connection's mechanism_list.

 Examples:
   - Example 0:
     model=dsGenerateModel('db/dt=3')

   - Example 1: Lorenz equations
     eqns={
       's=10; r=27; b=2.666';
       'dx/dt=s*(y-x)';
       'dy/dt=r*x-y-x*z';
       'dz/dt=-b*z+x*y';
     };
     model=dsGenerateModel(eqns)

   - Example 2: Leaky integrate-and-fire neuron
     model=dsGenerateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')

   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive
     model=dsGenerateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')

   - Example 4: HH with self inhibition and sinusoidal drive
     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa','iK'};
     specification.connections(1).mechanism_list={'iGABAa'};
     specification.connections(1).parameters={'tauDx',15};
     model=dsGenerateModel(specification)

   - Example 5: using custom mechanism alias in equations (for modularization)
     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';
     specification.populations(1).mechanism_list={'iNa@M','iK@M'};
     model=dsGenerateModel(specification)

     or:

     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';
     model=dsGenerateModel(specification)

   - Example 6: directly incorporating mechanism models from online repositories:

     model=dsGenerateModel('dv/dt=@M; {ib:57,iK}@M')

     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,
     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.
     note: currently not supported on *most* machines...

 See also: <a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>, <a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>, <a href="dsParseModelEquations.html" class="code" title="function [model,name_map] = dsParseModelEquations(text,varargin)">dsParseModelEquations</a>, dsSimulate</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>	CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</li><li><a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>	COMBINEMODELS - combine subfields in two DynaSim model structures</li><li><a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>	IMPORTMODEL - import model from raw equations, other program source, etc.</li><li><a href="dsPropagateNamespaces.html" class="code" title="function model = dsPropagateNamespaces(model,map, varargin)">dsPropagateNamespaces</a>	PROPAGATENAMESPACES - namespace-establishing namespace substitutions.</li><li><a href="dsStrrep.html" class="code" title="function str = dsStrrep(str,oldstr,newstr,lpad,rpad, varargin)">dsStrrep</a>	STRREP - replace full words by new character strings, ignoring matches that appear as sub-strings.</li><li><a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>	Inputs:</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>	CHECKMODEL - Standardize model structure and auto-populate missing fields</li><li><a href="dsProbeCellProperties.html" class="code" title="function data = dsProbeCellProperties(model,varargin)">dsProbeCellProperties</a>	data = dsProbeCellProperties(model,'option1',option1,...)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub2" class="code">function_names={};</a></li><li><a href="#_sub3" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a></li><li><a href="#_sub4" class="code">functions_to_monitor={};</a></li><li><a href="#_sub5" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a></li><li><a href="#_sub6" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a></li><li><a href="#_sub7" class="code">functions_to_monitor=unique(functions_to_monitor);</a></li><li><a href="#_sub8" class="code">function add_keywords(src,dst,namespace)</a></li><li><a href="#_sub9" class="code">function_names=fieldnames(model.functions);</a></li><li><a href="#_sub10" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,name_map] = dsGenerateModel(specification, varargin)</a>
0002 <span class="comment">%GENERATEMODEL - Parse DynaSim specification and organize model data in DynaSim model structure</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   [model,name_map]=dsGenerateModel(specification,'option',value,...)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   - specification: one of:</span>
0009 <span class="comment">%     - DynaSim specification structure (see below and dsCheckSpecification for more details)</span>
0010 <span class="comment">%     - string with name of MAT-file containing DynaSim specification structure</span>
0011 <span class="comment">%     - string with equations</span>
0012 <span class="comment">%     - string with name of file containing equations (.eqns)</span>
0013 <span class="comment">%       note: .eqns files can also be converted into model structure using LoadModel()</span>
0014 <span class="comment">%   - options (with defaults): 'option1',value1,'option2',value2,...</span>
0015 <span class="comment">%     'modifications'  : specify modifications to apply to specification</span>
0016 <span class="comment">%                        before generating the model, see dsApplyModifications</span>
0017 <span class="comment">%                        for more details (default?: []).</span>
0018 <span class="comment">%     'open_link_flag' : whether to leave linker identifiers in place (default: 0)</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Outputs:</span>
0021 <span class="comment">%   - model: DynaSim model structure (see dsCheckModel for more details):</span>
0022 <span class="comment">%     .parameters      : substructure with model parameters</span>
0023 <span class="comment">%     .fixed_variables : substructure with fixed variable definitions</span>
0024 <span class="comment">%     .functions       : substructure with function definitions</span>
0025 <span class="comment">%     .monitors        : substructure with monitor definitions</span>
0026 <span class="comment">%     .state_variables : cell array listing state variables</span>
0027 <span class="comment">%     .ODEs            : substructure with one ordinary differential</span>
0028 <span class="comment">%                             equation (ODE) per state variable</span>
0029 <span class="comment">%     .ICs             : substructure with initial conditions (ICs) for</span>
0030 <span class="comment">%                             each state variable</span>
0031 <span class="comment">%     .conditionals(i) : structure array with each element indicating</span>
0032 <span class="comment">%                             conditional actions specified in subfields</span>
0033 <span class="comment">%                             &quot;condition&quot;,&quot;action&quot;,&quot;else&quot; (see NOTE 1 in dsCheckModel)</span>
0034 <span class="comment">%     .linkers(i)      : structure array with each element indicating</span>
0035 <span class="comment">%                             an &quot;expression&quot; that should be inserted</span>
0036 <span class="comment">%                             (according to &quot;operation&quot;) into any equations</span>
0037 <span class="comment">%                             where the &quot;target&quot; appears. (see NOTE 2 in dsCheckModel)</span>
0038 <span class="comment">%       .target    : string giving the target where expression should be inserted</span>
0039 <span class="comment">%       .expression: string giving the expression to insert</span>
0040 <span class="comment">%       .operation : string giving the operation to use to insert expression</span>
0041 <span class="comment">%     .comments{i}     : cell array of comments found in model files</span>
0042 <span class="comment">%     .specification   : specification used to generate the model</span>
0043 <span class="comment">%     .namespaces      : (see NOTE 3 in dsCheckModel)</span>
0044 <span class="comment">%   - name_map: cell matrix mapping parameter, variable, and function names</span>
0045 <span class="comment">%       between the user-created specification (population equations and mechanism</span>
0046 <span class="comment">%       files) and the full model with automatically generated namespaces. It</span>
0047 <span class="comment">%       has four columns with: user-specified name, name with namespace prefix,</span>
0048 <span class="comment">%       namespace, and type ('parameters', 'fixed_variables', 'state_variables',</span>
0049 <span class="comment">%       'functions', or 'monitors') indicating the category to which the named</span>
0050 <span class="comment">%       element belongs.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% - DynaSim specification structure (see dsCheckSpecification for more details)</span>
0053 <span class="comment">%   .populations(i) (required): contains info for defining independent population models</span>
0054 <span class="comment">%       .name (default: 'pop1')      : name of population</span>
0055 <span class="comment">%       .size (default: 1)           : number of elements in population (i.e., # cells)</span>
0056 <span class="comment">%       .equations (required)        : string listing equations (see NOTE 1 in dsCheckSpecification)</span>
0057 <span class="comment">%       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2</span>
0058 <span class="comment">%                                      in dsCheckSpecification)</span>
0059 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0060 <span class="comment">%         the population. provide as cell array list of key/value pairs</span>
0061 <span class="comment">%         {'param1',value1,'param2',value2,...}</span>
0062 <span class="comment">%       .model (default: [])   : optional DynaSim model structure</span>
0063 <span class="comment">%   .connections(i) (default: []): contains info for linking population models</span>
0064 <span class="comment">%       .source (required if &gt;1 pops): name of source population</span>
0065 <span class="comment">%       .target (required if &gt;1 pops): name of target population</span>
0066 <span class="comment">%       .mechanism_list (required)   : list of mechanisms that link two populations</span>
0067 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0068 <span class="comment">%         mechanisms of this connection's mechanism_list.</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% Examples:</span>
0071 <span class="comment">%   - Example 0:</span>
0072 <span class="comment">%     model=dsGenerateModel('db/dt=3')</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%   - Example 1: Lorenz equations</span>
0075 <span class="comment">%     eqns={</span>
0076 <span class="comment">%       's=10; r=27; b=2.666';</span>
0077 <span class="comment">%       'dx/dt=s*(y-x)';</span>
0078 <span class="comment">%       'dy/dt=r*x-y-x*z';</span>
0079 <span class="comment">%       'dz/dt=-b*z+x*y';</span>
0080 <span class="comment">%     };</span>
0081 <span class="comment">%     model=dsGenerateModel(eqns)</span>
0082 <span class="comment">%</span>
0083 <span class="comment">%   - Example 2: Leaky integrate-and-fire neuron</span>
0084 <span class="comment">%     model=dsGenerateModel('tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)')</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%   - Example 3: Hodgkin-Huxley neuron with sinusoidal drive</span>
0087 <span class="comment">%     model=dsGenerateModel('dv/dt=current+sin(2*pi*t); {iNa,iK}')</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%   - Example 4: HH with self inhibition and sinusoidal drive</span>
0090 <span class="comment">%     specification.populations(1).equations='dv/dt=current+sin(2*pi); v(0)=-65';</span>
0091 <span class="comment">%     specification.populations(1).mechanism_list={'iNa','iK'};</span>
0092 <span class="comment">%     specification.connections(1).mechanism_list={'iGABAa'};</span>
0093 <span class="comment">%     specification.connections(1).parameters={'tauDx',15};</span>
0094 <span class="comment">%     model=dsGenerateModel(specification)</span>
0095 <span class="comment">%</span>
0096 <span class="comment">%   - Example 5: using custom mechanism alias in equations (for modularization)</span>
0097 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); v(0)=-65';</span>
0098 <span class="comment">%     specification.populations(1).mechanism_list={'iNa@M','iK@M'};</span>
0099 <span class="comment">%     model=dsGenerateModel(specification)</span>
0100 <span class="comment">%</span>
0101 <span class="comment">%     or:</span>
0102 <span class="comment">%</span>
0103 <span class="comment">%     specification.populations(1).equations='dv/dt=@M+sin(2*pi); {iNa,iK}@M; v(0)=-65';</span>
0104 <span class="comment">%     model=dsGenerateModel(specification)</span>
0105 <span class="comment">%</span>
0106 <span class="comment">%   - Example 6: directly incorporating mechanism models from online repositories:</span>
0107 <span class="comment">%</span>
0108 <span class="comment">%     model=dsGenerateModel('dv/dt=@M; {ib:57,iK}@M')</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%     where &quot;ib&quot; is a known alias for the infinitebrain.org repository,</span>
0111 <span class="comment">%     and &quot;57&quot; is the Na+ current at http://infinitebrain.org/models/57.</span>
0112 <span class="comment">%     note: currently not supported on *most* machines...</span>
0113 <span class="comment">%</span>
0114 <span class="comment">% See also: dsCheckSpecification, dsCheckModel, dsParseModelEquations, dsSimulate</span>
0115 
0116 <span class="comment">% Check inputs</span>
0117 <span class="comment">% ------------------------------------------------------</span>
0118 <span class="keyword">if</span> nargin==0
0119   <span class="comment">% use default model</span>
0120   specification=[];
0121   specification.populations(1).equations=<span class="string">'dv/dt=10+@current/Cm; Cm=1; v(0)=-65'</span>;
0122   specification.populations(1).mechanism_list={<span class="string">'iNa'</span>,<span class="string">'iK'</span>};
0123   specification.populations(1).parameters={<span class="string">'Cm'</span>,1};
0124   specification.connections(1).mechanism_list={<span class="string">'iGABAa'</span>};
0125   varargin={<span class="string">'modifications'</span>,[]};
0126 <span class="keyword">end</span>
0127 <span class="comment">% ------------------------------------------------------</span>
0128 
0129 options=<a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>(varargin,{<span class="keyword">...</span>
0130   <span class="string">'modifications'</span>,[],[],<span class="keyword">...</span>
0131   <span class="string">'open_link_flag'</span>,0,{0,1},<span class="keyword">...</span>
0132   <span class="string">'auto_gen_test_data_flag'</span>,0,{0,1},<span class="keyword">...</span>
0133   },false);
0134 
0135 <span class="keyword">if</span> options.auto_gen_test_data_flag
0136   varargs = varargin;
0137   varargs{<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(strcmp(varargs, <span class="string">'auto_gen_test_data_flag'</span>))+1} = 0;
0138   varargs(end+1:end+2) = {<span class="string">'unit_test_flag'</span>,1};
0139   argin = [{specification}, varargs]; <span class="comment">% specific to this function</span>
0140 <span class="keyword">end</span>
0141 
0142 <span class="comment">% check if a model</span>
0143 <span class="keyword">if</span> isfield(specification,<span class="string">'state_variables'</span>)
0144   <span class="comment">% do nothing</span>
0145   model=specification;
0146   <span class="keyword">return</span>;
0147 <span class="comment">%   TODO: consider the following --</span>
0148 <span class="comment">%   if isfield(specification,'specification')</span>
0149 <span class="comment">%     % regenerate from specification</span>
0150 <span class="comment">%     specification=specification.specification;</span>
0151 <span class="comment">%   end</span>
0152 <span class="keyword">end</span>
0153 <span class="comment">% standardize specification</span>
0154 specification=<a href="dsCheckSpecification.html" class="code" title="function spec = dsCheckSpecification(specification, varargin)">dsCheckSpecification</a>(specification, varargin{:}); <span class="comment">% standardize &amp; auto-populate as needed</span>
0155 
0156 <span class="comment">% Apply modifications to specification before generating model</span>
0157 <span class="keyword">if</span> ~isempty(options.modifications)
0158   specification=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(specification,options.modifications, varargin{:});
0159 <span class="keyword">end</span>
0160 
0161 <span class="comment">% specification metadata:</span>
0162 npops=length(specification.populations); <span class="comment">% number of populations</span>
0163 ncons=length(specification.connections); <span class="comment">% number of connections</span>
0164 
0165 <span class="comment">%{</span>
0166 <span class="comment">% Dev notes on improving implementation:</span>
0167 <span class="comment">% Ideally (1.0)-(3.0) could be packaged into external functions and run as:</span>
0168 <span class="comment">% -------------------------------------------------------------------------</span>
0169 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0170 <span class="comment">% [model,name_map]=LoadModelSet(specification) % bug: disrupted subsequent namespace propagation (without raising an error)</span>
0171 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0172 <span class="comment">% model = dsPropagateNamespaces(model,name_map); % this works</span>
0173 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0174 <span class="comment">% model = LinkMechanisms(model,name_map);      % problem: unable to identify linker population from model.linkers; see notes below (3.0) for more details</span>
0175 <span class="comment">% -------------------------------------------------------------------------</span>
0176 <span class="comment">%}</span>
0177 
0178 <span class="comment">% support full modularization of mechanisms</span>
0179 <span class="comment">% (eg, dv/dt=@M; {Na,K}@M w/ Na.mech: @current += I(IN,m,h)).</span>
0180 <span class="comment">%     approach taken below:</span>
0181 <span class="comment">%     - add support for dv/dt=@M; {Na@M,K@M}</span>
0182 <span class="comment">%       have dsGenerateModel split mech_name on '@' and replace first</span>
0183 <span class="comment">%       linker in mech (e.g., @current) by what follows '@' (e.g., @M)</span>
0184 <span class="comment">%     - then have dsCheckSpecification convert {Na,K}@M into {Na@M,K@M}</span>
0185 
0186 <span class="comment">%% 1.0 load sub-models, assign namespaces, and combine across all equations and mechanisms in specification</span>
0187 model.parameters={};
0188 model.fixed_variables=[];
0189 model.functions=[];
0190 model.monitors=[];
0191 model.state_variables={};
0192 model.ODEs=[];
0193 model.ICs=[];
0194 model.conditionals=[];
0195 model.linkers=[];
0196 model.comments={};
0197 name_map={}; <span class="comment">% {name, namespace_name, namespace, type}, used for namespacing</span>
0198 linker_pops={}; <span class="comment">% list of populations associated with mechanism linkers</span>
0199 
0200 <span class="comment">% 1.1 load and combine population sub-models from population equations and mechanisms</span>
0201 <span class="keyword">for</span> i=1:npops
0202   <span class="comment">% does the population model already exist?</span>
0203   <span class="keyword">if</span> ~isempty(specification.populations(i).model)
0204     tmpmodel=specification.populations(i).model; <span class="comment">% get model structure</span>
0205     tmpname=tmpmodel.specification.populations.name; <span class="comment">% assumes one population sub-model</span>
0206     
0207     <span class="comment">% adjust the name if necessary</span>
0208     <span class="keyword">if</span> ~strcmp(specification.populations(i).name,tmpname)
0209       <span class="comment">% use the name in the specification</span>
0210       tmpmodel=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,specification.populations(i).name}, varargin{:});
0211     <span class="keyword">elseif</span> strcmp(tmpname,<span class="string">'pop1'</span>) <span class="comment">% if default name</span>
0212       <span class="comment">% use default name for this population index</span>
0213       tmpmodel=<a href="dsApplyModifications.html" class="code" title="function [output,modifications] = dsApplyModifications(model, modifications, varargin)">dsApplyModifications</a>(tmpmodel,{tmpname,<span class="string">'name'</span>,sprintf(<span class="string">'pop%g'</span>,i)}, varargin{:});
0214     <span class="keyword">end</span>
0215     
0216     tmpmodel.linkers=[]; <span class="comment">% remove old linkers from original model construction</span>
0217     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0218     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmodel.namespaces);
0219     <span class="keyword">continue</span>;
0220   <span class="keyword">end</span>
0221   <span class="comment">% construct new population model</span>
0222   PopScope=specification.populations(i).name;
0223     <span class="comment">% NOTE: dsParseModelEquations adds a '_' suffix to the namespace; therefore,</span>
0224     <span class="comment">% a '_' suffix is added to PopScope when used below for consistency of</span>
0225     <span class="comment">% namespaces/namespaces. (this could be cleaned up by adding '_' to PopScope</span>
0226     <span class="comment">% here, removing it below, and removing the additional '_' from</span>
0227     <span class="comment">% dsParseModelEquations).</span>
0228     
0229   <span class="comment">% 1.1.1 parse population equations</span>
0230   equations=specification.populations(i).equations;
0231   parameters=specification.populations(i).parameters;
0232   nmechs=length(specification.populations(i).mechanism_list);
0233   
0234   <span class="comment">% parse population equations</span>
0235   <span class="keyword">if</span> ~isempty(equations)
0236     [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(equations,<span class="string">'namespace'</span>,PopScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0237     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0238     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0239   <span class="keyword">end</span>
0240   
0241   <span class="comment">% 1.1.2 parse population mechanisms</span>
0242   <span class="keyword">for</span> j=1:nmechs
0243     mechanism_=specification.populations(i).mechanism_list{j};
0244     
0245     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0246     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0247     mechanism=mechanism_{1};
0248     
0249     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0250     
0251     <span class="comment">% set mechanism namespace</span>
0252     <span class="keyword">if</span> any(mechanism==<span class="string">':'</span>)
0253       <span class="comment">% exclude host name from namespace</span>
0254       tmp=regexp(mechanism,<span class="string">':'</span>,<span class="string">'split'</span>);
0255       MechScope=[specification.populations(i).name <span class="string">'_'</span> tmp{2}];
0256     <span class="keyword">else</span>
0257       <span class="comment">% extract mechanism file name without path</span>
0258       [~,MechID]=fileparts2(mechanism);
0259       MechScope=[specification.populations(i).name <span class="string">'_'</span> MechID];
0260     <span class="keyword">end</span>
0261 
0262     <span class="comment">% parse mechanism equations</span>
0263     [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,specification.populations(i).name,<span class="string">'user_parameters'</span>,parameters);
0264     <span class="comment">% replace 1st linker name by the one in specification</span>
0265     <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0266       <span class="comment">% first try to find 1st linker target starting with @</span>
0267       links_at=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp({tmpmodel.linkers.target},<span class="string">'^@'</span>,<span class="string">'once'</span>)));
0268       
0269       <span class="keyword">if</span> ~isempty(links_at)
0270         <span class="comment">% use first link with target prepended by '@'</span>
0271         link_ind=links_at(1);
0272       <span class="keyword">else</span>
0273         <span class="comment">% use first link</span>
0274         link_ind=1;
0275       <span class="keyword">end</span>
0276       
0277       tmpmodel.linkers(link_ind).target=[<span class="string">'@'</span> new_linker];
0278     <span class="keyword">end</span>
0279     
0280     <span class="comment">% combine sub-model with other sub-models</span>
0281     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0282     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0283     linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat({specification.populations(i).name},[1 length(tmpmodel.linkers)]));
0284   <span class="keyword">end</span>
0285   pop=specification.populations(i).name;
0286   
0287   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0288   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(pop,pop,[PopScope <span class="string">'_'</span>]);
0289   model.parameters.([pop <span class="string">'_Npop'</span>])=num2str(specification.populations(i).size);
0290 <span class="keyword">end</span>
0291 
0292 <span class="comment">% 1.2 load and combine sub-models from connection mechanisms</span>
0293 <span class="keyword">for</span> i=1:ncons
0294   <span class="comment">% parse connection mechanisms</span>
0295   source=specification.connections(i).source;
0296   target=specification.connections(i).target;
0297   parameters=specification.connections(i).parameters;
0298   ConScope=[target <span class="string">'_'</span> source <span class="string">'_'</span>];
0299     <span class="comment">% NOTE: in contrast to PopScope above, ConScope is never passed to</span>
0300     <span class="comment">% dsParseModelEquations; thus the '_' should be added here for consistency</span>
0301     <span class="comment">% with mechanism namespaces (which are modified by dsParseModelEquations).</span>
0302   <span class="keyword">for</span> j=1:length(specification.connections(i).mechanism_list)
0303     mechanism_=specification.connections(i).mechanism_list{j};
0304     
0305     <span class="comment">% support separation of linker names in pop equations vs mechanisms</span>
0306     mechanism_=regexp(mechanism_,<span class="string">'@'</span>,<span class="string">'split'</span>);
0307     mechanism=mechanism_{1};
0308     
0309     <span class="keyword">if</span> numel(mechanism_)&gt;1, new_linker=mechanism_{2}; <span class="keyword">else</span> new_linker=[]; <span class="keyword">end</span>
0310     
0311     <span class="comment">% extract mechanism file name without path</span>
0312     [~,MechID]=fileparts2(mechanism);
0313     MechScope=[target <span class="string">'_'</span> source <span class="string">'_'</span> MechID];
0314         <span class="comment">% NOTE: must use target_source_mechanism for connection mechanisms</span>
0315         <span class="comment">% to distinguish their parent namespaces from those of population mechanisms</span>
0316         <span class="comment">% see: dsGetParentNamespace</span>
0317     
0318     <span class="comment">% parse model equations</span>
0319     [tmpmodel,tmpmap]=<a href="dsImportModel.html" class="code" title="function [model,map] = dsImportModel(source,varargin)">dsImportModel</a>(mechanism,<span class="string">'namespace'</span>,MechScope,<span class="string">'ic_pop'</span>,source,<span class="string">'user_parameters'</span>,parameters);
0320     
0321     <span class="comment">% replace 1st linker name by the one in specification</span>
0322     <span class="keyword">if</span> ~isempty(new_linker) &amp;&amp; ~isempty(tmpmodel.linkers)
0323       tmpmodel.linkers(1).target=[<span class="string">'@'</span> new_linker];
0324     <span class="keyword">end</span>
0325     
0326     model=<a href="dsCombineModels.html" class="code" title="function model = dsCombineModels(model1,model2, varargin)">dsCombineModels</a>(model,tmpmodel, varargin{:});
0327     name_map=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(1,name_map,tmpmap);
0328     
0329     <span class="comment">% link this mechanism to the target population</span>
0330     linker_pops=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,linker_pops,repmat(target,[1 length(tmpmodel.linkers)]));
0331     
0332     <span class="comment">% edit names of connection monitors specified in population equations</span>
0333     <span class="comment">% TODO: consider design changes to avoid specifying connection monitors</span>
0334     <span class="comment">%   in population equations; this is an undesirable hack:</span>
0335     <span class="comment">%     eg, convert E_iGABAa_functions -&gt; I_E_iGABAa_functions</span>
0336     <span class="keyword">if</span> ~isempty(model.monitors)
0337       <span class="comment">% get indices to all model.monitors that have incorrect connection namespace</span>
0338       con_mon_to_update=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(~cellfun(@isempty,regexp(<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors),[<span class="string">'^'</span> target <span class="string">'_'</span> mechanism])));
0339       <span class="keyword">if</span> any(con_mon_to_update)
0340         <span class="comment">% get list of current model.monitors</span>
0341         monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0342         <span class="keyword">for</span> m=1:length(con_mon_to_update)
0343           <span class="comment">% get name of monitor with incorrect connection namespace</span>
0344           old=monitor_names{con_mon_to_update(m)};
0345           
0346           <span class="comment">% get name of monitor with correct connection namespace</span>
0347           new=strrep(old,[target <span class="string">'_'</span> mechanism <span class="string">'_'</span>],[MechScope <span class="string">'_'</span>]);
0348           
0349           <span class="comment">% add new monitor with correct namespace</span>
0350           model.monitors.(new)=model.monitors.(old);
0351           
0352           <span class="comment">% remove old monitor with incorrect namespace</span>
0353           model.monitors=rmfield(model.monitors,old);
0354         <span class="keyword">end</span>
0355       <span class="keyword">end</span>
0356     <span class="keyword">end</span>
0357   <span class="keyword">end</span>
0358   <span class="comment">% add reserved keywords (parameters and state variables) to name_map</span>
0359   <a href="#_sub8" class="code" title="subfunction add_keywords(src,dst,namespace)">add_keywords</a>(source,target,ConScope);
0360 <span class="keyword">end</span>
0361 
0362 <span class="comment">% check for monitoring functions (e.g., 'monitor functions' or 'monitor Na.functions')</span>
0363 <span class="keyword">if</span> ~isempty(model.monitors)
0364   <span class="comment">% get list of functions</span>
0365   <span class="keyword">if</span> ~isempty(model.functions)
0366     <a name="_sub1" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0367   <span class="keyword">else</span>
0368     <a name="_sub2" href="#_subfunctions" class="code">function_names={};</a>
0369   <span class="keyword">end</span>
0370   <span class="comment">% get list of monitor names</span>
0371   monitor_names=<a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.monitors);
0372   
0373   <span class="comment">% get indices to monitors with names ending in _functions</span>
0374   <a name="_sub3" href="#_subfunctions" class="code">function_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,</a><span class="string">'_functions$'</span>,<span class="string">'once'</span>)));
0375   
0376   <span class="comment">% create list of functions with namespaces matching monitors ending in _functions</span>
0377   <a name="_sub4" href="#_subfunctions" class="code">functions_to_monitor={};</a>
0378   
0379   <span class="keyword">for</span> i=1:length(function_monitor_index)
0380     <span class="comment">% get namespace of functions to monitor</span>
0381     monitor_name=monitor_names{function_monitor_index(i)};
0382     monitor_namespace=regexp(monitor_name,<span class="string">'(.*)_functions$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0383     monitor_namespace=monitor_namespace{1};
0384     
0385     <span class="comment">% get list of functions with matching namespace</span>
0386     <a name="_sub5" href="#_subfunctions" class="code">function_index=find(~cellfun(@isempty,regexp(function_names,[</a><span class="string">'^'</span> monitor_namespace],<span class="string">'once'</span>)));
0387     
0388     <span class="comment">% add functions to list</span>
0389     <a name="_sub6" href="#_subfunctions" class="code">functions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));</a>
0390     
0391     <span class="comment">% remove &quot;function&quot; monitor name</span>
0392     model.monitors=rmfield(model.monitors,monitor_name);
0393   <span class="keyword">end</span>
0394   
0395   <span class="comment">% eliminate duplicate function names</span>
0396   <a name="_sub7" href="#_subfunctions" class="code">functions_to_monitor=unique(functions_to_monitor);</a>
0397   
0398   <span class="comment">% add functions to monitor list</span>
0399   <span class="keyword">for</span> i=1:length(functions_to_monitor)
0400     model.monitors.(functions_to_monitor{i})=[];
0401   <span class="keyword">end</span>
0402 <span class="keyword">end</span>
0403 
0404   <span class="comment">% ----------------------------------</span>
0405   <span class="comment">% NESTED FUNCTIONS</span>
0406   <span class="comment">% ----------------------------------</span>
0407   <a name="_sub8" href="#_subfunctions" class="code">function add_keywords(src,dst,namespace)</a>
0408     <span class="comment">% NOTE: this needs to be coordinated with update_keywords() in dsSimulate()</span>
0409     <span class="comment">%   for parameters</span>
0410     Nsrc=[src <span class="string">'_Npop'</span>];
0411     Ndst=[dst <span class="string">'_Npop'</span>];
0412     
0413     old={<span class="string">'Npre'</span>,<span class="string">'N[1]'</span>,<span class="string">'N_pre'</span>,<span class="string">'Npost'</span>,<span class="string">'N_post'</span>,<span class="string">'N[0]'</span>,<span class="string">'Npop'</span>,<span class="string">'N_pop'</span>};
0414     new={Nsrc,Nsrc,Nsrc,Ndst,Ndst,Ndst,Ndst,Ndst};
0415     <span class="keyword">for</span> p=1:length(old)
0416       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'parameters'</span>};
0417     <span class="keyword">end</span>
0418     
0419     <span class="comment">% for state variables</span>
0420     new={};
0421     old={};
0422     src_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'pre'</span> <span class="string">'$'</span>]));
0423     dst_excluded=~cellfun(@isempty,regexp(name_map(:,1),[<span class="string">'post'</span> <span class="string">'$'</span>]));
0424     excluded=src_excluded|dst_excluded;
0425     
0426     PopScope=[src <span class="string">'_'</span>];
0427     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0428     <span class="keyword">if</span> any(var_idx)
0429       Xsrc_old_vars=name_map(var_idx,1);
0430       Xsrc_new_vars=name_map(var_idx,2);
0431       <span class="comment">% default for IN is first Xsrc state var</span>
0432       Xsrc=Xsrc_new_vars{1};
0433       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'IN'</span>,<span class="string">'Xpre'</span>,<span class="string">'X_pre'</span>});
0434       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xsrc,Xsrc,Xsrc});
0435     <span class="keyword">else</span>
0436       Xsrc_old_vars=[];
0437       Xsrc_new_vars=[];
0438       Xsrc=[];
0439     <span class="keyword">end</span>
0440     
0441     PopScope=[dst <span class="string">'_'</span>];
0442     var_idx=strcmp(PopScope,name_map(:,3)) &amp; strcmp(<span class="string">'state_variables'</span>,name_map(:,4)) &amp; ~excluded;
0443     <span class="keyword">if</span> any(var_idx)
0444       Xdst_old_vars=name_map(var_idx,1);
0445       Xdst_new_vars=name_map(var_idx,2);
0446       <span class="comment">% default for OUT and X is first Xdst state var</span>
0447       Xdst=Xdst_new_vars{1};
0448       old=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,old,{<span class="string">'OUT'</span>,<span class="string">'X'</span>,<span class="string">'Xpost'</span>,<span class="string">'X_post'</span>});
0449       new=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,new,{Xdst,Xdst,Xdst,Xdst});
0450     <span class="keyword">else</span>
0451       Xdst_old_vars=[];
0452       Xdst_new_vars=[];
0453       Xdst=[];
0454     <span class="keyword">end</span>
0455     
0456     <span class="comment">% add variants [var_pre,var_post,varpre,varpost]</span>
0457     <span class="keyword">if</span> ~isempty(Xsrc_old_vars)
0458       [Xsrc_old_vars,IA]=setdiff(Xsrc_old_vars,old);
0459       Xsrc_new_vars=Xsrc_new_vars(IA);
0460     <span class="keyword">end</span>
0461     
0462     <span class="keyword">if</span> ~isempty(Xdst_old_vars)
0463       [Xdst_old_vars,IA]=setdiff(Xdst_old_vars,old);
0464       Xdst_new_vars=Xdst_new_vars(IA);
0465     <span class="keyword">end</span>
0466     
0467     <span class="keyword">for</span> p=1:length(Xsrc_old_vars)
0468       old{end+1}=[Xsrc_old_vars{p} <span class="string">'_pre'</span>];
0469       new{end+1}=Xsrc_new_vars{p};
0470       old{end+1}=[Xsrc_old_vars{p} <span class="string">'pre'</span>];
0471       new{end+1}=Xsrc_new_vars{p};
0472     <span class="keyword">end</span>
0473     
0474     <span class="keyword">for</span> p=1:length(Xdst_old_vars)
0475       old{end+1}=[Xdst_old_vars{p} <span class="string">'_post'</span>];
0476       new{end+1}=Xdst_new_vars{p};
0477       old{end+1}=[Xdst_old_vars{p} <span class="string">'post'</span>];
0478       new{end+1}=Xdst_new_vars{p};
0479     <span class="keyword">end</span>
0480     
0481     <span class="keyword">for</span> p=1:length(old)
0482       name_map(end+1,:)={old{p},new{p},namespace,<span class="string">'state_variables'</span>};
0483     <span class="keyword">end</span>
0484   <span class="keyword">end</span>
0485 
0486 <span class="comment">%% 2.0 propagate namespaces through variable and function names</span>
0487 <span class="comment">%      i.e., to establish uniqueness of names by adding namespace/namespace prefixes)</span>
0488 model = <a href="dsPropagateNamespaces.html" class="code" title="function model = dsPropagateNamespaces(model,map, varargin)">dsPropagateNamespaces</a>(model,name_map, varargin{:});
0489 
0490 <span class="comment">%% 3.0 expand population equations according to mechanism linkers</span>
0491 <span class="comment">% purpose: expand population equations according to linkers</span>
0492 <span class="comment">% - link populations.equations to mechanism sub-models</span>
0493 <span class="comment">% - link mechanism functions and state variables across mechanisms in a given population</span>
0494 
0495 <span class="comment">% store indices to all expressions and conditionals that are linked (this</span>
0496 <span class="comment">% is necessary for efficiently removing linker targets from expressions after linking)</span>
0497 all_expression_inds=[];
0498 all_expression_targets={};
0499 all_conditionals_inds=[];
0500 all_conditionals_targets={};
0501 
0502 <span class="comment">% add variables to linked expression if its a function without ()</span>
0503 <span class="keyword">if</span> ~isempty(model.functions) &amp;&amp; ~isempty(model.linkers)
0504   <a name="_sub9" href="#_subfunctions" class="code">function_names=fieldnames(model.functions);</a>
0505   expressions={model.linkers.expression};
0506   [~,I,J]=intersect(function_names,expressions);
0507   <span class="keyword">for</span> i=1:length(I)
0508     e=model.functions.(function_names{J(i)}); <span class="comment">% function expression (eg,'@(x,y,z)x-(y-z)')</span>
0509     v=regexp(e,<span class="string">'@(\([\w,]+\))'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% function input list (eg, '(x,y,z)')</span>
0510     <span class="keyword">if</span> ~isempty(v)
0511       model.linkers(I(i)).expression=[model.linkers(I(i)).expression v{1}];
0512     <span class="keyword">end</span>
0513   <span class="keyword">end</span>
0514 <span class="keyword">end</span>
0515 
0516 <span class="comment">% loop over linkers</span>
0517 <span class="keyword">for</span> i=1:length(model.linkers)
0518   <span class="comment">% determine how to link</span>
0519   operation=model.linkers(i).operation;
0520   oldstr=model.linkers(i).target;
0521   newstr=model.linkers(i).expression;
0522   <span class="keyword">switch</span> operation <span class="comment">% see dsClassifyEquation and dsParseModelEquations   % ('((\+=)|(-=)|(\*=)|(/=)|(=&gt;))')</span>
0523     <span class="keyword">case</span> <span class="string">'+='</span>
0524       operator=<span class="string">'+'</span>;
0525     <span class="keyword">case</span> <span class="string">'-='</span>
0526       operator=<span class="string">'-'</span>;
0527     <span class="keyword">case</span> <span class="string">'*='</span>
0528       operator=<span class="string">'.*'</span>;
0529     <span class="keyword">case</span> <span class="string">'/='</span>
0530       operator=<span class="string">'./'</span>;
0531     <span class="keyword">otherwise</span>
0532       operator=<span class="string">'+'</span>;
0533   <span class="keyword">end</span>
0534   <span class="comment">% determine what to link (ie, link across everything belonging to the linker population)</span>
0535   <span class="comment">% explicitly constrain to linker population</span>
0536   expressions_in_pop=~cellfun(@isempty,regexp(name_map(:,3),[<span class="string">'^'</span> linker_pops{i}]));
0537   
0538   <span class="keyword">if</span> ~isempty(model.conditionals)
0539     conditionals_in_pop=~cellfun(@isempty,regexp({model.conditionals.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0540   <span class="keyword">end</span>
0541   
0542   <span class="keyword">if</span> ~isempty(model.linkers)
0543     linkers_in_pop=~cellfun(@isempty,regexp({model.linkers.namespace},[<span class="string">'^'</span> linker_pops{i}]));
0544   <span class="keyword">end</span>
0545   
0546   <span class="comment">% constrain to namespace</span>
0547   names_in_namespace=cellfun(@(x,y)strncmp(y,x,length(y)),name_map(:,2),name_map(:,3));
0548   
0549   <span class="comment">% get list of (functions,monitors,ODEs) belonging to the linker population</span>
0550   eqn_types={<span class="string">'ODEs'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','ODEs'};</span>
0551   search_types={<span class="string">'state_variables'</span>,<span class="string">'monitors'</span>,<span class="string">'functions'</span>};<span class="comment">%{'monitors','state_variables'};</span>
0552   
0553   <span class="comment">% indices to expressions in the linker population with the correct search_types and namespace</span>
0554   inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(expressions_in_pop&amp;names_in_namespace&amp;ismember(name_map(:,4),search_types));
0555   
0556   <span class="comment">% eliminate duplicates (e.g., state_variables replacing OUT and X)</span>
0557   [jnk,ia,ib]=<a href="#_sub7" class="code" title="subfunctions_to_monitor=unique(functions_to_monitor);">unique</a>(name_map(inds,2),<span class="string">'stable'</span>);
0558   inds=inds(ia);
0559   all_expression_inds=[all_expression_inds inds'];
0560   all_expression_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_expression_targets,repmat({oldstr},[1 length(inds)]));
0561  
0562   <span class="comment">% substitute link</span>
0563   <span class="keyword">for</span> j=1:length(inds)
0564     name=name_map{inds(j),2}; <span class="comment">% name of variable as stored in model structure</span>
0565     type=name_map{inds(j),4}; <span class="comment">% search_types</span>
0566     eqn_type=eqn_types{strcmp(type,search_types)}; <span class="comment">% corresponding equation type</span>
0567     
0568     <span class="comment">% update expression with the current link</span>
0569     <span class="keyword">if</span> isfield(model.(eqn_type),name)
0570       <span class="comment">% note: name will not be a field of eqn_type for special monitors</span>
0571       <span class="comment">% (e.g., monitor functions)</span>
0572       model.(eqn_type).(name)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.(eqn_type).(name),oldstr,newstr,operator);
0573     <span class="keyword">end</span>
0574   <span class="keyword">end</span>
0575   
0576   <span class="keyword">if</span> ~isempty(model.conditionals)
0577     fields={<span class="string">'condition'</span>,<span class="string">'action'</span>,<span class="string">'else'</span>};
0578     
0579     <span class="comment">% get list of conditionals belonging to the linker population</span>
0580     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(conditionals_in_pop);
0581     all_conditionals_inds=[all_conditionals_inds inds];
0582     all_conditionals_targets=<a href="#_sub6" class="code" title="subfunctions_to_monitor=cat(1,functions_to_monitor,function_names(function_index));">cat</a>(2,all_conditionals_targets,repmat({oldstr},[1 length(inds)]));
0583     
0584     <span class="comment">% substitute link</span>
0585     <span class="keyword">for</span> j=1:length(inds)
0586       <span class="keyword">for</span> field_index=1:length(fields)
0587         field=fields{field_index};
0588         model.conditionals(inds(j)).(field)=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.conditionals(inds(j)).(field),oldstr,newstr,operator);
0589       <span class="keyword">end</span>
0590     <span class="keyword">end</span>
0591   <span class="keyword">end</span>
0592   
0593   <span class="keyword">if</span> ~isempty(model.linkers)
0594     inds=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(linkers_in_pop);
0595     <span class="keyword">for</span> j=1:length(inds)
0596       model.linkers(inds(j)).expression=<a href="#_sub10" class="code" title="subfunction str=linker_strrep(str,oldstr,newstr,operator)">linker_strrep</a>(model.linkers(inds(j)).expression,oldstr,newstr,operator);
0597     <span class="keyword">end</span>
0598   <span class="keyword">end</span>
0599 <span class="keyword">end</span>
0600 
0601 <span class="keyword">if</span> options.open_link_flag==0
0602   <span class="comment">% remove target placeholders from expressions and conditionals</span>
0603   <span class="keyword">for</span> i=1:length(all_expression_inds)
0604     oldstr=all_expression_targets{i};
0605     newstr=<span class="string">''</span>;
0606     name=name_map{all_expression_inds(i),2};
0607     type=name_map{all_expression_inds(i),4};
0608     eqn_type=eqn_types{strcmp(type,search_types)};
0609     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0610     replace = [newstr <span class="string">'))'</span>];
0611     <span class="keyword">if</span> isfield(model.(eqn_type),name) &amp;&amp; ischar(model.(eqn_type).(name))
0612         <span class="comment">% NOTE: name will not be a field of eqn_type for special monitors</span>
0613         <span class="comment">% (e.g., monitor functions)</span>
0614       model.(eqn_type).(name)=regexprep(model.(eqn_type).(name),pattern,replace);
0615     <span class="keyword">end</span>
0616   <span class="keyword">end</span>
0617 <span class="keyword">end</span>
0618 
0619 <span class="keyword">if</span> ~isempty(model.conditionals)
0620   <span class="keyword">for</span> i=1:length(all_conditionals_inds)
0621     oldstr=all_conditionals_targets{i};
0622     newstr=<span class="string">''</span>;
0623     pattern = [<span class="string">'\)\.?[-\+\*/]'</span> oldstr <span class="string">'\)'</span>]; <span class="comment">% pattern accounts for all possible newstr defined for linking</span>
0624     replace = [newstr <span class="string">'))'</span>];
0625     <span class="keyword">for</span> field_index=1:length(fields)
0626       field=fields{field_index};
0627       <span class="keyword">if</span> model.conditionals(all_conditionals_inds(i)).(field)
0628         model.conditionals(all_conditionals_inds(i)).(field)=regexprep(model.conditionals(all_conditionals_inds(i)).(field),pattern,replace);
0629       <span class="keyword">end</span>
0630     <span class="keyword">end</span>
0631   <span class="keyword">end</span>
0632 <span class="keyword">end</span>
0633 
0634 <span class="comment">% ------------------------------------------</span>
0635 <span class="comment">% NOTE on non-ideal implementation of 3.0: model.linkers does not contain enough</span>
0636 <span class="comment">% information to determine the population to which it belongs in all cases</span>
0637 <span class="comment">% (due to namespace format differences for population vs connection mechanisms &amp; models</span>
0638 <span class="comment">% with one vs more populations). consequently, had to perform linking in this</span>
0639 <span class="comment">% function using info stored above while parsing the model; ideally, the</span>
0640 <span class="comment">% linking could occur independently of this function, informed by info in</span>
0641 <span class="comment">% model.linkers, and be packaged in its own external function LinkMechanisms().</span>
0642 <span class="comment">% ------------------------------------------</span>
0643 
0644 <span class="comment">%% 4.0 finalize</span>
0645 
0646 <span class="comment">% 4.1 sort .ODEs and .ICs wrt .state_variables</span>
0647 model.ODEs = orderfields(model.ODEs,model.state_variables);
0648 model.ICs = orderfields(model.ICs,model.state_variables);
0649 
0650 <span class="comment">% 4.2 convert to numeric parameters</span>
0651 c = struct2cell(model.parameters);
0652 
0653 <span class="comment">% get index of strings</span>
0654 idx1=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@ischar,c));
0655 
0656 <span class="comment">% which strings contain numeric values?</span>
0657 idx2=<a href="#_sub3  5" class="code" title="subfunction_monitor_index=find(~cellfun(@isempty,regexp(monitor_names,function_index=find(~cellfun(@isempty,regexp(function_names,[">find</a>(cellfun(@isempty,regexp(c(idx1),<span class="string">'[a-z_A-Z]'</span>)) | ~cellfun(@isempty,regexp(c(idx1),<span class="string">'^\s*\[*\s*\+?inf\s*\]*\s*$'</span>,<span class="string">'ignorecase'</span>)));
0658 
0659 <span class="comment">% convert those strings which contain numeric values</span>
0660 c(idx1(idx2)) = cellfun(@eval,c(idx1(idx2)),<span class="string">'uni'</span>,0);
0661 <span class="comment">%idx=cellfun(@isempty,regexp(c,'[a-z_A-Z]')) | ~cellfun(@isempty,regexp(c,'^\s*\[*\s*inf\s*\]*\s*$','ignorecase'));</span>
0662 <span class="comment">%c(idx) = cellfun(@eval,c(idx),'uni',0);</span>
0663 f = <a href="#_sub1  9" class="code" title="subfunction_names=fieldnames(model.functions);function_names=fieldnames(model.functions);">fieldnames</a>(model.parameters);
0664 model.parameters = cell2struct(c,f,1);
0665 
0666 <span class="comment">% 4.3 store original specification</span>
0667 model.specification = specification; <span class="comment">% store specification to enable modifications to be applied later</span>
0668 model.namespaces = name_map; <span class="comment">% store name_map for transparency</span>
0669 
0670 model=<a href="dsCheckModel.html" class="code" title="function model = dsCheckModel(model, varargin)">dsCheckModel</a>(model, varargin{:});
0671 
0672 <span class="comment">%% auto_gen_test_data_flag argout</span>
0673 <span class="keyword">if</span> options.auto_gen_test_data_flag
0674   argout = {model, name_map}; <span class="comment">% specific to this function</span>
0675   
0676   <a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>(argin, argout);
0677 <span class="keyword">end</span>
0678 
0679 <span class="keyword">end</span> <span class="comment">% main function</span>
0680 
0681 
0682 <span class="comment">%% SUBFUNCTIONS</span>
0683 <a name="_sub10" href="#_subfunctions" class="code">function str=linker_strrep(str,oldstr,newstr,operator)</a>
0684   <span class="keyword">if</span> isempty(str)
0685     <span class="keyword">return</span>;
0686   <span class="keyword">end</span>
0687   <span class="comment">% if inserting one word (e.g., a state variable), just replace it</span>
0688   <span class="comment">% WARNING: could cause problems in future if there is an additive</span>
0689   <span class="comment">% substitution of different state variables into the same place followed</span>
0690   <span class="comment">% by non-additive operations (e.g., @cai+=cai1 and @cai+=cai2 into</span>
0691   <span class="comment">% v'=f(v)*cai where cai1 &amp; cai2 are defined in mechanisms for the same v;</span>
0692   <span class="comment">% workaround: insert into v'=f(v)*(cai)).</span>
0693   
0694   <span class="comment">% check if anything besides a single variable:</span>
0695   <span class="keyword">if</span> isempty(regexp(newstr,<span class="string">'[^a-z_A-Z\d]+'</span>,<span class="string">'once'</span>))
0696     str=<a href="dsStrrep.html" class="code" title="function str = dsStrrep(str,oldstr,newstr,lpad,rpad, varargin)">dsStrrep</a>(str,oldstr,newstr);
0697   <span class="keyword">else</span>
0698     <span class="comment">% otherwise do substitution with operator and parenthesis</span>
0699     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'([^\w]+)'</span>]; <span class="comment">% in the middle</span>
0700     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$2'</span>];
0701     str=regexprep(str,pat,rep);
0702     pat=[<span class="string">'([^\w]+)'</span> oldstr <span class="string">'$'</span>];        <span class="comment">% at the end</span>
0703     rep=[<span class="string">'$1(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0704     str=regexprep(str,pat,rep);
0705     pat=[<span class="string">'^'</span> oldstr <span class="string">'([^\w]+)'</span>];        <span class="comment">% at the beginning</span>
0706     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')$1'</span>];
0707     str=regexprep(str,pat,rep);
0708     pat=[<span class="string">'^'</span> oldstr <span class="string">'$'</span>];               <span class="comment">% all there is</span>
0709     rep=[<span class="string">'(('</span> newstr <span class="string">')'</span> operator oldstr <span class="string">')'</span>];
0710     str=regexprep(str,pat,rep);
0711   <span class="keyword">end</span>
0712 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 23-Jun-2017 18:15:58 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>