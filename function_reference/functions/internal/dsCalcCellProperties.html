<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsCalcCellProperties</title>
  <meta name="keywords" content="dsCalcCellProperties">
  <meta name="description" content="CALCCELLPROPERTIES - calculates the intrinsic electrophysiological properties of all cells in one or more populations">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>

<a name="_top"></a>
<div><a href="../../menu.html">Home</a> &gt;  <a href="../menu.html">functions</a> &gt; <a href="menu.html">internal</a> &gt; dsCalcCellProperties.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../menu.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="menu.html">Index for functions/internal&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>dsCalcCellProperties
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>CALCCELLPROPERTIES - calculates the intrinsic electrophysiological properties of all cells in one or more populations</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function stats = dsCalcCellProperties(data, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">CALCCELLPROPERTIES - calculates the intrinsic electrophysiological properties of all cells in one or more populations

 This is designed to be used in conjunction with the experiment
 dsProbeCellProperties which removes all connections from a model and produces
 a data array of simulated data in response to a series of hyperpolarizing and
 depolarizing pulses. This function is based on the DNSim experiment
 &quot;cell_pulses&quot;.

 Usage:
   stats = dsCalcCellProperties(data,'option1',option1,...)

 Inputs:
   - data: array of DynaSim data structures returned by dsProbeCellProperties

 Outputs:
   - stats.(pop).(measure) [1 x num_cells] (averaged over repetitions)
   - measures (intrinsic properties):
       RMP, V_thresh, R_in, tau_m, FI_slope, CV, AR24, AR_coefficient
       FR_min (threshrate), FR_min2 (steprate?), FR_max (steprate?)
     - AP morphology: AP_amp, AP_dur (spikewidth), AP_taur, AP_taud
                      Ih_relsag, Ih_abssag, hump, AHP_amp, AHP_dur
                      AHP_time2trough, ISI_median, AR23, AR13, ISI1,
                      min_ISI_median, ISI_step_median

 Algorithm walkthrough:
   From Iinj=0:
   RMP = (avg over 50-100% step | Iinj=0)

   From largest hyperpolarizing step:
   Ih Sag = (Vend-Vmin)/|RMP-Vend|
       where Vmin=(min voltage during T sec hyperpolarizing step)
             Vend=(V at end of hyperpolarizing step)
   Ih abs sag = (Vend-Vmin)

   From last subthreshold step:
   Hump = (Vmax-Vend)/|RMP-Vend|
       where Vmax=(max voltage during depolarizing step preceding spike)
             Vend=(V at end of step)

   Across hyperpolarizing subthreshold steps:
   Rin = Input resistence (I/V slope) [4]
   taum = Membrane time constant: time for voltage relaxation to (1/e)Vmax
     where Vmax=max deflection from baseline on hyperpolarizing steps
     note: avg taum's over small drives that keep active currents silent (eg, 5-15pA)

   Across suprathreshold steps with at least two spikes:
   FI slope [Hz/nA]: slope of f/I curve (firing freq vs injected current 0-140pA) (see [2])

   Across suprathreshold steps &gt;=60pA above first step with at least two spikes:
   AR coefficient: (slope of AR/I) where per step AR=ISI(1)/ISI(end)
   Note: AR = Adaptation ratio
   ISI_step_median = median ISI on step 60pA above first step w/ 2 spikes
   FR_step = mean FR on step 60pA above first step w/ 2 spikes
   ARif = max AR across steps &gt;=60pA above first step w/ 2 spikes

   From first suprathreshold T sec step:
   FRmin (threshrate) = (# spikes)/T

   From first suprathreshold T sec step with at least two spikes:
   FRmin2 (steprate?) = (# spikes)/T

   From first spike of first suprathreshold step: AP morphology
   Vthresh = V( crossing(dV/dt,20mV/ms) ) %10mV/ms) )
   AP_amp = (Vpeak-Vthresh)
   AP_taur = (time to rise from 10% to 90% between Vthresh and Vpeak)
   AP_taud = (time to decay from 10% to 90% between Vpeak and Vthresh)
   AP_dur (spikewidth) = (time between rising and falling (Vthresh+APamp/2) = (Vthresh+Vpeak)/2)
   AHP_amp = (Vbaseline-Vmin) where Vmin taken during repolarizing phase
   AHP_dur (AHP duration, half-width) = time between half-peak amplitude of AHP
                                     = (time between falling and rising (Vbaseline+AHPamp/2))
   AHP_time2trough = (time between falling Vbaseline and AHPamp)
   ADPamp? ADPdur?

   From suprathreshold step 20pA above first step with at least two spikes:
   CV(ISIs over 30-100% step)

   From last suprathreshold T sec step (or step at amp=max (eg, 140pA)):
   FR_max (steprate?): (# spikes)/T
   min_ISI_median
   max_ISI
   AR24 = ISI(2)/ISI(4)

 References for methods used:
   [1] Steffensen, Scott C., et al. &quot;Electrophysiological characterization of
     GABAergic neurons in the ventral tegmental area.&quot; The Journal of
     neuroscience 18.19 (1998): 8003-8015.
   [2] Van Aerde, Karlijn I., et al. &quot;Flexible spike timing of layer 5 neurons
     during dynamic beta oscillation shifts in rat prefrontal cortex.&quot; The
     Journal of physiology 587.21 (2009): 5177-5196.
   [3] Connors, BW, MJ Gutnick, DA Prince. &quot;Electrophysiological properties of
     neocortical neurons in vitro.&quot; Journal of Neurophysiology 48.6 (1982):
     1302-1320.
   [4] Povysheva, Nadezhda V., et al. &quot;Parvalbumin-positive basket
     interneurons in monkey and rat prefrontal cortex.&quot; Journal of
     neurophysiology 100.4 (2008): 2348-2360.
   [5] Gonz?lez-Burgos, Guillermo, et al. &quot;Functional properties of fast
     spiking interneurons and their synaptic connections with pyramidal cells in
     primate dorsolateral prefrontal cortex.&quot; Journal of Neurophysiology 93.2
     (2005): 942-953.
   [6] Gorelova, Natalia, Jeremy K. Seamans, and Charles R. Yang. &quot;Mechanisms
     of dopamine activation of fast-spiking interneurons that exert inhibition
     in rat prefrontal cortex.&quot; Journal of neurophysiology 88.6 (2002):
     3150-3166.

 Example:
   data = dsProbeCellProperties(model)
   stats = dsCalcCellProperties(data)

 See also: <a href="dsProbeCellProperties.html" class="code" title="function data = dsProbeCellProperties(model,varargin)">dsProbeCellProperties</a>

 Author: Jason Sherfey, PhD &lt;jssherfey@gmail.com&gt;
 Copyright (C) 2016 Jason Sherfey, Boston University, USA</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="dsCheckData.html" class="code" title="function data = dsCheckData(data, varargin)">dsCheckData</a>	CHECKDATA - Standardize data structure and auto-populate missing fields</li><li><a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="dsSelectVariables.html" class="code" title="function [variables,pop_names] = dsSelectVariables(labels,var_strings, varargin)">dsSelectVariables</a>	SELECTVARIABLES - determine what variables to plot</li><li><a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>	Inputs:</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function stats = dsCalcCellProperties(data, varargin)</a>
0002 <span class="comment">%CALCCELLPROPERTIES - calculates the intrinsic electrophysiological properties of all cells in one or more populations</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% This is designed to be used in conjunction with the experiment</span>
0005 <span class="comment">% dsProbeCellProperties which removes all connections from a model and produces</span>
0006 <span class="comment">% a data array of simulated data in response to a series of hyperpolarizing and</span>
0007 <span class="comment">% depolarizing pulses. This function is based on the DNSim experiment</span>
0008 <span class="comment">% &quot;cell_pulses&quot;.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Usage:</span>
0011 <span class="comment">%   stats = dsCalcCellProperties(data,'option1',option1,...)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Inputs:</span>
0014 <span class="comment">%   - data: array of DynaSim data structures returned by dsProbeCellProperties</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Outputs:</span>
0017 <span class="comment">%   - stats.(pop).(measure) [1 x num_cells] (averaged over repetitions)</span>
0018 <span class="comment">%   - measures (intrinsic properties):</span>
0019 <span class="comment">%       RMP, V_thresh, R_in, tau_m, FI_slope, CV, AR24, AR_coefficient</span>
0020 <span class="comment">%       FR_min (threshrate), FR_min2 (steprate?), FR_max (steprate?)</span>
0021 <span class="comment">%     - AP morphology: AP_amp, AP_dur (spikewidth), AP_taur, AP_taud</span>
0022 <span class="comment">%                      Ih_relsag, Ih_abssag, hump, AHP_amp, AHP_dur</span>
0023 <span class="comment">%                      AHP_time2trough, ISI_median, AR23, AR13, ISI1,</span>
0024 <span class="comment">%                      min_ISI_median, ISI_step_median</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Algorithm walkthrough:</span>
0027 <span class="comment">%   From Iinj=0:</span>
0028 <span class="comment">%   RMP = (avg over 50-100% step | Iinj=0)</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%   From largest hyperpolarizing step:</span>
0031 <span class="comment">%   Ih Sag = (Vend-Vmin)/|RMP-Vend|</span>
0032 <span class="comment">%       where Vmin=(min voltage during T sec hyperpolarizing step)</span>
0033 <span class="comment">%             Vend=(V at end of hyperpolarizing step)</span>
0034 <span class="comment">%   Ih abs sag = (Vend-Vmin)</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   From last subthreshold step:</span>
0037 <span class="comment">%   Hump = (Vmax-Vend)/|RMP-Vend|</span>
0038 <span class="comment">%       where Vmax=(max voltage during depolarizing step preceding spike)</span>
0039 <span class="comment">%             Vend=(V at end of step)</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   Across hyperpolarizing subthreshold steps:</span>
0042 <span class="comment">%   Rin = Input resistence (I/V slope) [4]</span>
0043 <span class="comment">%   taum = Membrane time constant: time for voltage relaxation to (1/e)Vmax</span>
0044 <span class="comment">%     where Vmax=max deflection from baseline on hyperpolarizing steps</span>
0045 <span class="comment">%     note: avg taum's over small drives that keep active currents silent (eg, 5-15pA)</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%   Across suprathreshold steps with at least two spikes:</span>
0048 <span class="comment">%   FI slope [Hz/nA]: slope of f/I curve (firing freq vs injected current 0-140pA) (see [2])</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%   Across suprathreshold steps &gt;=60pA above first step with at least two spikes:</span>
0051 <span class="comment">%   AR coefficient: (slope of AR/I) where per step AR=ISI(1)/ISI(end)</span>
0052 <span class="comment">%   Note: AR = Adaptation ratio</span>
0053 <span class="comment">%   ISI_step_median = median ISI on step 60pA above first step w/ 2 spikes</span>
0054 <span class="comment">%   FR_step = mean FR on step 60pA above first step w/ 2 spikes</span>
0055 <span class="comment">%   ARif = max AR across steps &gt;=60pA above first step w/ 2 spikes</span>
0056 <span class="comment">%</span>
0057 <span class="comment">%   From first suprathreshold T sec step:</span>
0058 <span class="comment">%   FRmin (threshrate) = (# spikes)/T</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%   From first suprathreshold T sec step with at least two spikes:</span>
0061 <span class="comment">%   FRmin2 (steprate?) = (# spikes)/T</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%   From first spike of first suprathreshold step: AP morphology</span>
0064 <span class="comment">%   Vthresh = V( crossing(dV/dt,20mV/ms) ) %10mV/ms) )</span>
0065 <span class="comment">%   AP_amp = (Vpeak-Vthresh)</span>
0066 <span class="comment">%   AP_taur = (time to rise from 10% to 90% between Vthresh and Vpeak)</span>
0067 <span class="comment">%   AP_taud = (time to decay from 10% to 90% between Vpeak and Vthresh)</span>
0068 <span class="comment">%   AP_dur (spikewidth) = (time between rising and falling (Vthresh+APamp/2) = (Vthresh+Vpeak)/2)</span>
0069 <span class="comment">%   AHP_amp = (Vbaseline-Vmin) where Vmin taken during repolarizing phase</span>
0070 <span class="comment">%   AHP_dur (AHP duration, half-width) = time between half-peak amplitude of AHP</span>
0071 <span class="comment">%                                     = (time between falling and rising (Vbaseline+AHPamp/2))</span>
0072 <span class="comment">%   AHP_time2trough = (time between falling Vbaseline and AHPamp)</span>
0073 <span class="comment">%   ADPamp? ADPdur?</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%   From suprathreshold step 20pA above first step with at least two spikes:</span>
0076 <span class="comment">%   CV(ISIs over 30-100% step)</span>
0077 <span class="comment">%</span>
0078 <span class="comment">%   From last suprathreshold T sec step (or step at amp=max (eg, 140pA)):</span>
0079 <span class="comment">%   FR_max (steprate?): (# spikes)/T</span>
0080 <span class="comment">%   min_ISI_median</span>
0081 <span class="comment">%   max_ISI</span>
0082 <span class="comment">%   AR24 = ISI(2)/ISI(4)</span>
0083 <span class="comment">%</span>
0084 <span class="comment">% References for methods used:</span>
0085 <span class="comment">%   [1] Steffensen, Scott C., et al. &quot;Electrophysiological characterization of</span>
0086 <span class="comment">%     GABAergic neurons in the ventral tegmental area.&quot; The Journal of</span>
0087 <span class="comment">%     neuroscience 18.19 (1998): 8003-8015.</span>
0088 <span class="comment">%   [2] Van Aerde, Karlijn I., et al. &quot;Flexible spike timing of layer 5 neurons</span>
0089 <span class="comment">%     during dynamic beta oscillation shifts in rat prefrontal cortex.&quot; The</span>
0090 <span class="comment">%     Journal of physiology 587.21 (2009): 5177-5196.</span>
0091 <span class="comment">%   [3] Connors, BW, MJ Gutnick, DA Prince. &quot;Electrophysiological properties of</span>
0092 <span class="comment">%     neocortical neurons in vitro.&quot; Journal of Neurophysiology 48.6 (1982):</span>
0093 <span class="comment">%     1302-1320.</span>
0094 <span class="comment">%   [4] Povysheva, Nadezhda V., et al. &quot;Parvalbumin-positive basket</span>
0095 <span class="comment">%     interneurons in monkey and rat prefrontal cortex.&quot; Journal of</span>
0096 <span class="comment">%     neurophysiology 100.4 (2008): 2348-2360.</span>
0097 <span class="comment">%   [5] Gonz?lez-Burgos, Guillermo, et al. &quot;Functional properties of fast</span>
0098 <span class="comment">%     spiking interneurons and their synaptic connections with pyramidal cells in</span>
0099 <span class="comment">%     primate dorsolateral prefrontal cortex.&quot; Journal of Neurophysiology 93.2</span>
0100 <span class="comment">%     (2005): 942-953.</span>
0101 <span class="comment">%   [6] Gorelova, Natalia, Jeremy K. Seamans, and Charles R. Yang. &quot;Mechanisms</span>
0102 <span class="comment">%     of dopamine activation of fast-spiking interneurons that exert inhibition</span>
0103 <span class="comment">%     in rat prefrontal cortex.&quot; Journal of neurophysiology 88.6 (2002):</span>
0104 <span class="comment">%     3150-3166.</span>
0105 <span class="comment">%</span>
0106 <span class="comment">% Example:</span>
0107 <span class="comment">%   data = dsProbeCellProperties(model)</span>
0108 <span class="comment">%   stats = dsCalcCellProperties(data)</span>
0109 <span class="comment">%</span>
0110 <span class="comment">% See also: dsProbeCellProperties</span>
0111 <span class="comment">%</span>
0112 <span class="comment">% Author: Jason Sherfey, PhD &lt;jssherfey@gmail.com&gt;</span>
0113 <span class="comment">% Copyright (C) 2016 Jason Sherfey, Boston University, USA</span>
0114 
0115 <span class="comment">% Check inputs</span>
0116 options=<a href="dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>(varargin,{<span class="keyword">...</span>
0117   <span class="string">'spike_threshold'</span>,1e-5,[],<span class="keyword">...</span>
0118   <span class="string">'skip_time'</span>,10,[],<span class="keyword">...</span><span class="comment"> % time [ms] to exclude from detection</span>
0119   <span class="string">'plot_flag'</span>,0,{0,1},<span class="keyword">...</span>
0120   <span class="string">'equivalent_cells_flag'</span>,0,[],<span class="keyword">...</span><span class="comment"> % if true, only process one cell per pop</span>
0121   <span class="string">'auto_gen_test_data_flag'</span>,0,{0,1},<span class="keyword">...</span>
0122   },false);
0123 
0124 <span class="comment">%% auto_gen_test_data_flag argin</span>
0125 <span class="keyword">if</span> options.auto_gen_test_data_flag
0126   varargs = varargin;
0127   varargs{find(strcmp(varargs, <span class="string">'auto_gen_test_data_flag'</span>))+1} = 0;
0128   varargs(end+1:end+2) = {<span class="string">'unit_test_flag'</span>,1};
0129   argin = [{data}, varargs]; <span class="comment">% specific to this function</span>
0130 <span class="keyword">end</span>
0131 
0132 data=<a href="dsCheckData.html" class="code" title="function data = dsCheckData(data, varargin)">dsCheckData</a>(data, varargin{:});
0133 model=data(1).model;
0134 time=data(1).time;
0135 num_times=length(time);
0136 
0137 <span class="comment">% extract experiment parameters</span>
0138 experiment_options=data(1).simulator_options.experiment_options;
0139 
0140 <span class="comment">% stimulus timing</span>
0141 onset=experiment_options.onset; <span class="comment">%model.parameters.([pop_names{1} '_onset']);</span>
0142 offset=experiment_options.offset; <span class="comment">%model.parameters.([pop_names{1} '_offset']);</span>
0143 tsel=find(time&gt;=onset&amp;time&lt;=offset);
0144 
0145 <span class="comment">% assume exactly one simulation per amplitude</span>
0146 <span class="comment">% if num_steps ~= length(data)</span>
0147 <span class="comment">%   error('there can only be one simulation per stimulus amplitude');</span>
0148 <span class="comment">% end</span>
0149 
0150 <span class="comment">% extract population info</span>
0151 pop_names={model.specification.populations.name};
0152 num_pops=length(pop_names);
0153 
0154 <span class="comment">% set num_cells=1 if equivalent_cells_flag</span>
0155 <span class="keyword">if</span> experiment_options.equivalent_cells_flag==1
0156   pop_sizes=ones(1,num_pops);
0157 <span class="keyword">else</span>
0158   pop_sizes=[model.specification.populations.size];
0159 <span class="keyword">end</span>
0160 
0161 <span class="comment">% sort data by [data.(pop1)_TONIC] and sort amplitudes</span>
0162 [amplitudes,I]=sort([data.([pop_names{1} <span class="string">'_TONIC'</span>])]);
0163 data=data(I);
0164 num_steps=length(amplitudes);
0165 
0166 <span class="comment">% get list of variables to analyze</span>
0167 [vars,vars_pop]=<a href="dsSelectVariables.html" class="code" title="function [variables,pop_names] = dsSelectVariables(labels,var_strings, varargin)">dsSelectVariables</a>(data(1).labels, varargin{:});
0168 
0169 <span class="comment">% assume only one variable per population</span>
0170 <span class="keyword">if</span> length(unique(vars_pop))&gt;num_pops
0171   [vars;vars_pop]
0172   error(<span class="string">'there can only be one variable per population.'</span>);
0173 <span class="keyword">end</span>
0174 
0175 <span class="comment">% collect pulses</span>
0176 <span class="comment">% input=zeros(num_times,num_steps);</span>
0177 <span class="comment">% for s=1:num_steps</span>
0178 <span class="comment">%   input(:,s)=data(s).([pop_names{1} '_pulse'])(:,1);</span>
0179 <span class="comment">% end</span>
0180 
0181 CF = (1e-6)/(1e-8);   <span class="comment">% pA/um^2 =&gt; uA/cm^2. note: 1um2=1e-8cm2, 1pA=1e-6uA</span>
0182 amplitudes_pA=amplitudes*experiment_options.membrane_area/CF;
0183 
0184 <span class="comment">% initialize stats structure</span>
0185 stats.experiment_options=experiment_options;
0186 stats.amplitudes=amplitudes;
0187 stats.time=time;
0188 stats.cell_results={}; <span class="comment">% list of field names storing results for each cell</span>
0189 stats.pop_results={};  <span class="comment">% list of field names storing results for each population</span>
0190 
0191 <span class="comment">% analyze each population</span>
0192 <span class="keyword">for</span> p=1:num_pops
0193   <span class="comment">% extract info for this population</span>
0194   pop=pop_names{p};
0195   this_var=vars{strcmp(vars_pop,pop)};
0196   num_cells=pop_sizes(p);
0197   <span class="comment">% preallocate intrinsic property measures (each will be an average over repetitions)</span>
0198   stats.(pop).RMP     =nan(1,num_cells);
0199   stats.(pop).V_thresh=nan(1,num_cells);
0200   stats.(pop).R_in    =nan(1,num_cells);
0201   stats.(pop).tau_m   =nan(1,num_cells);
0202   stats.(pop).FI_slope=nan(1,num_cells);
0203   stats.(pop).CV      =nan(1,num_cells);
0204   stats.(pop).ISI_median=nan(1,num_cells);
0205   stats.(pop).ISI_step_median=nan(1,num_cells);
0206   stats.(pop).min_ISI_median=nan(1,num_cells);
0207   stats.(pop).max_ISI=nan(1,num_cells);
0208   stats.(pop).AR13    =nan(1,num_cells);
0209   stats.(pop).AR23    =nan(1,num_cells);
0210   stats.(pop).AR24    =nan(1,num_cells);
0211   stats.(pop).ARif    =nan(1,num_cells);
0212   stats.(pop).AR_coeff=nan(1,num_cells);
0213   stats.(pop).ISI1    =nan(1,num_cells);
0214   stats.(pop).FR_min  =nan(1,num_cells);
0215   stats.(pop).FR_min2 =nan(1,num_cells);
0216   stats.(pop).FR_step =nan(1,num_cells);
0217   stats.(pop).FR_max  =nan(1,num_cells);
0218   stats.(pop).AP_amp  =nan(1,num_cells);
0219   stats.(pop).AP_dur  =nan(1,num_cells);
0220   stats.(pop).AP_taur =nan(1,num_cells);
0221   stats.(pop).AP_taud =nan(1,num_cells);
0222   stats.(pop).Ih_relsag  =nan(1,num_cells);
0223   stats.(pop).Ih_abssag=nan(1,num_cells);
0224   stats.(pop).hump    =nan(1,num_cells);
0225   stats.(pop).AHP_amp =nan(1,num_cells);
0226   stats.(pop).AHP_dur =nan(1,num_cells);
0227   stats.(pop).AHP_time2trough=nan(1,num_cells);
0228   <span class="comment">% determine whether cells are spiking or not on each step</span>
0229   spike_times=cell(num_steps,num_cells);
0230   <span class="keyword">for</span> c=1:num_cells
0231     <span class="keyword">for</span> s=1:num_steps
0232       <span class="comment">% select trace for this (pop,cell,step)</span>
0233       X=data(s).(this_var)(tsel,c);
0234       <span class="comment">% get spikes in this cell during step</span>
0235       spike_inds=1+find((X(2:end)&gt;=options.spike_threshold &amp; X(1:end-1)&lt;options.spike_threshold));
0236       spike_times{s,c}=time(tsel(spike_inds));
0237     <span class="keyword">end</span>
0238     num_spikes=cellfun(@numel,spike_times(:,c));
0239     is_spiking=(num_spikes&gt;0); <span class="comment">% {0:subthreshold,1:suprathreshold}</span>
0240 
0241     <span class="comment">% Calculate measures of cell intrinsic properties</span>
0242     <span class="comment">% 1) calculate RMP (avg over repetitions) From steps with amp=0</span>
0243     <span class="comment">% RMP = (avg over 50-100% step | Iinj=0)</span>
0244     step_sel=find(amplitudes==0); <span class="comment">% select all simulations with amp=0</span>
0245     time_sel=tsel(round(.5*numel(tsel)):end); <span class="comment">% select 50-100% of step</span>
0246     rmp=0;
0247     <span class="keyword">for</span> s=1:length(step_sel)
0248       rmp=rmp+nanmean(data(step_sel(s)).(this_var)(time_sel,c));
0249     <span class="keyword">end</span>
0250     stats.(pop).RMP(c)=rmp/length(step_sel);
0251 
0252     <span class="comment">% 2) calculate Ih_relsag (avg over repetitions) From largest hyperpolarizing step</span>
0253     <span class="comment">% Ih Sag = (Vend-Vmin)/|RMP-Vend|</span>
0254     <span class="comment">%     where Vmin=(min voltage during T sec hyperpolarizing step)</span>
0255     <span class="comment">%           Vend=(V at end of hyperpolarizing step)</span>
0256     step_sel=find(amplitudes==min(amplitudes) &amp; amplitudes&lt;0);
0257     sag=0; abssag=0;
0258     <span class="keyword">for</span> s=1:length(step_sel)
0259       V=data(step_sel(s)).(this_var)(:,c);
0260       bl=V(tsel(1)-1);   <span class="comment">% baseline value is point immediately before stim onset</span>
0261       Vend=V(tsel(end)); <span class="comment">% final point</span>
0262       Vmin=min(V(tsel)); <span class="comment">% minimum point of sag</span>
0263       sag=sag+((Vend-Vmin)/abs(bl-Vend));
0264       abssag=abssag+(Vend-Vmin);
0265       <span class="comment">%figure; plot(time,V); line(xlim,[Vmin Vmin]); line(xlim,[Vend Vend]); line(xlim,[bl bl]);</span>
0266     <span class="keyword">end</span>
0267     stats.(pop).Ih_relsag(c)=sag/length(step_sel);
0268     stats.(pop).Ih_abssag(c)=abssag/length(step_sel);
0269 
0270     <span class="comment">% 3) calculate hump (avg over repetitions) From last subthreshold step</span>
0271     <span class="comment">% Hump = (Vmax-Vend)/|RMP-Vend|</span>
0272     <span class="comment">%     where Vmax=(max voltage during depolarizing step preceding spike)</span>
0273     <span class="comment">%           Vend=(V at end of step)</span>
0274     step_sel=max(1,find(num_spikes&gt;0,1,<span class="string">'first'</span>)-1);
0275     <span class="keyword">if</span> ~isempty(step_sel)
0276       V=data(step_sel).(this_var)(:,c);
0277       bl=V(tsel(1)-1);   <span class="comment">% baseline value is point immediately before stim onset</span>
0278       Vend=V(tsel(end)); <span class="comment">% final point</span>
0279       Vmax=max(V(tsel)); <span class="comment">% maximum point of hump</span>
0280       stats.(pop).hump(c)=((Vmax-Vend)/abs(bl-Vend));
0281     <span class="keyword">end</span>
0282 
0283     <span class="comment">% 4) calculate (R_in,tau_m) (from avg over repetitions) Across hyperpolarizing subthreshold steps</span>
0284     <span class="comment">% Rin = Input resistence (I/V slope) [4]</span>
0285     <span class="comment">% taum = Membrane time constant: time for voltage relaxation to (1/e)Vmax</span>
0286     <span class="comment">%   where Vmax=max deflection from baseline on hyperpolarizing steps</span>
0287     <span class="comment">%   note: avg taum's over small drives that keep active currents silent (eg, 5-15pA)</span>
0288     step_sel=find(num_spikes==0 &amp; amplitudes'&lt;0);
0289     amps=amplitudes(step_sel);
0290     uamps=unique(amps);
0291     nuamps=length(uamps);
0292     Veq=nan(1,nuamps);
0293     taum=nan(1,nuamps);
0294     time_sel=tsel(round(.5*numel(tsel)):end); <span class="comment">% select 50-100% of step</span>
0295     <span class="comment">% loop over unique amplitudes</span>
0296     <span class="keyword">for</span> a=1:nuamps
0297       asel=find(amps==uamps(a)); <span class="comment">% indices to subthreshold amps with this value</span>
0298       <span class="comment">% loop over repetitions of the same amplitude</span>
0299       veq=0; tau=0;
0300       <span class="keyword">for</span> l=1:length(asel)
0301         step=step_sel(asel(l)); <span class="comment">% index to this simulation</span>
0302         X=data(step).(this_var)(:,c);
0303         <span class="comment">% store mean voltage over 50-100% step</span>
0304         veq=veq+nanmean(X(time_sel));
0305         <span class="comment">% calc membrane time constant based on this step (time to Vmax(1/e))</span>
0306         bl=X(tsel(1)-1); <span class="comment">% baseline value is point immediately before stim onset</span>
0307         V=X-bl; <span class="comment">% shift baseline to V=0</span>
0308         <span class="keyword">if</span> uamps(a)&lt;0
0309           V=abs(V); <span class="comment">% invert values so that deflection is positive</span>
0310         <span class="keyword">end</span>
0311         Vmax=V(tsel(end)); <span class="comment">% max is final point during stim period before offset</span>
0312         Vthresh=Vmax*(1/exp(1)); <span class="comment">% voltage at 1/e</span>
0313         Vdecay=V(tsel(end):end); <span class="comment">% voltage decay after stim offset</span>
0314         tthresh=time(tsel(end)+find(Vdecay&lt;Vthresh,1,<span class="string">'first'</span>)-1); <span class="comment">% time at which decay crosses 1/e</span>
0315         tau=tau+(tthresh-offset); <span class="comment">% time to drop to 1/e after stim offset</span>
0316       <span class="keyword">end</span>
0317       Veq(a)=veq/length(asel);
0318       <span class="keyword">if</span> any(tau)
0319         taum(a)=tau/length(asel);
0320       <span class="keyword">end</span>
0321     <span class="keyword">end</span>
0322     <span class="comment">% calc R_in (from slope of amp/Veq)</span>
0323     <span class="keyword">if</span> any(~isnan(Veq))
0324       sel=~isnan(Veq);
0325       P=polyfit(uamps(sel),Veq(sel),1);
0326       stats.(pop).R_in(c)=P(1);
0327     <span class="keyword">end</span>
0328     <span class="keyword">if</span> any(~isnan(taum))
0329       stats.(pop).tau_m(c)=taum(find(~isnan(taum),1,<span class="string">'first'</span>));<span class="comment">%1);%nanmedian(taum);</span>
0330     <span class="keyword">end</span>
0331 
0332     <span class="comment">% 5) calculate FI_slope (from avg over repetitions) Across suprathreshold steps with at least two spikes</span>
0333     <span class="comment">% FI slope: slope of f/I curve (firing freq vs injected current 0-140pA) (see [2])</span>
0334 <span class="comment">%     step_sel=find(num_spikes&gt;1 &amp; amplitudes'&gt;0);</span>
0335 <span class="comment">%     amps=amplitudes(step_sel);</span>
0336 <span class="comment">%     uamps=unique(amps);</span>
0337 <span class="comment">%     nuamps=length(uamps);</span>
0338 <span class="comment">%     FR=nan(1,nuamps);</span>
0339 <span class="comment">%     % loop over unique amplitudes</span>
0340 <span class="comment">%     for a=1:nuamps</span>
0341 <span class="comment">%       asel=find(amps==uamps(a)); % indices to subthreshold amps with this value</span>
0342 <span class="comment">%       % loop over repetitions of the same amplitude</span>
0343 <span class="comment">%       fr=0;</span>
0344 <span class="comment">%       for l=1:length(asel)</span>
0345 <span class="comment">%         step=step_sel(asel(l)); % index to this simulation</span>
0346 <span class="comment">%         fr=fr+(num_spikes(step)/((offset-onset)/1000));</span>
0347 <span class="comment">%       end</span>
0348 <span class="comment">%       FR(a)=fr/length(asel); % [Hz]</span>
0349 <span class="comment">%     end</span>
0350 <span class="comment">%     % calc FI_slope</span>
0351 <span class="comment">%     if any(~isnan(FR))</span>
0352 <span class="comment">%       sel=~isnan(FR);</span>
0353 <span class="comment">%       amps_nA=uamps(sel)*experiment_options.membrane_area/CF/1000;</span>
0354 <span class="comment">%       P=polyfit(amps_nA,FR(sel),1);</span>
0355 <span class="comment">%       stats.(pop).FI_slope(c)=P(1); % [Hz/nA]</span>
0356 <span class="comment">%       figure; plot(amps_nA,FR(sel)); xlabel('amps [nA]'); ylabel('FR [Hz]');</span>
0357 <span class="comment">%       [num_spikes(step_sel) amplitudes(step_sel)']</span>
0358 <span class="comment">%     end</span>
0359 
0360     <span class="comment">% 6) calculate ARs (avg over repetitions) &amp; AR_coefficient Across</span>
0361     <span class="comment">%    suprathreshold steps &gt;=60pA above first step with at least two spikes</span>
0362     <span class="comment">% AR coefficient: (slope of AR/I) where per step AR=ISI(1)/ISI(end)</span>
0363     thresh_step=find(num_spikes&gt;1,1,<span class="string">'first'</span>);
0364     <span class="keyword">if</span> any(thresh_step)
0365       step_sel=find(amplitudes_pA&gt;(amplitudes_pA(thresh_step)+60));
0366     <span class="keyword">else</span>
0367       step_sel=[];
0368     <span class="keyword">end</span>
0369     <span class="keyword">if</span> any(step_sel)
0370       amps=amplitudes(step_sel);
0371       uamps=unique(amps);
0372       nuamps=length(uamps);
0373       AR=nan(1,nuamps);
0374       FR=nan(1,nuamps);
0375       <span class="comment">% loop over unique amplitudes</span>
0376       <span class="keyword">for</span> a=1:nuamps
0377         asel=find(amps==uamps(a)); <span class="comment">% indices to subthreshold amps with this value</span>
0378         <span class="comment">% loop over repetitions of the same amplitude</span>
0379         ar=0; denom=0;
0380         fr=0;
0381         <span class="keyword">for</span> l=1:length(asel)
0382           step=step_sel(asel(l)); <span class="comment">% index to this simulation</span>
0383           fr=fr+(num_spikes(step)/((offset-onset)/1000));
0384           ISI=diff(spike_times{step,c});
0385           <span class="keyword">if</span> length(ISI)&gt;1
0386             denom=denom+1;
0387   <span class="comment">%           if length(ISI)&gt;2</span>
0388   <span class="comment">%             ar=ar+(ISI(2)/ISI(end));</span>
0389   <span class="comment">%           else</span>
0390               ar=ar+(ISI(1)/ISI(end));
0391   <span class="comment">%           end</span>
0392           <span class="keyword">end</span>
0393         <span class="keyword">end</span>
0394         AR(a)=ar/denom;
0395         FR(a)=fr/length(asel); <span class="comment">% [Hz]</span>
0396       <span class="keyword">end</span>
0397       <span class="comment">% calc ISI_median at 60pA above threshold</span>
0398       spikes=spike_times{step_sel(1),c};
0399       ISI=diff(spikes);
0400       stats.(pop).ISI_step_median(c)=median(ISI);
0401       <span class="comment">% store FR at 60pA above threshold</span>
0402       stats.(pop).FR_step(c)=FR(1); <span class="comment">% FR at 60pA above threshold</span>
0403       <span class="keyword">if</span> ~strcmp(reportUI,<span class="string">'matlab'</span>) &amp;&amp; exist(<span class="string">'nanmax'</span>) ~= 2 <span class="comment">% 'nanmax is not in Octave's path</span>
0404         <span class="keyword">try</span>
0405           pkg load statistics; <span class="comment">% trying to load octave forge 'statistics' package before using nanmax function</span>
0406         <span class="keyword">catch</span>
0407           error(<span class="string">'nanmax function is needed, please install the statistics package from Octave Forge'</span>);
0408         <span class="keyword">end</span>
0409       <span class="keyword">end</span>
0410       stats.(pop).ARif(c)=nanmax(AR); <span class="comment">% nanmean, nanmedian</span>
0411       <span class="comment">% calculate AR_coefficient</span>
0412       <span class="keyword">if</span> any(~isnan(AR))
0413         sel=~isnan(AR);
0414         P=polyfit(uamps(sel),AR(sel),1);
0415         stats.(pop).AR_coeff(c)=P(1);
0416         <span class="comment">%figure; plot(uamps(sel),AR(sel)); xlabel('amps'); ylabel('AR');</span>
0417       <span class="keyword">end</span>
0418       <span class="comment">% calc FI_slope</span>
0419       <span class="keyword">if</span> any(~isnan(FR))
0420         sel=~isnan(FR);
0421         amps_nA=uamps(sel)*experiment_options.membrane_area/CF/1000;
0422         P=polyfit(amps_nA,FR(sel),1);
0423         stats.(pop).FI_slope(c)=P(1); <span class="comment">% [Hz/nA]</span>
0424         <span class="comment">%figure; plot(amps_nA,FR(sel)); xlabel('amps [nA]'); ylabel('FR [Hz]');</span>
0425         <span class="comment">%[num_spikes(step_sel) amplitudes(step_sel)']</span>
0426       <span class="keyword">end</span>
0427     <span class="keyword">end</span>
0428 
0429     <span class="comment">% 7) calculate FR_min From first suprathreshold T sec step</span>
0430     <span class="comment">% FRmin (threshrate) = (# spikes)/T</span>
0431     step_sel=find(num_spikes&gt;0,1,<span class="string">'first'</span>);
0432     <span class="keyword">if</span> any(step_sel)
0433       stats.(pop).FR_min(c)=num_spikes(step_sel)/((offset-onset)/1000);
0434     <span class="keyword">end</span>
0435 
0436     <span class="comment">% 8) calculate FR_min2 From first suprathreshold T sec step with at least two spikes</span>
0437     <span class="comment">% FRmin2 (steprate?) = (# spikes)/T</span>
0438     step_sel=find(num_spikes&gt;1,1,<span class="string">'first'</span>);
0439     <span class="keyword">if</span> any(step_sel)
0440       stats.(pop).FR_min2(c)=num_spikes(step_sel)/((offset-onset)/1000);
0441       stats.(pop).ISI1(c)=(spike_times{step_sel,c}(2)-spike_times{step_sel,c}(1));
0442     <span class="keyword">end</span>
0443 
0444     <span class="comment">% 9) calculate CV (avg over repetitions) From suprathreshold step 20pA above first step with at least two spikes</span>
0445     <span class="comment">% CV(ISIs over 30-100% step)</span>
0446     tmin=time(tsel(round(.3*numel(tsel)))); <span class="comment">% time at 30% through step</span>
0447     thresh_step=find(num_spikes&gt;1,1,<span class="string">'first'</span>);
0448     <span class="keyword">if</span> any(thresh_step)
0449       step_sel=find(amplitudes_pA&gt;(amplitudes_pA(thresh_step)+20));
0450     <span class="keyword">else</span>
0451       step_sel=[];
0452     <span class="keyword">end</span>
0453     <span class="keyword">if</span> any(step_sel)
0454       spikes=spike_times{step_sel,c};
0455       spikes=spikes(spikes&gt;tmin);
0456       ISI=diff(spikes);
0457       <span class="keyword">if</span> any(ISI)
0458         stats.(pop).CV(c)=std(ISI)/mean(ISI);
0459       <span class="keyword">end</span>
0460       spikes=spike_times{step_sel,c};
0461       ISI=diff(spikes);
0462       stats.(pop).ISI_median(c)=median(ISI);
0463       stats.(pop).max_ISI(c)=max(ISI);
0464     <span class="keyword">end</span>
0465 
0466     <span class="comment">% 10) calculate (FRmax,AR24) From last suprathreshold T sec step</span>
0467     <span class="comment">% FRmax (steprate?): (# spikes)/T</span>
0468     <span class="comment">% AR24 = ISI(2)/ISI(4)</span>
0469     step_sel=find(num_spikes&gt;4,1,<span class="string">'last'</span>);
0470     <span class="keyword">if</span> any(step_sel)
0471       spikes=spike_times{step_sel,c};
0472       ISIs=diff(spikes)/1000;
0473       finst=1./(ISIs);
0474       stats.(pop).AR24(c)=finst(2)/finst(4);
0475 <span class="comment">%       stats.(pop).AR23(c)=ISIs(2)/ISIs(3);</span>
0476 <span class="comment">%       stats.(pop).AR13(c)=ISIs(1)/ISIs(3);</span>
0477       stats.(pop).FR_max(c)=num_spikes(step_sel)/((offset-onset)/1000);
0478       stats.(pop).min_ISI_median(c)=median(diff(spikes));
0479     <span class="keyword">end</span>
0480     step_sel=find(num_spikes&gt;3,1,<span class="string">'first'</span>);
0481     <span class="keyword">if</span> any(step_sel)
0482       spikes=spike_times{step_sel,c};
0483       ISIs=diff(spikes)/1000;
0484       stats.(pop).AR23(c)=ISIs(2)/ISIs(3);
0485       stats.(pop).AR13(c)=ISIs(1)/ISIs(3);
0486     <span class="keyword">end</span>
0487 
0488     <span class="comment">% 11) calculate AP morphology From first spike of first suprathreshold step with at least two spikes</span>
0489     step_sel=find(num_spikes&gt;0,1,<span class="string">'first'</span>);
0490     <span class="keyword">if</span> any(step_sel)
0491       X=double(data(step_sel).(this_var)(:,c));
0492       spks=spike_times{step_sel,c};
0493       spk_1=spks(1); <span class="comment">% time of first spike</span>
0494       <span class="keyword">if</span> length(spks)&gt;1
0495         spk_2=spks(2); <span class="comment">% time of second spike</span>
0496       <span class="keyword">else</span>
0497         spk_2=inf;
0498       <span class="keyword">end</span>
0499       pad=100; <span class="comment">% ms, time before and after spike detection (make longer than expected AHP)</span>
0500       spk_beg=max(spk_1-pad,onset);
0501       spk_end=min(spk_1+pad,spk_2); <span class="comment">% make sure spike interval excludes the following spike</span>
0502       spk_beg_i=nearest(time,spk_beg);
0503       spk_end_i=nearest(time,spk_end);
0504       spk_inds=spk_beg_i:spk_end_i; <span class="comment">% indices for this spike</span>
0505       t=time(spk_inds); <span class="comment">% times around spike</span>
0506       V=X(spk_inds);  <span class="comment">% trace around spike</span>
0507       <span class="comment">% Vthresh = V( crossing(dV/dt,10mV/ms) )</span>
0508       dVdt=diff(V)/(t(2)-t(1));
0509       dVdt=smooth(dVdt,round(1/(t(2)-t(1)))); <span class="comment">% 1ms smoothing</span>
0510       thresh_ind=find(dVdt&gt;20,1,<span class="string">'first'</span>);<span class="comment">%crossing(dVdt,t,10);</span>
0511       Vthresh=V(thresh_ind(1));
0512       <span class="comment">% APamp = (Vpeak-Vthresh)</span>
0513       [pk,loc]=findpeaks(V,<span class="string">'NPeaks'</span>,1);
0514       Vpeak=V(loc);<span class="comment">%max(V);</span>
0515       Vpeak_i=loc;<span class="comment">%find(V==Vpeak,1,'first');</span>
0516       APamp=Vpeak-Vthresh;
0517       V10=Vthresh+.1*APamp; <span class="comment">% 10% from Vthresh to Vpeak</span>
0518       V90=Vthresh+.9*APamp; <span class="comment">% 90% from Vthresh to Vpeak</span>
0519       <span class="comment">% depolarizing rising phase</span>
0520       V10_i_r=1+find(V(2:end)&gt;=V10 &amp; V(1:end-1)&lt;V10); <span class="comment">% first</span>
0521       V90_i_r=1+find(V(2:end)&gt;=V90 &amp; V(1:end-1)&lt;V90); <span class="comment">% second</span>
0522       <span class="comment">% APtaur = (time to rise from 10% to 90% between Vthresh and Vpeak)</span>
0523       <span class="keyword">if</span> any(V10_i_r) &amp;&amp; any(V90_i_r)
0524         APtaur=t(V90_i_r(1))-t(V10_i_r(1));
0525       <span class="keyword">else</span>
0526         APtaur=nan;
0527       <span class="keyword">end</span>
0528       <span class="comment">% repolarizing falling phase</span>
0529       V10_i_d=1+find(V(1:end-1)&gt;=V10 &amp; V(2:end)&lt;V10); <span class="comment">% second</span>
0530       V90_i_d=1+find(V(1:end-1)&gt;=V90 &amp; V(2:end)&lt;V90); <span class="comment">% first</span>
0531       <span class="keyword">if</span> numel(V10_i_d)&gt;1 &amp;&amp; numel(V10_i_d)&gt;1
0532         V10_i_d=V10_i_d(end);
0533         V90_i_d=V90_i_d(end);
0534       <span class="keyword">end</span>
0535       <span class="keyword">if</span> isempty(V10_i_d)
0536         <span class="comment">% set to the minimum point of the repolarizing phase</span>
0537         V10=min(V(Vpeak_i:end));
0538         V10_i_d=find(V(Vpeak_i:end)==V10)+Vpeak_i-1;
0539       <span class="keyword">end</span>
0540       <span class="comment">% APtaud = (time to decay from 10% to 90% between Vpeak and Vthresh)</span>
0541       <span class="keyword">if</span> any(V10_i_d) &amp;&amp; any(V90_i_d)
0542         APtaud=t(V10_i_d(1))-t(V90_i_d(1));
0543       <span class="keyword">else</span>
0544         APtaud=nan;
0545       <span class="keyword">end</span>
0546       <span class="comment">% APdur (spikewidth) = (time between rising and falling (Vthresh+APamp/2) = (Vthresh+Vpeak)/2)</span>
0547       V50=Vthresh+.5*APamp;
0548       V50_i_r=1+find(V(2:end)&gt;=V50 &amp; V(1:end-1)&lt;V50);
0549       V50_i_d=1+find(V(1:end-1)&gt;=V50 &amp; V(2:end)&lt;V50);
0550       <span class="keyword">if</span> any(V50_i_d) &amp;&amp; any(V50_i_r)
0551         APdur=t(V50_i_d(1))-t(V50_i_r(1));
0552       <span class="keyword">else</span>
0553         APdur=nan;
0554       <span class="keyword">end</span>
0555       <span class="comment">% AHPamp = (Vbaseline-Vmin) where Vmin taken during repolarizing phase</span>
0556       <span class="comment">%bl=X(spk_inds(1)-1); % baseline voltage</span>
0557       bl=mean(V);
0558       <span class="comment">% find trough: look for first peak in the inverted post-spike trace</span>
0559       [pk,loc]=findpeaks(-smooth(V(V10_i_d:end),100),<span class="string">'NPeaks'</span>,1);
0560       ahp_trough_i=V10_i_d+loc-1;
0561       Vmin=V(ahp_trough_i);
0562       <span class="comment">%Vmin=-findpeaks(-V(V10_i_d:end),'NPeaks',1);</span>
0563       <span class="comment">%Vmin=max(findpeaks(-V(V10_i_d:end)));</span>
0564       <span class="comment">%Vmin=min(V(V10_i_d:end));</span>
0565       AHPamp=abs(bl-Vmin);
0566       <span class="comment">% AHPdur (AHP duration, half-width) = time between half-peak amplitude of AHP</span>
0567       <span class="comment">%                                   = (time between falling and rising (Vbaseline+AHPamp/2))</span>
0568       ahp_V50=bl+.5*AHPamp;
0569       ahp_V50_i_d=1+find(V(1:end-1)&gt;=ahp_V50 &amp; V(2:end)&lt;ahp_V50); <span class="comment">% first</span>
0570       ahp_V50_i_d(ahp_V50_i_d&lt;V10_i_d)=[]; <span class="comment">% remove crossings before repolarization</span>
0571       ahp_V50_i_r=1+find(V(2:end)&gt;=ahp_V50 &amp; V(1:end-1)&lt;ahp_V50); <span class="comment">% second</span>
0572       <span class="keyword">if</span> any(ahp_V50_i_d)
0573         ahp_V50_i_r(ahp_V50_i_r&lt;ahp_V50_i_d(1))=[]; <span class="comment">% remove crossings before start of AHP</span>
0574       <span class="keyword">end</span>
0575       <span class="keyword">if</span> any(ahp_V50_i_r) &amp;&amp; any(ahp_V50_i_d)
0576         AHPdur=t(ahp_V50_i_r(1))-t(ahp_V50_i_d(1));
0577       <span class="keyword">else</span>
0578         AHPdur=nan;
0579       <span class="keyword">end</span>
0580       <span class="comment">% AHP_time2trough = (time between falling Vbaseline and Vmin)</span>
0581 <span class="comment">%       ahp_bl_i_d=1+find(V(1:end-1)&gt;=ahp_V50 &amp; V(2:end)&lt;ahp_V50); % first</span>
0582 <span class="comment">%       ahp_bl_i_d(ahp_bl_i_d&lt;V10_i_d)=[]; % remove crossings before repolarization</span>
0583       <span class="comment">%ahp_trough_i=find(V==Vmin);</span>
0584       <span class="comment">%ahp_trough_i(ahp_trough_i&lt;V10_i_d)=[]; % remove crossings before start</span>
0585       <span class="keyword">if</span> any(V10_i_d)
0586         AHPtime2trough=t(ahp_trough_i(1))-t(Vpeak_i);<span class="comment">%t(V10_i_d(1));</span>
0587         <span class="keyword">if</span> options.plot_flag
0588           figure; plot(t,V);
0589           line(xlim,[V10 V10]); line(xlim,[Vmin Vmin]);
0590           line([t(ahp_trough_i(1)) t(ahp_trough_i(1))],ylim);
0591           line([t(Vpeak_i) t(Vpeak_i)],ylim,<span class="string">'color'</span>,<span class="string">'r'</span>);
0592         <span class="keyword">end</span>
0593       <span class="keyword">else</span>
0594         AHPtime2trough=nan;
0595       <span class="keyword">end</span>
0596       <span class="keyword">if</span> options.plot_flag
0597         figure; plot(t,V);
0598         line(xlim,[bl bl]);
0599         line(xlim,[Vthresh Vthresh]);
0600         line(xlim,[Vpeak Vpeak]);
0601         line(xlim,[V10 V10]);
0602         line([t(V10_i_r(1)) t(V10_i_r(1))],ylim);
0603         line([t(V10_i_d(1)) t(V10_i_d(1))],ylim);
0604         line(xlim,[V50 V50]);
0605         line(xlim,[V90 V90]);
0606         line(xlim,[ahp_V50 ahp_V50],<span class="string">'color'</span>,<span class="string">'r'</span>);
0607         line([t(ahp_V50_i_r(1)) t(ahp_V50_i_r(1))],ylim,<span class="string">'color'</span>,<span class="string">'r'</span>);
0608         line([t(ahp_V50_i_d(1)) t(ahp_V50_i_d(1))],ylim,<span class="string">'color'</span>,<span class="string">'r'</span>);
0609       <span class="keyword">end</span>
0610       stats.(pop).V_thresh(c)=Vthresh;
0611       stats.(pop).AP_amp(c)=APamp;
0612       stats.(pop).AP_taur(c)=APtaur;
0613       stats.(pop).AP_taud(c)=APtaud;
0614       stats.(pop).AP_dur(c)=APdur;
0615       stats.(pop).AHP_amp(c)=AHPamp;
0616       stats.(pop).AHP_dur(c)=AHPdur;
0617       stats.(pop).AHP_time2trough(c)=AHPtime2trough;
0618     <span class="keyword">end</span>
0619   <span class="keyword">end</span>
0620   <span class="comment">% collect data for this population across simulations</span>
0621   <span class="comment">% note: each simulation has a different input amplitude</span>
0622   X=zeros(num_steps,num_times,num_cells);
0623   <span class="keyword">for</span> s=1:num_steps
0624     X(s,:,:)=data(s).(this_var);
0625   <span class="keyword">end</span>
0626   <span class="comment">% calculate simple means</span>
0627   <span class="keyword">if</span> ~strcmp(reportUI,<span class="string">'matlab'</span>) &amp;&amp; exist(<span class="string">'nanmean'</span>) ~= 2 <span class="comment">% 'nanmean is not in Octave's path</span>
0628     <span class="keyword">try</span>
0629       pkg load statistics; <span class="comment">% trying to load octave forge 'statistics' package before using nanmean function</span>
0630     <span class="keyword">catch</span>
0631       error(<span class="string">'nanmean function is needed, please install the statistics package from Octave Forge'</span>);
0632     <span class="keyword">end</span>
0633   <span class="keyword">end</span>
0634   means=nanmean(X(:,tsel,:),2); <span class="comment">% average over select times</span>
0635   <span class="comment">% store means in stats structure</span>
0636   stats.([this_var <span class="string">'_mean_per_amp'</span>])=squeeze(means);
0637   stats.([this_var <span class="string">'_pop_mean_per_amp'</span>])=nanmean(means,3);
0638   stats.([this_var <span class="string">'_pop_mean_per_time'</span>])=nanmean(X,3);
0639 <span class="keyword">end</span>
0640 
0641 <span class="keyword">if</span> options.plot_flag
0642   v=1;
0643   figure(<span class="string">'position'</span>,[180 330 1450 530])
0644   subplot(2,2,1); <span class="comment">% V(t)</span>
0645   plot(time,stats.([vars{v} <span class="string">'_pop_mean_per_time'</span>]));
0646   xlabel(<span class="string">'time [ms]'</span>); ylabel([<span class="string">'&lt;'</span> strrep(vars{v},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">', pop&gt;'</span>]);
0647   legend(cellfun(@(x)[<span class="string">'I='</span> num2str(x)],num2cell(amplitudes),<span class="string">'uni'</span>,0));
0648   subplot(2,2,3); <span class="comment">% I(t)</span>
0649   <span class="comment">%plot(time,input); xlabel('time [ms]'); ylabel('I(t)');</span>
0650   <span class="comment">%legend(cellfun(@(x)['I=' num2str(x)],num2cell(amplitudes),'uni',0));</span>
0651   subplot(2,2,2); <span class="comment">% I/V</span>
0652   plot(amplitudes,stats.([vars{v} <span class="string">'_mean_per_amp'</span>])); hold on
0653   plot(amplitudes,stats.([vars{v} <span class="string">'_pop_mean_per_amp'</span>]),<span class="string">'k-'</span>,<span class="string">'linewidth'</span>,5);
0654   xlabel(<span class="string">'amplitude'</span>); ylabel([<span class="string">'&lt;'</span> strrep(vars{v},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">', time&gt;'</span>]);
0655 <span class="keyword">end</span>
0656 
0657 <span class="comment">%% auto_gen_test_data_flag argout</span>
0658 <span class="keyword">if</span> options.auto_gen_test_data_flag
0659   argout = {stats}; <span class="comment">% specific to this function</span>
0660 
0661   <a href="../../functions/internal/unit-test/dsUnitSaveAutoGenTestData.html" class="code" title="function dsUnitSaveAutoGenTestData(argin, argout, localFn_flag)">dsUnitSaveAutoGenTestData</a>(argin, argout);
0662 <span class="keyword">end</span>
0663 
0664 <span class="keyword">end</span>
0665 
0666 
0667 <span class="comment">% check how Tallie calculated:</span>
0668 <span class="comment">% - threshrate (mean spike rate on tonic depol just above threshold)</span>
0669 <span class="comment">% - steprate (mean spike rate on final? step depol)</span>
0670 <span class="comment">% - AHP 5-20ms (Q: mean post-spike AHP amplitude over 5-20ms after trough?)</span>
0671 <span class="comment">% - SpikeAmp (same as [4])</span>
0672 <span class="comment">% - SpikeWidth (Spike width at half height) (same as [4])</span>
0673 <span class="comment">% - RMP</span>
0674 
0675 <span class="comment">% AHPtau (AHP duration, half-width) = time between half-peak amplitude of AHP</span>
0676 
0677 <span class="comment">% From Iinj=0:</span>
0678 <span class="comment">% RMP: resting membrane potential [mV] = avg V over step 150-500ms</span>
0679 
0680 <span class="comment">% From first spike:</span>
0681 <span class="comment">% Vthresh (spike threshold) [4]: level of voltage deflection exceeding 20mV/1ms %10mV/1ms</span>
0682 <span class="comment">% Peak amplitude [4]: (peak - threshold value)</span>
0683 <span class="comment">% Spike rise time [4]: time to rise from 10% to 90% of peak amplitude</span>
0684 <span class="comment">% Spike decay time [4]: time to decay from 10% to 90% of the amplitude b/w peak and spike threshold</span>
0685 <span class="comment">% Spike duration (half-width) [1,4]: &quot;time between half-peak amplitude for the falling and rising edges&quot;</span>
0686 
0687 <span class="comment">% Other measures from [4]:</span>
0688 <span class="comment">% Sag (Ih?) = (Vmin-Vend)/|RMP-Vend|</span>
0689 <span class="comment">%     where Vmin=(min voltage during 500ms hyperpolarizing step)</span>
0690 <span class="comment">%           Vend=(V at end of hyperpolarizing step)</span>
0691 <span class="comment">% Hump = (Vmax-Vend)/|RMP-Vend|</span>
0692 <span class="comment">%     where Vmax=(max voltage during depolarizing step preceding spike)</span>
0693 <span class="comment">%           Vend=(V at end of step)</span>
0694 <span class="comment">% Adaptation ratio AR = ISI1/ISIend = f(step amplitude)</span>
0695 <span class="comment">% AR coefficient = slope of (step amp, AR) for amp &gt; 60pA above spike threshold</span>
0696 <span class="comment">% Coefficient of variation CV of ISIs was measured from spikes during</span>
0697 <span class="comment">%   150-500ms at depolarizing pulse 20pA above spike threshold</span>
0698 
0699 <span class="comment">% Measures from [2]:</span>
0700 <span class="comment">% FR: calculate from total spikes elicited by 1sec current injection at 140pA (see [2])</span>
0701 <span class="comment">% AR24: Adaptation ratio: ratio of inst. freq of 2nd and 4th spike intervals in train (see [2])</span></pre></div>
<hr><address>Generated on Tue 12-Dec-2017 11:32:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>