<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsPlot2</title>
  <meta name="keywords" content="dsPlot2">
  <meta name="description" content="% handles=dsPlot(data,'option',value)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>dsPlot2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% handles=dsPlot(data,'option',value)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [handles,xp] = dsPlot2(data,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% handles=dsPlot(data,'option',value)
 Purpose: plot data in various ways depending on what data was provided
 and what options are defined. this function is wrapped by dsPlotWaveforms,
 PlotPower, ... to provide a single function for organizing and displaying
 data.
 Inputs:
   data: DynaSim data structure (see dsCheckData)
   Accepts the following name/value pairs:
     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot
     'population' - name of population to plot (default: 'all'); accepts
                    regexp strings
     'variable' - name of variable to plot for each population (default: state variable, X or V);
                      accepts regexp strings
     'varied1' - Indices of 1st varied model parameter to plot. If the parameter
                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd
                 varied values. If the parameter is a char array, uses
                 regular expressions. Instead of 'varied1', can also use
                 the actual parameter name (e.g. 'E_Iapp')
     'varied2' - As varied 1, for 2nd varied parameter
     ....
     'variedN' - As varied 1, for 2nd varied parameter
     'num_embedded_subplots' - maximum # of waveforms to overlay per plot
     'max_num_overlaid' - maximum # of waveforms to overlay per plot
     'do_mean' - {false, true} - Turn on/off averaging across all units
                 in a population
     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}
                       If there is only one cell in a population, this forces
                       dsPlot2 to add other information to the overlay.
     'xlims' - [XMIN XMAX], x-axis limits (default: all data)
     'ylims' - [YMIN YMAX], y-axis limits (default: all data)
     'lock_axes' - {false, true}, locks abscissa and ordinate to be
                                  the same across all subplots
     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid
     'yscale' {'linear','log','log10'}, whether to plot linear or log scale
     'visible' {'on','off'}
     NOTE: analysis options available depending on plot_type
       see see dsCalcFR options for plot_type 'rastergram' or 'rates'
       see dsCalcPower options for plot_type 'power'
 Outputs:
   handles: graphic handles to figures
 
 See also: dsCalcFR, dsCalcPower, dsPlotWaveforms, dsCheckData, <a href="dsPlot.html" class="code" title="function handles = dsPlot(data,varargin)">dsPlot</a>, MDD,
           MDD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li><li><a href="../functions/internal/dsAll2mdd.html" class="code" title="function [xp,is_image] = dsAll2mdd(data,varargin)">dsAll2mdd</a>	</li><li><a href="../functions/internal/dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>	CHECKOPTIONS - organize key/value pairs in structure with default or user-supplied values according to a schema</li><li><a href="../functions/internal/dsGet_variables_from_meta.html" class="code" title="function varlabels = dsGet_variables_from_meta(xp)">dsGet_variables_from_meta</a>	</li><li><a href="../functions/internal/dsImportPlots.html" class="code" title="function [data,studyinfo] = dsImportPlots(file,varargin)">dsImportPlots</a>	IMPORTPLOTS - load info about saved images (generated by SimulateMode or dsAnalyze) alongwith corresponding varied model components.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub2" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub3" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub4" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub5" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub6" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub7" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub8" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub9" class="code">function_handles = function_handles(available_dims);</a></li><li><a href="#_sub10" class="code">function_args = function_args(available_dims);</a></li><li><a href="#_sub11" class="code">function var_out = getdefaultstatevar(xp)</a></li><li><a href="#_sub12" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a></li><li><a href="#_sub13" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a></li><li><a href="#_sub14" class="code">function ax_ind_varied = findaxis_varied(xp)</a></li><li><a href="#_sub15" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a></li><li><a href="#_sub16" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a></li><li><a href="#_sub17" class="code">function varied_names = only_varieds(xp)</a></li><li><a href="#_sub18" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a></li><li><a href="#_sub19" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a></li><li><a href="#_sub20" class="code">function leg1 = setup_legends(xp2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [handles,xp] = dsPlot2(data,varargin)</a>
0002 <span class="comment">%% handles=dsPlot(data,'option',value)</span>
0003 <span class="comment">% Purpose: plot data in various ways depending on what data was provided</span>
0004 <span class="comment">% and what options are defined. this function is wrapped by dsPlotWaveforms,</span>
0005 <span class="comment">% PlotPower, ... to provide a single function for organizing and displaying</span>
0006 <span class="comment">% data.</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   data: DynaSim data structure (see dsCheckData)</span>
0009 <span class="comment">%   Accepts the following name/value pairs:</span>
0010 <span class="comment">%     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot</span>
0011 <span class="comment">%     'population' - name of population to plot (default: 'all'); accepts</span>
0012 <span class="comment">%                    regexp strings</span>
0013 <span class="comment">%     'variable' - name of variable to plot for each population (default: state variable, X or V);</span>
0014 <span class="comment">%                      accepts regexp strings</span>
0015 <span class="comment">%     'varied1' - Indices of 1st varied model parameter to plot. If the parameter</span>
0016 <span class="comment">%                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd</span>
0017 <span class="comment">%                 varied values. If the parameter is a char array, uses</span>
0018 <span class="comment">%                 regular expressions. Instead of 'varied1', can also use</span>
0019 <span class="comment">%                 the actual parameter name (e.g. 'E_Iapp')</span>
0020 <span class="comment">%     'varied2' - As varied 1, for 2nd varied parameter</span>
0021 <span class="comment">%     ....</span>
0022 <span class="comment">%     'variedN' - As varied 1, for 2nd varied parameter</span>
0023 <span class="comment">%     'num_embedded_subplots' - maximum # of waveforms to overlay per plot</span>
0024 <span class="comment">%     'max_num_overlaid' - maximum # of waveforms to overlay per plot</span>
0025 <span class="comment">%     'do_mean' - {false, true} - Turn on/off averaging across all units</span>
0026 <span class="comment">%                 in a population</span>
0027 <span class="comment">%     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}</span>
0028 <span class="comment">%                       If there is only one cell in a population, this forces</span>
0029 <span class="comment">%                       dsPlot2 to add other information to the overlay.</span>
0030 <span class="comment">%     'xlims' - [XMIN XMAX], x-axis limits (default: all data)</span>
0031 <span class="comment">%     'ylims' - [YMIN YMAX], y-axis limits (default: all data)</span>
0032 <span class="comment">%     'lock_axes' - {false, true}, locks abscissa and ordinate to be</span>
0033 <span class="comment">%                                  the same across all subplots</span>
0034 <span class="comment">%     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid</span>
0035 <span class="comment">%     'yscale' {'linear','log','log10'}, whether to plot linear or log scale</span>
0036 <span class="comment">%     'visible' {'on','off'}</span>
0037 <span class="comment">%     NOTE: analysis options available depending on plot_type</span>
0038 <span class="comment">%       see see dsCalcFR options for plot_type 'rastergram' or 'rates'</span>
0039 <span class="comment">%       see dsCalcPower options for plot_type 'power'</span>
0040 <span class="comment">% Outputs:</span>
0041 <span class="comment">%   handles: graphic handles to figures</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also: dsCalcFR, dsCalcPower, dsPlotWaveforms, dsCheckData, dsPlot, MDD,</span>
0044 <span class="comment">%           MDD</span>
0045 
0046 <span class="comment">%% Set Master parameters</span>
0047   
0048 <span class="comment">% Flag for returning error if the user specifies name/value pairs that are not in the</span>
0049 <span class="comment">% dsCheckOptions list</span>
0050 strict_mode = 0;        <span class="comment">% Should be set to zero for this to work within simulate model</span>
0051 
0052 <span class="comment">%% Convert data input to appropriate form</span>
0053 
0054 <span class="comment">% If data is path to studyinfo...</span>
0055 <span class="keyword">if</span> ischar(data)
0056     study_dir = data;
0057     
0058     <span class="comment">% Import plot files</span>
0059     data_img = <a href="../functions/internal/dsImportPlots.html" class="code" title="function [data,studyinfo] = dsImportPlots(file,varargin)">dsImportPlots</a>(study_dir);
0060     
0061     [handles, xp] = <a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>(data_img,varargin{:});
0062     <span class="keyword">return</span>;
0063 <span class="keyword">end</span>
0064 
0065 <span class="comment">% Convert the incoming DynaSim data structure to an MDD object</span>
0066 <span class="keyword">if</span> ~isa(data,<span class="string">'MDD'</span>)
0067     [xp,is_image] = <a href="../functions/internal/dsAll2mdd.html" class="code" title="function [xp,is_image] = dsAll2mdd(data,varargin)">dsAll2mdd</a>(data);
0068 <span class="keyword">else</span>
0069     xp = data;
0070     <span class="keyword">if</span> iscell(xp.data{1})
0071         is_image = 1;
0072     <span class="keyword">else</span>
0073         is_image = 0;
0074     <span class="keyword">end</span>
0075 <span class="keyword">end</span>
0076 
0077 <span class="comment">%% Convert varargin to appropriate forms</span>
0078 <span class="comment">% Find out names of varied variables</span>
0079 varied_names = <a href="#_sub17" class="code" title="subfunction varied_names = only_varieds(xp)">only_varieds</a>(xp);  <span class="comment">% Returns only the names of the varied variables</span>
0080 
0081 <span class="comment">% Convert 'varied1'...'variedN' values in varargin to the names of the</span>
0082 <span class="comment">% actual varied parameters</span>
0083 myargin = varargin;
0084 <span class="keyword">for</span> i = 1:length(myargin)
0085     <span class="comment">% Char entries</span>
0086     <span class="keyword">if</span> ischar(myargin{i})
0087         myargin{i} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i},varied_names);
0088     <span class="keyword">end</span>
0089     
0090     <span class="comment">% Nested char entries within cell array entries</span>
0091     <span class="keyword">if</span> iscell(myargin{i})
0092         <span class="keyword">for</span> j = 1:length(myargin{i})
0093             <span class="keyword">if</span> ischar(myargin{i}{j})
0094                 myargin{i}{j} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i}{j},varied_names);
0095             <span class="keyword">end</span>
0096         <span class="keyword">end</span>
0097     <span class="keyword">end</span>
0098 <span class="keyword">end</span>
0099 
0100 <span class="comment">% %% Add dummy axes as needed. Having these greatly simplifies the code below.</span>
0101 <span class="comment">% if isempty(xp.findaxis('populations'))</span>
0102 <span class="comment">%     Na=length(xp.axis);</span>
0103 <span class="comment">%     xp.axis(Na+1).name = 'populations';</span>
0104 <span class="comment">%     xp.axis(Na+1).values = 'Pop1';</span>
0105 <span class="comment">% end</span>
0106 <span class="comment">%</span>
0107 <span class="comment">% if isempty(xp.findaxis('variables'))</span>
0108 <span class="comment">%     Na=length(xp.axis);</span>
0109 <span class="comment">%     xp.axis(Na+1).name = 'variables';</span>
0110 <span class="comment">%     xp.axis(Na+1).values = 'X';</span>
0111 <span class="comment">% end</span>
0112 <span class="comment">%</span>
0113 <span class="comment">% if isempty(findaxis_varied(xp))  % If no varied axes</span>
0114 <span class="comment">%     Na=length(xp.axis);</span>
0115 <span class="comment">%     xp.axis(Na+1).name = 'Varied1';</span>
0116 <span class="comment">%     xp.axis(Na+1).values = 1;</span>
0117 <span class="comment">% end</span>
0118 
0119 <span class="comment">%% Parse varargin and set up defaults</span>
0120 [options, options_extras0] = <a href="../functions/internal/dsCheckOptions.html" class="code" title="function [parms, params_unspecified ] = dsCheckOptions(options, options_schema, strict)">dsCheckOptions</a>(myargin,{<span class="keyword">...</span>
0121   <span class="string">'population'</span>,[],[],<span class="keyword">...</span>
0122   <span class="string">'variable'</span>,[],[],<span class="keyword">...</span>
0123   <span class="string">'num_embedded_subplots'</span>,2,{1,2,3,4},<span class="keyword">...</span>
0124   <span class="string">'max_num_overlaid'</span>,50,[],<span class="keyword">...</span>
0125   <span class="string">'do_mean'</span>,false,[false true],<span class="keyword">...</span>
0126   <span class="string">'force_last'</span>,[],[],<span class="keyword">...</span>
0127   <span class="string">'do_overlay_shift'</span>,false,[false true],<span class="keyword">...</span>
0128   <span class="string">'overlay_shift_val'</span>,[],[],<span class="keyword">...</span>
0129   <span class="string">'do_zscore'</span>,[false],[false true],<span class="keyword">...</span>
0130   <span class="string">'plot_type'</span>,<span class="string">'waveform'</span>,{<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>,<span class="string">'imagesc'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>,<span class="string">'power'</span>,<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>},<span class="keyword">...</span>
0131   <span class="string">'xlims'</span>,[],[],<span class="keyword">...</span>
0132   <span class="string">'ylims'</span>,[],[],<span class="keyword">...</span>
0133   <span class="string">'zlims'</span>,[],[],<span class="keyword">...</span>
0134   <span class="string">'figwidth'</span>,[1],[],<span class="keyword">...</span>
0135   <span class="string">'figheight'</span>,[1],[],<span class="keyword">...</span>
0136   <span class="string">'crop_range'</span>,[],[],<span class="keyword">...</span>
0137   <span class="string">'lock_axes'</span>,true,[false true],<span class="keyword">...</span>
0138   <span class="string">'saved_fignum'</span>,[1],[],<span class="keyword">...</span>
0139   <span class="string">'max_num_newfigs'</span>,[10],[],<span class="keyword">...</span>
0140   <span class="string">'plot_options'</span>,struct,[],<span class="keyword">...</span>
0141   <span class="string">'subplot_options'</span>,struct,[],<span class="keyword">...</span>
0142   <span class="string">'figure_options'</span>,struct,[],<span class="keyword">...</span>
0143   <span class="string">'do_zoom'</span>,false,[false true],<span class="keyword">...</span>
0144   <span class="string">'yscale'</span>,<span class="string">'linear'</span>,{<span class="string">'linear'</span>,<span class="string">'log'</span>,<span class="string">'log10'</span>,<span class="string">'log2'</span>},<span class="keyword">...</span>
0145   <span class="string">'visible'</span>,<span class="string">'on'</span>,{<span class="string">'on'</span>,<span class="string">'off'</span>},<span class="keyword">...</span>
0146   <span class="string">'show_colorbar'</span>,false,[false true],<span class="keyword">...</span>
0147   <span class="string">'save_figures'</span>,false,[false true],<span class="keyword">...</span>
0148   <span class="string">'save_figname_prefix'</span>,[],[],<span class="keyword">...</span>
0149   <span class="string">'save_figname_path'</span>,[],[],<span class="keyword">...</span>
0150   <span class="string">'prepend_date_time'</span>,true,[false true],<span class="keyword">...</span>
0151   <span class="string">'supersize_me'</span>,false,[false true],<span class="keyword">...</span>
0152   <span class="string">'save_res'</span>,[],[],<span class="keyword">...</span>
0153   <span class="string">'Ndims_per_subplot'</span>,[],[],<span class="keyword">...</span>
0154   <span class="string">'dim_stacking'</span>,[],[],<span class="keyword">...</span>
0155   <span class="string">'plot_handle'</span>,[],[],<span class="keyword">...</span>
0156   },false);
0157 handles=[];
0158 
0159 <span class="comment">% Pull out fields from options struct</span>
0160 plot_type = options.plot_type;
0161 plot_options = options.plot_options;
0162 subplot_options = options.subplot_options;
0163 figure_options = options.figure_options;
0164 num_embedded_subplots = options.num_embedded_subplots;
0165 do_mean = options.do_mean;
0166 force_last = options.force_last;
0167 crop_range = options.crop_range;
0168 lock_axes = options.lock_axes;
0169 Ndims_per_subplot = options.Ndims_per_subplot;
0170 plot_handle = options.plot_handle;
0171 
0172 <span class="comment">% Add default options to structures</span>
0173 <span class="comment">% Plot_options</span>
0174 <span class="comment">% Used when running xp_matrix_advancedplot3D</span>
0175     plot_options = struct_addDef(plot_options,<span class="string">'ylims'</span>,options.ylims);
0176     plot_options = struct_addDef(plot_options,<span class="string">'xlims'</span>,options.xlims);
0177     plot_options = struct_addDef(plot_options,<span class="string">'zlims'</span>,options.zlims);
0178 <span class="comment">% Used when running xp_plotimage</span>
0179     plot_options = struct_addDef(plot_options,<span class="string">'saved_fignum'</span>,options.saved_fignum);
0180 <span class="comment">% Used when running xp_PlotData or xp_PlotFR2</span>
0181     plot_options = struct_addDef(plot_options,<span class="string">'args'</span>,{});
0182 <span class="comment">% Used when running waveformErr</span>
0183     plot_options = struct_addDef(plot_options,<span class="string">'meanfunc'</span>,@(x) mean(x,2));
0184     plot_options = struct_addDef(plot_options,<span class="string">'errfunc'</span>,@(x) std(x,[],2) ./ (sqrt(size(x,2)) * ones(size(x,1),1)));
0185 
0186 <span class="comment">% Subplot_options</span>
0187 subplot_options = struct_addDef(subplot_options,<span class="string">'subplotzoom_enabled'</span>,options.do_zoom);
0188 subplot_options = struct_addDef(subplot_options,<span class="string">'force_rowvect'</span>,true);
0189 
0190 <span class="comment">% Figure options</span>
0191 figure_options = struct_addDef(figure_options,<span class="string">'visible'</span>,options.visible);
0192 figure_options = struct_addDef(figure_options,<span class="string">'save_figures'</span>,options.save_figures);
0193 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_path'</span>,options.save_figname_path);
0194 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_prefix'</span>,options.save_figname_prefix);
0195 figure_options = struct_addDef(figure_options,<span class="string">'prepend_date_time'</span>,options.prepend_date_time);
0196 figure_options = struct_addDef(figure_options,<span class="string">'supersize_me'</span>,options.supersize_me);
0197 figure_options = struct_addDef(figure_options,<span class="string">'save_res'</span>,options.save_res);
0198 figure_options = struct_addDef(figure_options,<span class="string">'max_num_newfigs'</span>,options.max_num_newfigs);
0199 figure_options = struct_addDef(figure_options,<span class="string">'figwidth'</span>,options.figwidth);
0200 figure_options = struct_addDef(figure_options,<span class="string">'figheight'</span>,options.figheight);
0201 
0202 <span class="comment">%% Pre-process raw data contained in xp.data (mean + downsample)</span>
0203 <span class="comment">% % Note: these options don't work if data are images</span>
0204 <span class="comment">% Apply max overlaid</span>
0205 MTPP = options.max_num_overlaid; <span class="comment">% max traces per plot</span>
0206 <span class="keyword">if</span> any(strcmp(options.plot_type,{<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>,<span class="string">'power'</span>})) &amp;&amp; all(cellfun(@isnumeric,xp.data(:))) &amp;&amp; ~do_mean &amp;&amp; ~is_image
0207     mydata = xp.data;
0208     mydata2 = cell(size(mydata));
0209     <span class="keyword">for</span> i = 1:numel(mydata)
0210         <span class="keyword">if</span> ~isempty(mydata{i})
0211             mydata2{i} = mydata{i}(:,1:min(size(mydata{i},2),MTPP));
0212         <span class="keyword">end</span>
0213     <span class="keyword">end</span>
0214     
0215     xp.data = mydata2;
0216     clear mydata mydata2
0217     
0218     <span class="comment">% Update cell numbers metadata</span>
0219     cell_names = [1:max(cellfun(@(x) size(x,2),xp.data(:)))];
0220     cell_names_str = cellfunu(@(s) [<span class="string">'Cell '</span> num2str(s)], num2cell(cell_names));
0221     xp.meta.datainfo(2).values = cell_names_str;
0222 <span class="keyword">end</span>
0223 
0224 <span class="comment">% Average across cells if necessary</span>
0225 <span class="keyword">if</span> do_mean &amp;&amp; ~is_image
0226     mydata = xp.data;
0227     mydata = cellfun(@(x) mean(x,2), mydata,<span class="string">'UniformOutput'</span>,0);
0228     xp.data = mydata;
0229     xp.meta.datainfo(2).values = {<span class="string">'&lt;Cells&gt;'</span>};
0230 <span class="keyword">end</span>
0231 
0232 <span class="comment">%% Arrange dimensions of xp in appropriate order</span>
0233 <span class="comment">% % Should be variables x populations x varied1 x ... x variedN</span>
0234 
0235 <span class="comment">% Axis indices of populations</span>
0236 ax_ind_var = xp.findaxis(<span class="string">'variables'</span>);
0237 ax_ind_pop = xp.findaxis(<span class="string">'population'</span>);
0238 ax_ind_varied = <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp);
0239 
0240 <span class="comment">% Permute to put varied variables last</span>
0241 myorder = [ax_ind_var, ax_ind_pop, ax_ind_varied(:)'];
0242 <span class="keyword">if</span> length(myorder) &gt; 1
0243     xp = permute(xp,myorder);
0244 <span class="keyword">end</span>
0245 
0246 <span class="comment">%% Identify user selections for populations, variables, etc., and convert xp to xp2</span>
0247 <span class="comment">% %  (xp2 contains only user selections)</span>
0248 <span class="comment">% User selection for populations</span>
0249 chosen_pop = options.population;
0250 <span class="keyword">if</span> isempty(chosen_pop)
0251     chosen_pop = <span class="string">':'</span>;
0252 <span class="keyword">end</span>
0253 
0254 <span class="comment">% User selection for state variables</span>
0255 chosen_vars = options.variable;
0256 <span class="keyword">if</span> isempty(chosen_vars)
0257     chosen_vars = <a href="#_sub11" class="code" title="subfunction var_out = getdefaultstatevar(xp)">getdefaultstatevar</a>(xp);
0258 <span class="keyword">end</span>
0259 
0260 <span class="comment">% User selection for varied parameters</span>
0261 options_extras = options_extras0;
0262 [chosen_varied , options_extras ]= <a href="#_sub12" class="code" title="subfunction [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)">get_chosen_varied</a>(varied_names,options_extras);
0263 
0264 <span class="comment">% If any options are still leftover, these are extraneous. Report an error</span>
0265 leftover_fields = fieldnames(options_extras);
0266 <span class="keyword">if</span> ~isempty(leftover_fields) &amp;&amp; strict_mode
0267     error(<span class="string">'The following unrecogized name/value pairs were passed in: %s'</span>, sprintf(<span class="string">'%s '</span>,leftover_fields{:}));
0268 <span class="keyword">end</span>
0269 
0270 <span class="comment">% Convert any &quot;all&quot; strings in chosen_varied to colon operators</span>
0271 inds = cellfun(@ischar,chosen_varied);
0272 chosen_varied(inds) = cellfun(@(s) strrep(s,<span class="string">'all'</span>,<span class="string">':'</span>),chosen_varied(inds),<span class="string">'UniformOutput'</span>,0);
0273 <span class="keyword">if</span> strcmp(chosen_vars,<span class="string">'all'</span>); chosen_vars = <span class="string">':'</span>; <span class="keyword">end</span>
0274 <span class="keyword">if</span> strcmp(chosen_pop,<span class="string">'all'</span>); chosen_pop = <span class="string">':'</span>; <span class="keyword">end</span>
0275 
0276 <span class="comment">% Select out chosen data</span>
0277 chosen_all = {};
0278 <span class="keyword">if</span> ~isempty(ax_ind_varied); chosen_all = [chosen_varied,chosen_all]; <span class="keyword">end</span>
0279 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'populations'</span>)); chosen_all = [chosen_pop,chosen_all]; <span class="keyword">end</span>
0280 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'variables'</span>)); chosen_all = [chosen_vars,chosen_all]; <span class="keyword">end</span>
0281 <span class="comment">%xp2 = xp(chosen_vars,chosen_pop,chosen_varied{:});</span>
0282 <span class="keyword">if</span> ndims(xp) == 2 &amp;&amp; ~isempty(strfind(xp.axis(2).name,<span class="string">'Dim'</span>)) &amp;&amp; length(chosen_all) == 1
0283     chosen_all = [chosen_all {<span class="string">':'</span>}];        <span class="comment">% If xp is a column vector and only 1 varied entry present, fill out chosen_all to be size 2.</span>
0284 <span class="keyword">end</span>
0285 xp2 = xp(chosen_all{:});
0286 
0287 
0288 <span class="comment">%% Squeeze out unused dimensions</span>
0289 <span class="comment">% Squeeze to eliminate superfluous dimensions</span>
0290 xp2 = xp2.squeeze;
0291 Nd = ndims(xp2);
0292 
0293 <span class="comment">% Rearrange dimensions of xp2 for stacking</span>
0294 <span class="keyword">if</span> ~isempty(options.dim_stacking)
0295     ax_names = xp2.exportAxisNames;
0296     <span class="keyword">if</span> length(options.dim_stacking) ~= length(ax_names) -1
0297         error(<span class="string">'Incorrect number of dimensions specified. dim_stacking must be some permutation of the following: %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0298     <span class="keyword">end</span>
0299     xp2.permute(options.dim_stacking);
0300 <span class="keyword">end</span>
0301 
0302 
0303 
0304 <span class="comment">%% If doing force overlay, move overlay population to the end</span>
0305 <span class="keyword">if</span> ~isempty(force_last)
0306     
0307     <span class="comment">% If it's a stand-alone string, convert to cell array</span>
0308     <span class="keyword">if</span> ischar(force_last)
0309         force_last = {force_last};
0310     <span class="keyword">end</span>
0311     
0312     <span class="comment">% Functionalize this at some point... building list of requested axes</span>
0313     ax_names = xp2.exportAxisNames;
0314     ax_ind = zeros(1,length(force_last));
0315     <span class="keyword">for</span> i = 1:length(force_last)
0316         temp = xp2.findaxis(force_last{i});
0317         <span class="keyword">if</span> isempty(temp)
0318             error(<span class="string">'Requested axis not found. force_last must be one of the following: : %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0319         <span class="keyword">end</span>
0320         ax_ind(i) = temp;
0321     <span class="keyword">end</span>
0322     
0323 <span class="comment">%     % % Note: I am disabling this for now, because it is messing up</span>
0324 <span class="comment">%     certain plotting options. % %</span>
0325 <span class="comment">%     % Dims per subplot should be at least 2 if we're forcing last...</span>
0326 <span class="comment">%     % perhaps change this later</span>
0327 <span class="comment">%     if isempty(Ndims_per_subplot)</span>
0328 <span class="comment">%         Ndims_per_subplot = 2;</span>
0329 <span class="comment">%     end</span>
0330 <span class="comment">%     if Ndims_per_subplot == 1</span>
0331 <span class="comment">%         Ndims_per_subplot = 2;</span>
0332 <span class="comment">%     end</span>
0333     
0334     others_ind = true(1,ndims(xp2));
0335     others_ind(ax_ind) = false;
0336     xp2 = xp2.permute([find(others_ind), ax_ind]);        <span class="comment">% Move chosen axis to the back!</span>
0337     
0338 <span class="keyword">end</span>
0339 
0340 
0341 <span class="comment">%% If only one cell</span>
0342 
0343 <span class="comment">% If only 1 cell, move in 2nd cell</span>
0344 <span class="keyword">if</span> length(xp2.meta.datainfo(2).values) &lt;= 1 &amp;&amp; ~is_image
0345     <span class="comment">% Move populations axis to the end if it exists</span>
0346     
0347     ax2overlay = [];
0348     <span class="keyword">if</span> isempty(force_last) &amp;&amp; isempty(options.dim_stacking)
0349         ax2overlay = xp2.findaxis(<span class="string">'populations'</span>);           <span class="comment">% If force_last or dim_stacking isn't specified, then choose populations</span>
0350     <span class="keyword">end</span>
0351     
0352     <span class="keyword">if</span> isempty(ax2overlay)
0353         ax2overlay = xp2.ndims;     <span class="comment">% If can't find populations, use last axis on the stack</span>
0354     <span class="keyword">end</span>
0355     
0356     <span class="comment">% Save variables associated with this axis</span>
0357     packed_vars = xp2.axis(ax2overlay).values;
0358     packed_name = xp2.axis(ax2overlay).name;
0359     
0360     <span class="comment">% Add &lt;average&gt; symbols if necessary to packed_vars</span>
0361     cellnames = xp2.meta.datainfo(2).values;
0362     temp = cellfun(@isempty,strfind(cellnames,<span class="string">'&lt;'</span>));    <span class="comment">% Check if originals were averages!</span>
0363     <span class="keyword">if</span> any(~temp)
0364         <span class="keyword">if</span> isnumeric(packed_vars); packed_vars = cellfunu(@(s) [strrep(packed_name,<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> num2str(s)],num2cell(packed_vars)); <span class="keyword">end</span>
0365         packed_vars = cellfunu(@(s) [<span class="string">'&lt;'</span> s <span class="string">'&gt;'</span>], packed_vars);
0366     <span class="keyword">end</span>
0367     
0368     xp2.meta.datainfo(2).name = packed_name;
0369     xp2.meta.datainfo(2).values = packed_vars(:)';
0370     
0371     xp2 = xp2.packDim(ax2overlay,2);
0372     xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0373 <span class="keyword">end</span>
0374 
0375 <span class="comment">%% Set up do z-score &amp; overlay shift</span>
0376 <span class="keyword">if</span> options.do_zscore &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0377     mydata = xp2.data;
0378     <span class="keyword">for</span> i = 1:numel(mydata)
0379         mydata{i} = zscore(mydata{i});
0380     <span class="keyword">end</span>
0381     xp2.data = mydata;
0382 <span class="keyword">end</span>
0383 
0384 <span class="comment">% Shift the overlay by a certain amount</span>
0385     <span class="keyword">if</span> options.do_overlay_shift &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0386         Nd = ndims(xp2);
0387         xp2 = xp2.packDim(Nd);
0388         mydata = xp2.data;
0389         <span class="keyword">for</span> i = 1:numel(mydata)
0390             mydata{i} = <a href="#_sub19" class="code" title="subfunction mydata_out = do_shift_lastdim (mydata,shift)">do_shift_lastdim</a> (mydata{i},options.overlay_shift_val);
0391         <span class="keyword">end</span>
0392         xp2.data = mydata;
0393         xp2 = xp2.unpackDim(3,Nd);
0394         xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0395     <span class="keyword">end</span>
0396 
0397 <span class="comment">%% Crop data</span>
0398 <span class="comment">% This is inserted here because apparently the operation is slow and it's</span>
0399 <span class="comment">% faster to do this after we've already squeezed / selected.</span>
0400 <span class="keyword">if</span> ~isempty(crop_range) &amp;&amp;  all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0401     t_temp = xp2.meta.datainfo(1).values;
0402     ind = (t_temp &gt; crop_range(1) &amp; t_temp &lt;= crop_range(2));
0403     <span class="keyword">for</span> i = 1:numel(xp2.data)
0404         <span class="keyword">if</span> ~isempty(xp2.data{i}); xp2.data{i} = xp2.data{i}(ind,:); <span class="keyword">end</span>
0405     <span class="keyword">end</span>
0406     xp2.meta.datainfo(1).values = t_temp(ind);
0407     
0408     <span class="comment">% Also crop DynaSim metadata info about time.</span>
0409     t_temp2 = xp2.meta.dynasim.time;
0410     ind = (t_temp2 &gt; crop_range(1) &amp; t_temp2 &lt;= crop_range(2));
0411     t_temp2 = t_temp2(ind);
0412     xp2.meta.dynasim.time = t_temp2;
0413     
0414 <span class="keyword">end</span>
0415 
0416 <span class="comment">%% Set up legend entries and axis limits</span>
0417 <span class="comment">% Set up legend entries</span>
0418 subplot_options.legend1 = <a href="#_sub20" class="code" title="subfunction leg1 = setup_legends(xp2)">setup_legends</a>(xp2);
0419 
0420 <span class="comment">% Get axis lims</span>
0421 <span class="keyword">if</span> isempty(plot_options.xlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0422         xdat = xp2.meta.datainfo(1).values;
0423         plot_options.xlims = [min(xdat) max(xdat)];
0424 <span class="keyword">end</span>
0425 <span class="keyword">if</span> isempty(plot_options.ylims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0426     <span class="keyword">switch</span> plot_type
0427         <span class="keyword">case</span> {<span class="string">'waveform'</span>,<span class="string">'waveformErr'</span>}
0428             <span class="comment">% Merge all data into one single huge column</span>
0429             data_all = xp2.data(:);
0430             data_all = cellfunu(@(x) x(:), data_all);
0431             data_all = vertcat(data_all{:});
0432             <span class="comment">% Find the max and minima - these are the largest and smallest</span>
0433             <span class="comment">% values we could ever see.</span>
0434             data_lims = [min(data_all) max(data_all)];
0435             plot_options.ylims = data_lims;
0436     <span class="keyword">end</span>
0437 <span class="keyword">end</span>
0438 
0439 <span class="keyword">if</span> isempty(plot_options.zlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0440     <span class="keyword">switch</span> plot_type
0441         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0442             data_all = xp2.data(:);
0443             data_all = cellfunu(@(x) x(:), data_all);
0444             data_all = vertcat(data_all{:});
0445             data_lims = [min(data_all) max(data_all)];
0446             plot_options.zlims = data_lims;
0447     <span class="keyword">end</span>
0448 <span class="keyword">end</span>
0449 
0450 <span class="comment">%% Prepare plotting handles for specific plot types</span>
0451 <span class="keyword">if</span> is_image
0452     <span class="comment">% Is an image</span>
0453     data_plothandle = @xp_plotimage;
0454     plot_options.scale = .5;           <span class="comment">% Scale of .5 enforces some anti-aliasing</span>
0455 <span class="keyword">else</span>
0456     <span class="keyword">switch</span> plot_type
0457         <span class="keyword">case</span> <span class="string">'waveform'</span>
0458             <span class="comment">% Is data</span>
0459             data_plothandle = @xp1D_matrix_plot;
0460             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0461         <span class="keyword">case</span> <span class="string">'waveformErr'</span>
0462             data_plothandle = @xp1D_matrix_boundedline;
0463             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0464         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0465             data_plothandle = @xp_matrix_imagesc;
0466             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0467             <span class="comment">% Disable legend when using imagesc</span>
0468             subplot_options.legend1 = [];
0469             <span class="comment">% Add time information</span>
0470             plot_options.xdat = xp2.meta.datainfo(1).values;
0471             <span class="comment">% Control colorbar</span>
0472             <span class="keyword">if</span> lock_axes
0473                 <span class="comment">% If axes are locked, only need to show 1 colorbar across</span>
0474                 <span class="comment">% all subplots</span>
0475                 subplot_options.do_colorbar = options.show_colorbar;
0476                 plot_options.do_colorbar = false;
0477 <span class="comment">%                 subplot_options.do_colorbar = false;</span>
0478 <span class="comment">%                 plot_options.do_colorbar = true;</span>
0479             <span class="keyword">else</span>
0480                 subplot_options.do_colorbar = false;
0481                 plot_options.do_colorbar = options.show_colorbar;
0482             <span class="keyword">end</span>
0483             
0484         <span class="keyword">case</span> {<span class="string">'power'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}
0485             <span class="comment">% Disable legend when using dsPlot</span>
0486             subplot_options.legend1 = [];
0487             
0488             <span class="comment">% Setup call to xp_PlotData</span>
0489             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0490             data_plothandle = @xp_PlotData;
0491             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0492             
0493             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>})) &amp;&amp; isempty(force_last) &amp;&amp; isempty(options.dim_stacking)
0494                 <span class="comment">% Move populations axis to the end of xp2. (Only do this if</span>
0495                 <span class="comment">% we're not already overwriting dims stacking order).</span>
0496                 ax_names = xp2.exportAxisNames;
0497                 ind_pop = false(1,length(ax_names));
0498                 ind_pop(xp2.findaxis(<span class="string">'populations'</span>)) = true;
0499                 ind_rest = ~ind_pop;
0500                 order = [find(ind_rest) find(ind_pop)];
0501                 xp2 = xp2.permute(order);
0502             <span class="keyword">end</span>
0503             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>})) 
0504                 <span class="comment">% Force Ndims_per_subplot to 2 fro rastergram.</span>
0505                 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0506                     Ndims_per_subplot = 2;                 <span class="comment">% Overwrite Ndims_per_subplot to 2. This ensures</span>
0507                 <span class="keyword">end</span>                                        <span class="comment">% that multiple populations can be stacked in a</span>
0508                                                            <span class="comment">% single subplot.</span>
0509             <span class="keyword">end</span>
0510             
0511         <span class="keyword">case</span> {<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>}
0512             <span class="comment">% Disable legend when using dsPlotFR2</span>
0513             subplot_options.legend1 = [];
0514             <span class="comment">% Remove FR suffix from heatmap and heatmap_sorted plot types</span>
0515             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>}))
0516                 plot_type = strrep(plot_type,<span class="string">'FR'</span>,<span class="string">''</span>);
0517             <span class="keyword">end</span>
0518             
0519             <span class="comment">% Setup call to xp_PlotFR2</span>
0520             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0521             data_plothandle = @xp_PlotFR2;
0522             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0523     <span class="keyword">end</span>
0524 <span class="keyword">end</span>
0525 
0526 <span class="comment">% If Ndims_per_subplot has not been set yet, set it now!</span>
0527 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0528     Ndims_per_subplot = 1;
0529 <span class="keyword">end</span>
0530 
0531 <span class="comment">%% Prepare plotting structure depending on number of embedded subplots</span>
0532 <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0533 <span class="comment">% axis handle</span>
0534 <span class="keyword">switch</span> num_embedded_subplots
0535     <span class="keyword">case</span> 1
0536         <span class="comment">% Ordering of axis handles</span>
0537         <a name="_sub1" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0538         dims_per_function_handle = [1,1,Ndims_per_subplot];
0539         <a name="_sub2" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0540         
0541     <span class="keyword">case</span> 2
0542         <span class="comment">% Ordering of axis handles</span>
0543         <a name="_sub3" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0544         dims_per_function_handle = [1,2,Ndims_per_subplot];
0545         <a name="_sub4" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0546         
0547     <span class="keyword">case</span> 3
0548         <span class="comment">% Ordering of axis handles</span>
0549         <a name="_sub5" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0550         dims_per_function_handle = [1,2,1,Ndims_per_subplot];
0551         subplot_options2 = subplot_options;
0552         subplot_options2.legend1 = [];
0553         subplot_options.display_mode = 1;
0554         <a name="_sub6" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0555     <span class="keyword">case</span> 4
0556         <span class="comment">% Ordering of axis handles</span>
0557         <a name="_sub7" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0558         dims_per_function_handle = [1,2,2,Ndims_per_subplot];
0559         subplot_options2 = subplot_options;
0560         subplot_options2.legend1 = [];
0561         subplot_options.display_mode = 1;
0562         <a name="_sub8" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0563 <span class="keyword">end</span>
0564 
0565 <span class="comment">%% Auto trim dimensions as needed</span>
0566 <span class="comment">% Linearize dimensions of xp2 that are in excess of the total number we can</span>
0567 <span class="comment">% plot</span>
0568 maxNplotdims = sum(dims_per_function_handle)-1;
0569 xp2 = <a href="#_sub16" class="code" title="subfunction xp2 = reduce_dims(xp2,maxNplotdims)">reduce_dims</a>(xp2,maxNplotdims);
0570 
0571 <span class="comment">% Stack up available dimensions based on how much each axis handle can hold</span>
0572 ax_names = [xp2.exportAxisNames, <span class="string">'data'</span>];
0573 
0574 dimensions = <a href="#_sub15" class="code" title="subfunction dimensions = get_dimensions(ax_names,dims_per_function_handle)">get_dimensions</a>(ax_names,dims_per_function_handle);
0575 
0576 
0577 <span class="comment">% Remove any excess function handles that aren't needed</span>
0578 available_dims = ~cellfun(@isempty,dimensions);
0579 <a name="_sub9" href="#_subfunctions" class="code">function_handles = function_handles(available_dims);</a>
0580 dimensions = dimensions(available_dims);
0581 <a name="_sub10" href="#_subfunctions" class="code">function_args = function_args(available_dims);</a>
0582 
0583 <span class="comment">%% Run the plots!</span>
0584 <span class="comment">% Open new figure if necessary &amp; plot the data</span>
0585 <span class="keyword">if</span> ~isequal(@xp_handles_newfig, <a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>{1})
0586     <span class="comment">% Cheap hack to force it to create a new figure using our desired</span>
0587     <span class="comment">% parameters for instances when it wouldn't normally call</span>
0588     <span class="comment">% xp_handles_newfig.</span>
0589     xp3 = MDD;
0590     fhandle = @() recursivePlot(xp2,<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0591     xp3 = xp3.importData({fhandle});
0592     handles = xp_handles_newfig(xp3,figure_options);
0593 <span class="keyword">else</span>
0594     handles = xp2.recursivePlot(<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0595 <span class="keyword">end</span>
0596 
0597 
0598 <span class="keyword">end</span>
0599 
0600 
0601 <a name="_sub11" href="#_subfunctions" class="code">function var_out = getdefaultstatevar(xp)</a>
0602     <span class="comment">% search through and try to find the variable represnting voltage. If can't find</span>
0603     <span class="comment">% it, just return the first variable listed.</span>
0604     
0605     <span class="comment">% See if variables axis even exists</span>
0606     <span class="keyword">if</span> isempty(xp.findaxis(<span class="string">'variables'</span>))
0607         <span class="comment">% If reach here, it means variables is not used in the code. Just</span>
0608         <span class="comment">% return some dummy values and move on.</span>
0609         var_out = <span class="string">':'</span>; 
0610         <span class="keyword">return</span>;
0611     <span class="keyword">end</span>
0612     
0613     vars_from_labels = <a href="../functions/internal/dsGet_variables_from_meta.html" class="code" title="function varlabels = dsGet_variables_from_meta(xp)">dsGet_variables_from_meta</a>(xp);
0614     <span class="keyword">if</span> ~isempty(vars_from_labels)
0615         vars_from_labels = vars_from_labels(1);   <span class="comment">% Best guess at default state variable. Usually its the 1st entry in labels</span>
0616     <span class="keyword">end</span>
0617     
0618     <span class="comment">% Pull out variables</span>
0619     vars_orig = xp.axis(<span class="string">'variables'</span>).values;
0620     
0621     <span class="comment">% Make everything uppercase to ensure</span>
0622     <span class="comment">% case-insensitive.</span>
0623     vars = upper(vars_orig);
0624     possibilities = upper({vars_from_labels{:},<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'Vm'</span>,<span class="string">'Xm'</span>,<span class="string">'Y'</span>,<span class="string">'Ym'</span>});
0625     
0626     ind = [];
0627     i=0;
0628     <span class="keyword">while</span> isempty(ind) &amp;&amp; i &lt; length(possibilities)
0629         i=i+1;
0630         ind = find(strcmpi(vars,possibilities{i}));
0631     <span class="keyword">end</span>
0632     
0633     <span class="keyword">if</span> ~isempty(ind)
0634         var_out = vars_orig{ind};
0635     <span class="keyword">else</span>
0636         var_out = vars_orig{1};
0637     <span class="keyword">end</span>
0638 <span class="keyword">end</span>
0639 
0640 <a name="_sub12" href="#_subfunctions" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a>
0641 
0642     <span class="comment">% Initialize output</span>
0643     chosen_varied = repmat({<span class="string">':'</span>},1,length(varied_names));
0644     
0645     <span class="comment">% Varied name-value pairs entered by user</span>
0646     varied_NVPs = fieldnames(options_varied);
0647     
0648     <span class="comment">% See if any of these match actual varied parameters</span>
0649     <span class="keyword">for</span> i =  1:length(varied_NVPs)
0650         ind = find(strcmp(varied_names,varied_NVPs{i}));
0651         <span class="keyword">if</span> length(ind) == 1
0652             chosen_varied{ind} = options_varied.(varied_NVPs{i});
0653             
0654             <span class="comment">% Optional (remove from options_varied)</span>
0655             options_varied = rmfield(options_varied,varied_NVPs{i});
0656         <span class="keyword">elseif</span> length(ind) &gt; 1
0657             error(<span class="string">'Multiple varied arguments found'</span>);
0658         <span class="keyword">else</span>
0659             <span class="comment">% Not a varied variable name</span>
0660         <span class="keyword">end</span>
0661         
0662         
0663     <span class="keyword">end</span>
0664     
0665 <span class="keyword">end</span>
0666 
0667 <a name="_sub13" href="#_subfunctions" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a>
0668 
0669         <span class="keyword">if</span> strcmp(str_in(1:min(6,end)),<span class="string">'varied'</span>)        <span class="comment">% User has entered variedX</span>
0670             <span class="comment">% fn is original fieldname (e.g. variedX)</span>
0671             <span class="comment">% fn2 is new field name of varied parameter (e.g. E_Iapp)</span>
0672             str_out = ax_names_varied{str2num(str_in(7:end))};
0673         <span class="keyword">else</span>
0674             str_out = str_in;
0675         <span class="keyword">end</span>
0676     
0677 <span class="keyword">end</span>
0678 
0679 <a name="_sub14" href="#_subfunctions" class="code">function ax_ind_varied = findaxis_varied(xp)</a>
0680     <span class="comment">% Uses metadata to identify a list of varied variables. Then validates</span>
0681     <span class="comment">% that they match the available axis names and returns their index.</span>
0682     varied = xp.meta.dynasim.varied;
0683     ax_names = xp.exportAxisNames;
0684     ax_ind_varied = false(1,length(ax_names));
0685     <span class="keyword">for</span> i = 1:length(varied)
0686         ind = strcmp(varied{i},ax_names);
0687         <span class="keyword">if</span> sum(ind) ~= 1; error(<span class="string">'Varied axis not found OR something wrong with varied label'</span>); <span class="keyword">end</span>
0688         ax_ind_varied = ax_ind_varied | ind;
0689     <span class="keyword">end</span>
0690     
0691     ax_ind_varied = find(ax_ind_varied);
0692 <span class="keyword">end</span>
0693 
0694 <a name="_sub15" href="#_subfunctions" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a>
0695     <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0696     <span class="comment">% axis handle</span>
0697 
0698     i = length(dims_per_function_handle);
0699     <span class="keyword">while</span> i &gt; 0 &amp;&amp; ~isempty(ax_names)
0700         
0701         Ndims_curr = dims_per_function_handle(i);
0702         dimensions{i} = ax_names(max(1,end-Ndims_curr+1):end);
0703         ax_names = ax_names(1:end-Ndims_curr);
0704         i=i-1;
0705     <span class="keyword">end</span>
0706     
0707 <span class="keyword">end</span>
0708 
0709 <a name="_sub16" href="#_subfunctions" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a>
0710     Nd = ndims(xp2);
0711     <span class="keyword">if</span> Nd &gt; maxNplotdims 
0712         xp2 = xp2.mergeDims( [maxNplotdims:Nd] );
0713         xp2 = xp2.squeeze;
0714         Nd = ndims(xp2);
0715 
0716         <span class="keyword">if</span> Nd ~= maxNplotdims; error(<span class="string">'something wrong'</span>); <span class="keyword">end</span>
0717     <span class="keyword">end</span>
0718 <span class="keyword">end</span>
0719 
0720 <a name="_sub17" href="#_subfunctions" class="code">function varied_names = only_varieds(xp)</a>
0721     <span class="comment">% Get list of varied axis names</span>
0722     varied_names = xp.meta.dynasim.varied;
0723     
0724     <span class="comment">% Make sure that they are acutally in xp.axis.names.</span>
0725     <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp); <span class="comment">% This function will return an error if they are missing!</span>
0726     
0727 <span class="keyword">end</span>
0728 
0729 <a name="_sub18" href="#_subfunctions" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a>
0730     warning(<span class="string">'update this command or possibly merge with findaxis_varied'</span>);
0731     inds = true(1,length(all_names));
0732     inds(strcmp(all_names,<span class="string">'populations'</span>)) = false; 
0733     inds(strcmp(all_names,<span class="string">'variables'</span>)) = false;
0734     varied_names = all_names(inds);
0735 <span class="keyword">end</span>
0736 
0737 <a name="_sub19" href="#_subfunctions" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a>
0738     sz = size(mydata);
0739     nd = ndims(mydata);
0740     
0741     <span class="keyword">if</span> isempty(shift)
0742         <span class="comment">% Do adaptive shift</span>
0743         upscale_factor = 2;
0744         temp = reshape(mydata,prod(sz(1:nd-1)),sz(nd));
0745         stdevs = nanstd(temp)*upscale_factor;               <span class="comment">% STD ignoring NaNs</span>
0746         sh = [0, stdevs(1:end-1) + stdevs(2:end)]';
0747         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0748     <span class="keyword">else</span>
0749         sh = shift*[0:sz(end)-1]';      <span class="comment">% Fixed shift amount</span>
0750         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0751     <span class="keyword">end</span>
0752     
0753     
0754     sh = permute(sh, [2:nd,1]);
0755     <span class="keyword">if</span> length(sz(1:nd-1)) == 1
0756         sh2 = repmat(sh, sz(1:nd-1),1);     <span class="comment">% Special case for scalar input to repmat. When repmat receives a scalar, it repeats BOTH rows and columns instead of just rows</span>
0757     <span class="keyword">else</span>
0758         sh2 = repmat(sh, sz(1:nd-1));
0759     <span class="keyword">end</span>
0760     
0761     mydata_out = mydata + sh2;
0762     
0763 <span class="keyword">end</span>
0764 
0765 <a name="_sub20" href="#_subfunctions" class="code">function leg1 = setup_legends(xp2)</a>
0766     
0767     <span class="comment">% Pull out all metadata names and values</span>
0768     <span class="keyword">for</span> i = 1:length(xp2.meta.datainfo)
0769         mn{i} = xp2.meta.datainfo(i).name;
0770         mv{i} = xp2.meta.datainfo(i).values;
0771     <span class="keyword">end</span>
0772 
0773     <span class="comment">% Convert any numeric entries to cell strings as needed</span>
0774     <span class="keyword">for</span> i = 2:length(xp2.meta.datainfo)
0775         <span class="keyword">if</span> isnumeric(mv{i})
0776             <span class="comment">% If axis is numeric, as in the case with varied parameters, convert to</span>
0777             <span class="comment">% a cell array of strings</span>
0778             mv{i} = cellfun(@num2str,num2cell(mv{i}),<span class="string">'UniformOutput'</span>,0);
0779 
0780             <span class="comment">% Also pre-pend the name of the variable being varied</span>
0781             <span class="keyword">for</span> j = 1:length(mv{i})
0782                 mv{i}{j} = [strrep(mn{i},<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> mv{i}{j}];
0783             <span class="keyword">end</span>
0784         <span class="keyword">end</span>
0785     <span class="keyword">end</span>
0786     
0787     <span class="keyword">if</span> length(mv) == 2
0788         leg1 = mv{2};
0789     <span class="keyword">elseif</span> length(mv) == 3
0790         <span class="comment">%Cartesean product of mv{2} and mv{3}</span>
0791         k = 0;
0792         <span class="keyword">for</span> j = 1:length(mv{3})
0793             <span class="keyword">for</span> i = 1:length(mv{2})         <span class="comment">% We plot the 2nd dimension 1st; they are grouped together</span>
0794                 k=k+1;
0795                 leg1{k} = [mv{2}{i} <span class="string">' '</span> mv{3}{j}];
0796             <span class="keyword">end</span>
0797         <span class="keyword">end</span>
0798     <span class="keyword">else</span>
0799         error(<span class="string">'should not reach'</span>);
0800     <span class="keyword">end</span>
0801 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 23-Jun-2017 18:15:58 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>