<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of dsPlot2</title>
  <meta name="keywords" content="dsPlot2">
  <meta name="description" content="% handles=dsPlot(data,'option',value)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>dsPlot2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% handles=dsPlot(data,'option',value)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [handles,xp] = dsPlot2(data,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% handles=dsPlot(data,'option',value)
 Purpose: plot data in various ways depending on what data was provided
 and what options are defined. this function is wrapped by ds.plotWaveforms,
 PlotPower, ... to provide a single function for organizing and displaying
 data.
 Inputs:
   data: DynaSim data structure (see ds.checkData)
   Accepts the following name/value pairs:
     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot
     'population' - name of population to plot (default: 'all'); accepts
                    regexp strings
     'variable' - name of variable to plot for each population (default: state variable, X or V);
                      accepts regexp strings
     'varied1' - Indices of 1st varied model parameter to plot. If the parameter
                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd
                 varied values. If the parameter is a char array, uses
                 regular expressions. Instead of 'varied1', can also use
                 the actual parameter name (e.g. 'E_Iapp')
     'varied2' - As varied 1, for 2nd varied parameter
     ....
     'variedN' - As varied 1, for 2nd varied parameter
     'num_embedded_subplots' - maximum # of waveforms to overlay per plot
     'max_num_overlaid' - maximum # of waveforms to overlay per plot
     'do_mean' - {false, true} - Turn on/off averaging across all units
                 in a population
     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}
                       If there is only one cell in a population, this forces
                       dsPlot2 to add other information to the overlay.
     'xlims' - [XMIN XMAX], x-axis limits (default: all data)
     'ylims' - [YMIN YMAX], y-axis limits (default: all data)
     'lock_axes' - {false, true}, locks abscissa and ordinate to be
                                  the same across all subplots
     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid
     'yscale' {'linear','log','log10'}, whether to plot linear or log scale
     'visible' {'on','off'}
     NOTE: analysis options available depending on plot_type
       see see ds.calcFR options for plot_type 'rastergram' or 'rates'
       see ds.calcPower options for plot_type 'power'
 Outputs:
   handles: graphic handles to figures
 
 See also: ds.calcFR, ds.calcPower, ds.plotWaveforms, ds.checkData, <a href="dsPlot.html" class="code" title="function handles = dsPlot(data,varargin)">dsPlot</a>, MDD,
           MDD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../functions/+ds/strrep.html" class="code" title="function str = strrep(str,oldstr,newstr,lpad,rpad, varargin)">strrep</a>	STRREP - replace full words by new character strings, ignoring matches that appear as sub-strings.</li><li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>	% handles=dsPlot(data,'option',value)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub2" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub3" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub4" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a></li><li><a href="#_sub5" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub6" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub7" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};</a></li><li><a href="#_sub8" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a></li><li><a href="#_sub9" class="code">function_handles = function_handles(available_dims);</a></li><li><a href="#_sub10" class="code">function_args = function_args(available_dims);</a></li><li><a href="#_sub11" class="code">function var_out = getdefaultstatevar(xp)</a></li><li><a href="#_sub12" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a></li><li><a href="#_sub13" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a></li><li><a href="#_sub14" class="code">function ax_ind_varied = findaxis_varied(xp)</a></li><li><a href="#_sub15" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a></li><li><a href="#_sub16" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a></li><li><a href="#_sub17" class="code">function varied_names = only_varieds(xp)</a></li><li><a href="#_sub18" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a></li><li><a href="#_sub19" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a></li><li><a href="#_sub20" class="code">function leg1 = setup_legends(xp2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [handles,xp] = dsPlot2(data,varargin)</a>
0002 <span class="comment">%% handles=dsPlot(data,'option',value)</span>
0003 <span class="comment">% Purpose: plot data in various ways depending on what data was provided</span>
0004 <span class="comment">% and what options are defined. this function is wrapped by ds.plotWaveforms,</span>
0005 <span class="comment">% PlotPower, ... to provide a single function for organizing and displaying</span>
0006 <span class="comment">% data.</span>
0007 <span class="comment">% Inputs:</span>
0008 <span class="comment">%   data: DynaSim data structure (see ds.checkData)</span>
0009 <span class="comment">%   Accepts the following name/value pairs:</span>
0010 <span class="comment">%     'plot_type' {'waveform' (default),'rastergram','rates','power'} - what to plot</span>
0011 <span class="comment">%     'population' - name of population to plot (default: 'all'); accepts</span>
0012 <span class="comment">%                    regexp strings</span>
0013 <span class="comment">%     'variable' - name of variable to plot for each population (default: state variable, X or V);</span>
0014 <span class="comment">%                      accepts regexp strings</span>
0015 <span class="comment">%     'varied1' - Indices of 1st varied model parameter to plot. If the parameter</span>
0016 <span class="comment">%                 is numeric, specify indices (e.g. 1:3 corresponds to 1st-3rd</span>
0017 <span class="comment">%                 varied values. If the parameter is a char array, uses</span>
0018 <span class="comment">%                 regular expressions. Instead of 'varied1', can also use</span>
0019 <span class="comment">%                 the actual parameter name (e.g. 'E_Iapp')</span>
0020 <span class="comment">%     'varied2' - As varied 1, for 2nd varied parameter</span>
0021 <span class="comment">%     ....</span>
0022 <span class="comment">%     'variedN' - As varied 1, for 2nd varied parameter</span>
0023 <span class="comment">%     'num_embedded_subplots' - maximum # of waveforms to overlay per plot</span>
0024 <span class="comment">%     'max_num_overlaid' - maximum # of waveforms to overlay per plot</span>
0025 <span class="comment">%     'do_mean' - {false, true} - Turn on/off averaging across all units</span>
0026 <span class="comment">%                 in a population</span>
0027 <span class="comment">%     'force_last' - {'none', 'populations' (default), 'variables', 'varied1' ... 'variedN'}</span>
0028 <span class="comment">%                       If there is only one cell in a population, this forces</span>
0029 <span class="comment">%                       dsPlot2 to add other information to the overlay.</span>
0030 <span class="comment">%     'xlims' - [XMIN XMAX], x-axis limits (default: all data)</span>
0031 <span class="comment">%     'ylims' - [YMIN YMAX], y-axis limits (default: all data)</span>
0032 <span class="comment">%     'lock_axes' - {false, true}, locks abscissa and ordinate to be</span>
0033 <span class="comment">%                                  the same across all subplots</span>
0034 <span class="comment">%     'do_zoom' - {false, true} - Turn on zoom function in subplot_grid</span>
0035 <span class="comment">%     'yscale' {'linear','log','log10'}, whether to plot linear or log scale</span>
0036 <span class="comment">%     'visible' {'on','off'}</span>
0037 <span class="comment">%     NOTE: analysis options available depending on plot_type</span>
0038 <span class="comment">%       see see ds.calcFR options for plot_type 'rastergram' or 'rates'</span>
0039 <span class="comment">%       see ds.calcPower options for plot_type 'power'</span>
0040 <span class="comment">% Outputs:</span>
0041 <span class="comment">%   handles: graphic handles to figures</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also: ds.calcFR, ds.calcPower, ds.plotWaveforms, ds.checkData, dsPlot, MDD,</span>
0044 <span class="comment">%           MDD</span>
0045 
0046 <span class="comment">%% Set Master parameters</span>
0047   
0048 <span class="comment">% Flag for returning error if the user specifies name/value pairs that are not in the</span>
0049 <span class="comment">% ds.checkOptions list</span>
0050 strict_mode = 0;        <span class="comment">% Should be set to zero for this to work within simulate model</span>
0051 
0052 <span class="comment">%% Convert data input to appropriate form</span>
0053 
0054 <span class="comment">% If data is path to studyinfo...</span>
0055 <span class="keyword">if</span> ischar(data)
0056     study_dir = data;
0057     
0058     <span class="comment">% Import plot files</span>
0059     data_img = ds.importPlots(study_dir);
0060     
0061     [handles, xp] = <a href="dsPlot2.html" class="code" title="function [handles,xp] = dsPlot2(data,varargin)">dsPlot2</a>(data_img,varargin{:});
0062     <span class="keyword">return</span>;
0063 <span class="keyword">end</span>
0064 
0065 <span class="comment">% Convert the incoming DynaSim data structure to an MDD object</span>
0066 <span class="keyword">if</span> ~isa(data,<span class="string">'MDD'</span>)
0067     [xp,is_image] = ds.all2MDD(data);
0068 <span class="keyword">else</span>
0069     xp = data;
0070     <span class="keyword">if</span> iscell(xp.data{1})
0071         is_image = 1;
0072     <span class="keyword">else</span>
0073         is_image = 0;
0074     <span class="keyword">end</span>
0075 <span class="keyword">end</span>
0076 
0077 <span class="comment">%% Convert varargin to appropriate forms</span>
0078 <span class="comment">% Find out names of varied variables</span>
0079 varied_names = <a href="#_sub17" class="code" title="subfunction varied_names = only_varieds(xp)">only_varieds</a>(xp);  <span class="comment">% Returns only the names of the varied variables</span>
0080 
0081 <span class="comment">% Convert 'varied1'...'variedN' values in varargin to the names of the</span>
0082 <span class="comment">% actual varied parameters</span>
0083 myargin = varargin;
0084 <span class="keyword">for</span> i = 1:length(myargin)
0085     <span class="comment">% Char entries</span>
0086     <span class="keyword">if</span> ischar(myargin{i})
0087         myargin{i} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i},varied_names);
0088     <span class="keyword">end</span>
0089     
0090     <span class="comment">% Nested char entries within cell array entries</span>
0091     <span class="keyword">if</span> iscell(myargin{i})
0092         <span class="keyword">for</span> j = 1:length(myargin{i})
0093             <span class="keyword">if</span> ischar(myargin{i}{j})
0094                 myargin{i}{j} = <a href="#_sub13" class="code" title="subfunction str_out = variedN_to_axisnames(str_in,ax_names_varied)">variedN_to_axisnames</a>(myargin{i}{j},varied_names);
0095             <span class="keyword">end</span>
0096         <span class="keyword">end</span>
0097     <span class="keyword">end</span>
0098 <span class="keyword">end</span>
0099 
0100 <span class="comment">% %% Add dummy axes as needed. Having these greatly simplifies the code below.</span>
0101 <span class="comment">% if isempty(xp.findaxis('populations'))</span>
0102 <span class="comment">%     Na=length(xp.axis);</span>
0103 <span class="comment">%     xp.axis(Na+1).name = 'populations';</span>
0104 <span class="comment">%     xp.axis(Na+1).values = 'Pop1';</span>
0105 <span class="comment">% end</span>
0106 <span class="comment">%</span>
0107 <span class="comment">% if isempty(xp.findaxis('variables'))</span>
0108 <span class="comment">%     Na=length(xp.axis);</span>
0109 <span class="comment">%     xp.axis(Na+1).name = 'variables';</span>
0110 <span class="comment">%     xp.axis(Na+1).values = 'X';</span>
0111 <span class="comment">% end</span>
0112 <span class="comment">%</span>
0113 <span class="comment">% if isempty(findaxis_varied(xp))  % If no varied axes</span>
0114 <span class="comment">%     Na=length(xp.axis);</span>
0115 <span class="comment">%     xp.axis(Na+1).name = 'Varied1';</span>
0116 <span class="comment">%     xp.axis(Na+1).values = 1;</span>
0117 <span class="comment">% end</span>
0118 
0119 <span class="comment">%% Parse varargin and set up defaults</span>
0120 [options, options_extras0] = ds.checkOptions(myargin,{<span class="keyword">...</span>
0121   <span class="string">'population'</span>,[],[],<span class="keyword">...</span>
0122   <span class="string">'variable'</span>,[],[],<span class="keyword">...</span>
0123   <span class="string">'num_embedded_subplots'</span>,2,{1,2,3,4},<span class="keyword">...</span>
0124   <span class="string">'max_num_overlaid'</span>,50,[],<span class="keyword">...</span>
0125   <span class="string">'do_mean'</span>,false,[false true],<span class="keyword">...</span>
0126   <span class="string">'force_last'</span>,[],[],<span class="keyword">...</span>
0127   <span class="string">'do_overlay_shift'</span>,false,[false true],<span class="keyword">...</span>
0128   <span class="string">'overlay_shift_val'</span>,[],[],<span class="keyword">...</span>
0129   <span class="string">'do_zscore'</span>,[false],[false true],<span class="keyword">...</span>
0130   <span class="string">'plot_type'</span>,<span class="string">'waveform'</span>,{<span class="string">'waveform'</span>,<span class="string">'imagesc'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>,<span class="string">'power'</span>,<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>},<span class="keyword">...</span>
0131   <span class="string">'xlims'</span>,[],[],<span class="keyword">...</span>
0132   <span class="string">'ylims'</span>,[],[],<span class="keyword">...</span>
0133   <span class="string">'zlims'</span>,[],[],<span class="keyword">...</span>
0134   <span class="string">'figwidth'</span>,[1],[],<span class="keyword">...</span>
0135   <span class="string">'figheight'</span>,[1],[],<span class="keyword">...</span>
0136   <span class="string">'crop_range'</span>,[],[],<span class="keyword">...</span>
0137   <span class="string">'lock_axes'</span>,true,[false true],<span class="keyword">...</span>
0138   <span class="string">'saved_fignum'</span>,[1],[],<span class="keyword">...</span>
0139   <span class="string">'max_num_newfigs'</span>,[10],[],<span class="keyword">...</span>
0140   <span class="string">'plot_options'</span>,struct,[],<span class="keyword">...</span>
0141   <span class="string">'subplot_options'</span>,struct,[],<span class="keyword">...</span>
0142   <span class="string">'figure_options'</span>,struct,[],<span class="keyword">...</span>
0143   <span class="string">'do_zoom'</span>,false,[false true],<span class="keyword">...</span>
0144   <span class="string">'yscale'</span>,<span class="string">'linear'</span>,{<span class="string">'linear'</span>,<span class="string">'log'</span>,<span class="string">'log10'</span>,<span class="string">'log2'</span>},<span class="keyword">...</span>
0145   <span class="string">'visible'</span>,<span class="string">'on'</span>,{<span class="string">'on'</span>,<span class="string">'off'</span>},<span class="keyword">...</span>
0146   <span class="string">'show_colorbar'</span>,false,[false true],<span class="keyword">...</span>
0147   <span class="string">'save_figures'</span>,false,[false true],<span class="keyword">...</span>
0148   <span class="string">'save_figname_prefix'</span>,[],[],<span class="keyword">...</span>
0149   <span class="string">'save_figname_path'</span>,[],[],<span class="keyword">...</span>
0150   <span class="string">'prepend_date_time'</span>,true,[false true],<span class="keyword">...</span>
0151   <span class="string">'supersize_me'</span>,false,[false true],<span class="keyword">...</span>
0152   <span class="string">'save_res'</span>,[],[],<span class="keyword">...</span>
0153   <span class="string">'Ndims_per_subplot'</span>,[],[],<span class="keyword">...</span>
0154   <span class="string">'dim_stacking'</span>,[],[],<span class="keyword">...</span>
0155   <span class="string">'plot_handle'</span>,[],[],<span class="keyword">...</span>
0156   },false);
0157 handles=[];
0158 
0159 <span class="comment">% Pull out fields from options struct</span>
0160 plot_type = options.plot_type;
0161 plot_options = options.plot_options;
0162 subplot_options = options.subplot_options;
0163 figure_options = options.figure_options;
0164 num_embedded_subplots = options.num_embedded_subplots;
0165 do_mean = options.do_mean;
0166 force_last = options.force_last;
0167 crop_range = options.crop_range;
0168 lock_axes = options.lock_axes;
0169 Ndims_per_subplot = options.Ndims_per_subplot;
0170 plot_handle = options.plot_handle;
0171 
0172 <span class="comment">% Add default options to structures</span>
0173 <span class="comment">% Plot_options</span>
0174 <span class="comment">% Used when running xp_matrix_advancedplot3D</span>
0175     plot_options = struct_addDef(plot_options,<span class="string">'ylims'</span>,options.ylims);
0176     plot_options = struct_addDef(plot_options,<span class="string">'xlims'</span>,options.xlims);
0177     plot_options = struct_addDef(plot_options,<span class="string">'zlims'</span>,options.zlims);
0178 <span class="comment">% Used when running xp_plotimage</span>
0179     plot_options = struct_addDef(plot_options,<span class="string">'saved_fignum'</span>,options.saved_fignum);
0180 <span class="comment">% Used when running xp_PlotData or xp_PlotFR2</span>
0181     plot_options = struct_addDef(plot_options,<span class="string">'args'</span>,{});
0182 
0183 <span class="comment">% Subplot_options</span>
0184 subplot_options = struct_addDef(subplot_options,<span class="string">'subplotzoom_enabled'</span>,options.do_zoom);
0185 subplot_options = struct_addDef(subplot_options,<span class="string">'force_rowvect'</span>,true);
0186 
0187 <span class="comment">% Figure options</span>
0188 figure_options = struct_addDef(figure_options,<span class="string">'visible'</span>,options.visible);
0189 figure_options = struct_addDef(figure_options,<span class="string">'save_figures'</span>,options.save_figures);
0190 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_path'</span>,options.save_figname_path);
0191 figure_options = struct_addDef(figure_options,<span class="string">'save_figname_prefix'</span>,options.save_figname_prefix);
0192 figure_options = struct_addDef(figure_options,<span class="string">'prepend_date_time'</span>,options.prepend_date_time);
0193 figure_options = struct_addDef(figure_options,<span class="string">'supersize_me'</span>,options.supersize_me);
0194 figure_options = struct_addDef(figure_options,<span class="string">'save_res'</span>,options.save_res);
0195 figure_options = struct_addDef(figure_options,<span class="string">'max_num_newfigs'</span>,options.max_num_newfigs);
0196 figure_options = struct_addDef(figure_options,<span class="string">'figwidth'</span>,options.figwidth);
0197 figure_options = struct_addDef(figure_options,<span class="string">'figheight'</span>,options.figheight);
0198 
0199 <span class="comment">%% Pre-process raw data contained in xp.data (mean + downsample)</span>
0200 <span class="comment">% % Note: these options don't work if data are images</span>
0201 <span class="comment">% Apply max overlaid</span>
0202 MTPP = options.max_num_overlaid; <span class="comment">% max traces per plot</span>
0203 <span class="keyword">if</span> any(strcmp(options.plot_type,{<span class="string">'waveform'</span>,<span class="string">'power'</span>})) &amp;&amp; all(cellfun(@isnumeric,xp.data(:))) &amp;&amp; ~do_mean &amp;&amp; ~is_image
0204     mydata = xp.data;
0205     mydata2 = cell(size(mydata));
0206     <span class="keyword">for</span> i = 1:numel(mydata)
0207         <span class="keyword">if</span> ~isempty(mydata{i})
0208             mydata2{i} = mydata{i}(:,1:min(size(mydata{i},2),MTPP));
0209         <span class="keyword">end</span>
0210     <span class="keyword">end</span>
0211     
0212     xp.data = mydata2;
0213     clear mydata mydata2
0214     
0215     <span class="comment">% Update cell numbers metadata</span>
0216     cell_names = [1:max(cellfun(@(x) size(x,2),xp.data(:)))];
0217     cell_names_str = cellfunu(@(s) [<span class="string">'Cell '</span> num2str(s)], num2cell(cell_names));
0218     xp.meta.datainfo(2).values = cell_names_str;
0219 <span class="keyword">end</span>
0220 
0221 <span class="comment">% Average across cells if necessary</span>
0222 <span class="keyword">if</span> do_mean &amp;&amp; ~is_image
0223     mydata = xp.data;
0224     mydata = cellfun(@(x) mean(x,2), mydata,<span class="string">'UniformOutput'</span>,0);
0225     xp.data = mydata;
0226     xp.meta.datainfo(2).values = {<span class="string">'&lt;Cells&gt;'</span>};
0227 <span class="keyword">end</span>
0228 
0229 <span class="comment">%% Arrange dimensions of xp in appropriate order</span>
0230 <span class="comment">% % Should be variables x populations x varied1 x ... x variedN</span>
0231 
0232 <span class="comment">% Axis indices of populations</span>
0233 ax_ind_var = xp.findaxis(<span class="string">'variables'</span>);
0234 ax_ind_pop = xp.findaxis(<span class="string">'population'</span>);
0235 ax_ind_varied = <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp);
0236 
0237 <span class="comment">% Permute to put varied variables last</span>
0238 myorder = [ax_ind_var, ax_ind_pop, ax_ind_varied(:)'];
0239 <span class="keyword">if</span> length(myorder) &gt; 1
0240     xp = permute(xp,myorder);
0241 <span class="keyword">end</span>
0242 
0243 <span class="comment">%% Identify user selections for populations, variables, etc., and convert xp to xp2</span>
0244 <span class="comment">% %  (xp2 contains only user selections)</span>
0245 <span class="comment">% User selection for populations</span>
0246 chosen_pop = options.population;
0247 <span class="keyword">if</span> isempty(chosen_pop)
0248     chosen_pop = <span class="string">':'</span>;
0249 <span class="keyword">end</span>
0250 
0251 <span class="comment">% User selection for state variables</span>
0252 chosen_vars = options.variable;
0253 <span class="keyword">if</span> isempty(chosen_vars)
0254     chosen_vars = <a href="#_sub11" class="code" title="subfunction var_out = getdefaultstatevar(xp)">getdefaultstatevar</a>(xp);
0255 <span class="keyword">end</span>
0256 
0257 <span class="comment">% User selection for varied parameters</span>
0258 options_extras = options_extras0;
0259 [chosen_varied , options_extras ]= <a href="#_sub12" class="code" title="subfunction [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)">get_chosen_varied</a>(varied_names,options_extras);
0260 
0261 <span class="comment">% If any options are still leftover, these are extraneous. Report an error</span>
0262 leftover_fields = fieldnames(options_extras);
0263 <span class="keyword">if</span> ~isempty(leftover_fields) &amp;&amp; strict_mode
0264     error(<span class="string">'The following unrecogized name/value pairs were passed in: %s'</span>, sprintf(<span class="string">'%s '</span>,leftover_fields{:}));
0265 <span class="keyword">end</span>
0266 
0267 <span class="comment">% Convert any &quot;all&quot; strings in chosen_varied to colon operators</span>
0268 inds = cellfun(@ischar,chosen_varied);
0269 chosen_varied(inds) = cellfun(@(s) <a href="../functions/+ds/strrep.html" class="code" title="function str = strrep(str,oldstr,newstr,lpad,rpad, varargin)">strrep</a>(s,<span class="string">'all'</span>,<span class="string">':'</span>),chosen_varied(inds),<span class="string">'UniformOutput'</span>,0);
0270 <span class="keyword">if</span> strcmp(chosen_vars,<span class="string">'all'</span>); chosen_vars = <span class="string">':'</span>; <span class="keyword">end</span>
0271 <span class="keyword">if</span> strcmp(chosen_pop,<span class="string">'all'</span>); chosen_pop = <span class="string">':'</span>; <span class="keyword">end</span>
0272 
0273 <span class="comment">% Select out chosen data</span>
0274 chosen_all = {};
0275 <span class="keyword">if</span> ~isempty(ax_ind_varied); chosen_all = [chosen_varied,chosen_all]; <span class="keyword">end</span>
0276 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'populations'</span>)); chosen_all = [chosen_pop,chosen_all]; <span class="keyword">end</span>
0277 <span class="keyword">if</span> ~isempty(xp.findaxis(<span class="string">'variables'</span>)); chosen_all = [chosen_vars,chosen_all]; <span class="keyword">end</span>
0278 <span class="comment">%xp2 = xp(chosen_vars,chosen_pop,chosen_varied{:});</span>
0279 <span class="keyword">if</span> ndims(xp) == 2 &amp;&amp; ~isempty(strfind(xp.axis(2).name,<span class="string">'Dim'</span>)) &amp;&amp; length(chosen_all) == 1
0280     chosen_all = [chosen_all {<span class="string">':'</span>}];        <span class="comment">% If xp is a column vector and only 1 varied entry present, fill out chosen_all to be size 2.</span>
0281 <span class="keyword">end</span>
0282 xp2 = xp(chosen_all{:});
0283 
0284 
0285 <span class="comment">%% Squeeze out unused dimensions</span>
0286 <span class="comment">% Squeeze to eliminate superfluous dimensions</span>
0287 xp2 = xp2.squeeze;
0288 Nd = ndims(xp2);
0289 
0290 <span class="comment">% Rearrange dimensions of xp2 for stacking</span>
0291 <span class="keyword">if</span> ~isempty(options.dim_stacking)
0292     ax_names = xp2.exportAxisNames;
0293     <span class="keyword">if</span> length(options.dim_stacking) ~= length(ax_names) -1
0294         error(<span class="string">'Incorrect number of dimensions specified. dim_stacking must be some permutation of the following: %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0295     <span class="keyword">end</span>
0296     xp2.permute(options.dim_stacking);
0297 <span class="keyword">end</span>
0298 
0299 
0300 <span class="comment">%% If only one cell</span>
0301 
0302 <span class="comment">% If only 1 cell, move in 2nd cell</span>
0303 <span class="keyword">if</span> length(xp2.meta.datainfo(2).values) &lt;= 1 &amp;&amp; ~is_image
0304     <span class="comment">% Move populations axis to the end if it exists</span>
0305     ax2overlay = xp2.findaxis(<span class="string">'populations'</span>);
0306     <span class="keyword">if</span> isempty(ax2overlay)
0307         ax2overlay = xp2.ndims;     <span class="comment">% If can't find populations, use last axis on the stack</span>
0308     <span class="keyword">end</span>
0309     
0310     <span class="comment">% Save variables associated with this axis</span>
0311     packed_vars = xp2.axis(ax2overlay).values;
0312     packed_name = xp2.axis(ax2overlay).name;
0313     
0314     <span class="comment">% Add &lt;average&gt; symbols if necessary to packed_vars</span>
0315     cellnames = xp2.meta.datainfo(2).values;
0316     temp = cellfun(@isempty,strfind(cellnames,<span class="string">'&lt;'</span>));    <span class="comment">% Check if originals were averages!</span>
0317     <span class="keyword">if</span> any(~temp)
0318         <span class="keyword">if</span> isnumeric(packed_vars); packed_vars = cellfunu(@(s) [<a href="../functions/+ds/strrep.html" class="code" title="function str = strrep(str,oldstr,newstr,lpad,rpad, varargin)">strrep</a>(packed_name,<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> num2str(s)],num2cell(packed_vars)); <span class="keyword">end</span>
0319         packed_vars = cellfunu(@(s) [<span class="string">'&lt;'</span> s <span class="string">'&gt;'</span>], packed_vars);
0320     <span class="keyword">end</span>
0321     
0322     xp2.meta.datainfo(2).name = packed_name;
0323     xp2.meta.datainfo(2).values = packed_vars(:)';
0324     
0325     xp2 = xp2.packDim(ax2overlay,2);
0326     xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0327 <span class="keyword">end</span>
0328 
0329 <span class="comment">%% If doing force overlay, move overlay population to the end</span>
0330 <span class="keyword">if</span> ~isempty(force_last)
0331     
0332     <span class="comment">% If it's a stand-alone string, convert to cell array</span>
0333     <span class="keyword">if</span> ischar(force_last)
0334         force_last = {force_last};
0335     <span class="keyword">end</span>
0336     
0337     <span class="comment">% Functionalize this at some point... building list of requested axes</span>
0338     ax_names = xp2.exportAxisNames;
0339     ax_ind = zeros(1,length(force_last));
0340     <span class="keyword">for</span> i = 1:length(force_last)
0341         temp = xp2.findaxis(force_last{i});
0342         <span class="keyword">if</span> isempty(temp)
0343             error(<span class="string">'Requested axis not found. force_last must be one of the following: : %s'</span>, sprintf(<span class="string">'%s '</span>,ax_names{1:end}));
0344         <span class="keyword">end</span>
0345         ax_ind(i) = temp;
0346     <span class="keyword">end</span>
0347     
0348     <span class="comment">% Dims per subplot should be at least 2 if we're forcing last...</span>
0349     <span class="comment">% perhaps change this later</span>
0350     <span class="keyword">if</span> isempty(Ndims_per_subplot)
0351         Ndims_per_subplot = 2;
0352     <span class="keyword">end</span>
0353     <span class="keyword">if</span> Ndims_per_subplot == 1
0354         Ndims_per_subplot = 2;
0355     <span class="keyword">end</span>
0356     
0357     others_ind = true(1,ndims(xp2));
0358     others_ind(ax_ind) = false;
0359     xp2 = xp2.permute([find(others_ind), ax_ind]);        <span class="comment">% Move chosen axis to the back!</span>
0360     
0361 <span class="keyword">end</span>
0362 
0363 <span class="comment">%% Set up do z-score &amp; overlay shift</span>
0364 <span class="keyword">if</span> options.do_zscore &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0365     mydata = xp2.data;
0366     <span class="keyword">for</span> i = 1:numel(mydata)
0367         mydata{i} = zscore(mydata{i});
0368     <span class="keyword">end</span>
0369     xp2.data = mydata;
0370 <span class="keyword">end</span>
0371 
0372 <span class="comment">% Shift the overlay by a certain amount</span>
0373 <span class="keyword">if</span> ~isempty(Ndims_per_subplot)
0374     <span class="keyword">if</span> options.do_overlay_shift &amp;&amp; all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0375         Nd = ndims(xp2);
0376         xp2 = xp2.packDim(Nd);
0377         mydata = xp2.data;
0378         <span class="keyword">for</span> i = 1:numel(mydata)
0379             mydata{i} = <a href="#_sub19" class="code" title="subfunction mydata_out = do_shift_lastdim (mydata,shift)">do_shift_lastdim</a> (mydata{i},options.overlay_shift_val);
0380         <span class="keyword">end</span>
0381         xp2.data = mydata;
0382         xp2 = xp2.unpackDim(3,Nd);
0383         xp2 = xp2.squeezeRegexp(<span class="string">'Dim'</span>);
0384     <span class="keyword">end</span>
0385 <span class="keyword">end</span>
0386 
0387 <span class="comment">%% Crop data</span>
0388 <span class="comment">% This is inserted here because apparently the operation is slow and it's</span>
0389 <span class="comment">% faster to do this after we've already squeezed / selected.</span>
0390 <span class="keyword">if</span> ~isempty(crop_range) &amp;&amp;  all(cellfun(@isnumeric,xp2.data(:))) &amp;&amp; ~is_image
0391     t_temp = xp2.meta.datainfo(1).values;
0392     ind = (t_temp &gt; crop_range(1) &amp; t_temp &lt;= crop_range(2));
0393     <span class="keyword">for</span> i = 1:numel(xp2.data)
0394         <span class="keyword">if</span> ~isempty(xp2.data{i}); xp2.data{i} = xp2.data{i}(ind,:); <span class="keyword">end</span>
0395     <span class="keyword">end</span>
0396     xp2.meta.datainfo(1).values = t_temp(ind);
0397     
0398     <span class="comment">% Also crop DynaSim metadata info about time.</span>
0399     t_temp2 = xp2.meta.dynasim.time;
0400     ind = (t_temp2 &gt; crop_range(1) &amp; t_temp2 &lt;= crop_range(2));
0401     t_temp2 = t_temp2(ind);
0402     xp2.meta.dynasim.time = t_temp2;
0403     
0404 <span class="keyword">end</span>
0405 
0406 <span class="comment">%% Set up legend entries and axis limits</span>
0407 <span class="comment">% Set up legend entries</span>
0408 subplot_options.legend1 = <a href="#_sub20" class="code" title="subfunction leg1 = setup_legends(xp2)">setup_legends</a>(xp2);
0409 
0410 <span class="comment">% Get axis lims</span>
0411 <span class="keyword">if</span> isempty(plot_options.xlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0412         xdat = xp2.meta.datainfo(1).values;
0413         plot_options.xlims = [min(xdat) max(xdat)];
0414 <span class="keyword">end</span>
0415 <span class="keyword">if</span> isempty(plot_options.ylims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0416     <span class="keyword">switch</span> plot_type
0417         <span class="keyword">case</span> <span class="string">'waveform'</span>
0418             <span class="comment">% Merge all data into one single huge column</span>
0419             data_all = xp2.data(:);
0420             data_all = cellfunu(@(x) x(:), data_all);
0421             data_all = vertcat(data_all{:});
0422             <span class="comment">% Find the max and minima - these are the largest and smallest</span>
0423             <span class="comment">% values we could ever see.</span>
0424             data_lims = [min(data_all) max(data_all)];
0425             plot_options.ylims = data_lims;
0426     <span class="keyword">end</span>
0427 <span class="keyword">end</span>
0428 
0429 <span class="keyword">if</span> isempty(plot_options.zlims) &amp;&amp; lock_axes &amp;&amp; ~is_image
0430     <span class="keyword">switch</span> plot_type
0431         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0432             data_all = xp2.data(:);
0433             data_all = cellfunu(@(x) x(:), data_all);
0434             data_all = vertcat(data_all{:});
0435             data_lims = [min(data_all) max(data_all)];
0436             plot_options.zlims = data_lims;
0437     <span class="keyword">end</span>
0438 <span class="keyword">end</span>
0439 
0440 <span class="comment">%% Prepare plotting handles for specific plot types</span>
0441 <span class="keyword">if</span> is_image
0442     <span class="comment">% Is an image</span>
0443     data_plothandle = @xp_plotimage;
0444     plot_options.scale = .5;           <span class="comment">% Scale of .5 enforces some anti-aliasing</span>
0445 <span class="keyword">else</span>
0446     <span class="keyword">switch</span> plot_type
0447         <span class="keyword">case</span> <span class="string">'waveform'</span>
0448             <span class="comment">% Is data</span>
0449             data_plothandle = @xp1D_matrix_plot;
0450             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0451             
0452         <span class="keyword">case</span> <span class="string">'imagesc'</span>
0453             data_plothandle = @xp_matrix_imagesc;
0454             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0455             <span class="comment">% Disable legend when using imagesc</span>
0456             subplot_options.legend1 = [];
0457             <span class="comment">% Add time information</span>
0458             plot_options.xdat = xp2.meta.datainfo(1).values;
0459             <span class="comment">% Control colorbar</span>
0460             <span class="keyword">if</span> lock_axes
0461                 <span class="comment">% If axes are locked, only need to show 1 colorbar across</span>
0462                 <span class="comment">% all subplots</span>
0463                 subplot_options.do_colorbar = options.show_colorbar;
0464                 plot_options.do_colorbar = false;
0465 <span class="comment">%                 subplot_options.do_colorbar = false;</span>
0466 <span class="comment">%                 plot_options.do_colorbar = true;</span>
0467             <span class="keyword">else</span>
0468                 subplot_options.do_colorbar = false;
0469                 plot_options.do_colorbar = options.show_colorbar;
0470             <span class="keyword">end</span>
0471             
0472         <span class="keyword">case</span> {<span class="string">'power'</span>,<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}
0473             <span class="comment">% Disable legend when using dsPlot</span>
0474             subplot_options.legend1 = [];
0475             
0476             <span class="comment">% Setup call to xp_PlotData</span>
0477             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0478             data_plothandle = @xp_PlotData;
0479             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0480             
0481             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'rastergram'</span>,<span class="string">'raster'</span>}))
0482                 <span class="comment">% Move populations axis to the end of xp2. This ensures</span>
0483                 ax_names = xp2.exportAxisNames;
0484                 ind_pop = false(1,length(ax_names));
0485                 ind_pop(xp2.findaxis(<span class="string">'populations'</span>)) = true;
0486                 ind_rest = ~ind_pop;
0487                 order = [find(ind_rest) find(ind_pop)];
0488                 xp2 = xp2.permute(order);
0489                 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0490                     Ndims_per_subplot = 2;                 <span class="comment">% Overwrite Ndims_per_subplot to 2. This ensures</span>
0491                 <span class="keyword">end</span>                                        <span class="comment">% that multiple populations can be stacked in a</span>
0492                                                            <span class="comment">% single subplot.</span>
0493             <span class="keyword">end</span>
0494             
0495         <span class="keyword">case</span> {<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>,<span class="string">'meanFR'</span>,<span class="string">'meanFRdens'</span>}
0496             <span class="comment">% Disable legend when using ds.plotFR2</span>
0497             subplot_options.legend1 = [];
0498             <span class="comment">% Remove FR suffix from heatmap and heatmap_sorted plot types</span>
0499             <span class="keyword">if</span> any(strcmp(plot_type,{<span class="string">'heatmapFR'</span>,<span class="string">'heatmap_sortedFR'</span>}))
0500                 plot_type = <a href="../functions/+ds/strrep.html" class="code" title="function str = strrep(str,oldstr,newstr,lpad,rpad, varargin)">strrep</a>(plot_type,<span class="string">'FR'</span>,<span class="string">''</span>);
0501             <span class="keyword">end</span>
0502             
0503             <span class="comment">% Setup call to xp_PlotFR2</span>
0504             plot_options.args = {plot_options.args{:}, <span class="string">'plot_type'</span>,plot_type};
0505             data_plothandle = @xp_PlotFR2;
0506             <span class="keyword">if</span> ~isempty(plot_handle); data_plothandle = plot_handle; <span class="keyword">end</span>
0507     <span class="keyword">end</span>
0508 <span class="keyword">end</span>
0509 
0510 <span class="comment">% If Ndims_per_subplot has not been set yet, set it now!</span>
0511 <span class="keyword">if</span> isempty(Ndims_per_subplot)
0512     Ndims_per_subplot = 1;
0513 <span class="keyword">end</span>
0514 
0515 <span class="comment">%% Prepare plotting structure depending on number of embedded subplots</span>
0516 <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0517 <span class="comment">% axis handle</span>
0518 <span class="keyword">switch</span> num_embedded_subplots
0519     <span class="keyword">case</span> 1
0520         <span class="comment">% Ordering of axis handles</span>
0521         <a name="_sub1" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0522         dims_per_function_handle = [1,1,Ndims_per_subplot];
0523         <a name="_sub2" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0524         
0525     <span class="keyword">case</span> 2
0526         <span class="comment">% Ordering of axis handles</span>
0527         <a name="_sub3" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0528         dims_per_function_handle = [1,2,Ndims_per_subplot];
0529         <a name="_sub4" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options},{plot_options}};</a>
0530         
0531     <span class="keyword">case</span> 3
0532         <span class="comment">% Ordering of axis handles</span>
0533         <a name="_sub5" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0534         dims_per_function_handle = [1,2,1,Ndims_per_subplot];
0535         subplot_options2 = subplot_options;
0536         subplot_options2.legend1 = [];
0537         subplot_options.display_mode = 1;
0538         <a name="_sub6" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0539     <span class="keyword">case</span> 4
0540         <span class="comment">% Ordering of axis handles</span>
0541         <a name="_sub7" href="#_subfunctions" class="code">function_handles = {@xp_handles_newfig, @xp_subplot_grid, @xp_subplot_grid,data_plothandle};   </a><span class="comment">% Specifies the handles of the plotting functions</span>
0542         dims_per_function_handle = [1,2,2,Ndims_per_subplot];
0543         subplot_options2 = subplot_options;
0544         subplot_options2.legend1 = [];
0545         subplot_options.display_mode = 1;
0546         <a name="_sub8" href="#_subfunctions" class="code">function_args = {{figure_options},{subplot_options2},{subplot_options},{plot_options}};</a>
0547 <span class="keyword">end</span>
0548 
0549 <span class="comment">%% Auto trim dimensions as needed</span>
0550 <span class="comment">% Linearize dimensions of xp2 that are in excess of the total number we can</span>
0551 <span class="comment">% plot</span>
0552 maxNplotdims = sum(dims_per_function_handle)-1;
0553 xp2 = <a href="#_sub16" class="code" title="subfunction xp2 = reduce_dims(xp2,maxNplotdims)">reduce_dims</a>(xp2,maxNplotdims);
0554 
0555 <span class="comment">% Stack up available dimensions based on how much each axis handle can hold</span>
0556 ax_names = [xp2.exportAxisNames, <span class="string">'data'</span>];
0557 
0558 dimensions = <a href="#_sub15" class="code" title="subfunction dimensions = get_dimensions(ax_names,dims_per_function_handle)">get_dimensions</a>(ax_names,dims_per_function_handle);
0559 
0560 
0561 <span class="comment">% Remove any excess function handles that aren't needed</span>
0562 available_dims = ~cellfun(@isempty,dimensions);
0563 <a name="_sub9" href="#_subfunctions" class="code">function_handles = function_handles(available_dims);</a>
0564 dimensions = dimensions(available_dims);
0565 <a name="_sub10" href="#_subfunctions" class="code">function_args = function_args(available_dims);</a>
0566 
0567 <span class="comment">%% Run the plots!</span>
0568 <span class="comment">% Open new figure if necessary &amp; plot the data</span>
0569 <span class="keyword">if</span> ~isequal(@xp_handles_newfig, <a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>{1})
0570     <span class="comment">% Cheap hack to force it to create a new figure using our desired</span>
0571     <span class="comment">% parameters for instances when it wouldn't normally call</span>
0572     <span class="comment">% xp_handles_newfig.</span>
0573     xp3 = MDD;
0574     fhandle = @() recursivePlot(xp2,<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0575     xp3 = xp3.importData({fhandle});
0576     handles = xp_handles_newfig(xp3,figure_options);
0577 <span class="keyword">else</span>
0578     handles = xp2.recursivePlot(<a href="#_sub9" class="code" title="subfunction_handles = function_handles(available_dims);">function_handles</a>,dimensions,<a href="#_sub10" class="code" title="subfunction_args = function_args(available_dims);">function_args</a>);
0579 <span class="keyword">end</span>
0580 
0581 
0582 <span class="keyword">end</span>
0583 
0584 
0585 <a name="_sub11" href="#_subfunctions" class="code">function var_out = getdefaultstatevar(xp)</a>
0586     <span class="comment">% search through and try to find the variable represnting voltage. If can't find</span>
0587     <span class="comment">% it, just return the first variable listed.</span>
0588     
0589     <span class="comment">% See if variables axis even exists</span>
0590     <span class="keyword">if</span> isempty(xp.findaxis(<span class="string">'variables'</span>))
0591         <span class="comment">% If reach here, it means variables is not used in the code. Just</span>
0592         <span class="comment">% return some dummy values and move on.</span>
0593         var_out = <span class="string">':'</span>; 
0594         <span class="keyword">return</span>;
0595     <span class="keyword">end</span>
0596     
0597     vars_from_labels = ds.get_variables_from_meta(xp);
0598     <span class="keyword">if</span> ~isempty(vars_from_labels)
0599         vars_from_labels = vars_from_labels(1);   <span class="comment">% Best guess at default state variable. Usually its the 1st entry in labels</span>
0600     <span class="keyword">end</span>
0601     
0602     <span class="comment">% Pull out variables</span>
0603     vars_orig = xp.axis(<span class="string">'variables'</span>).values;
0604     
0605     <span class="comment">% Make everything uppercase to ensure</span>
0606     <span class="comment">% case-insensitive.</span>
0607     vars = upper(vars_orig);
0608     possibilities = upper({vars_from_labels{:},<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'Vm'</span>,<span class="string">'Xm'</span>,<span class="string">'Y'</span>,<span class="string">'Ym'</span>});
0609     
0610     ind = [];
0611     i=0;
0612     <span class="keyword">while</span> isempty(ind) &amp;&amp; i &lt; length(possibilities)
0613         i=i+1;
0614         ind = find(strcmpi(vars,possibilities{i}));
0615     <span class="keyword">end</span>
0616     
0617     <span class="keyword">if</span> ~isempty(ind)
0618         var_out = vars_orig{ind};
0619     <span class="keyword">else</span>
0620         var_out = vars_orig{1};
0621     <span class="keyword">end</span>
0622 <span class="keyword">end</span>
0623 
0624 <a name="_sub12" href="#_subfunctions" class="code">function [chosen_varied, options_varied ]= get_chosen_varied(varied_names,options_varied)</a>
0625 
0626     <span class="comment">% Initialize output</span>
0627     chosen_varied = repmat({<span class="string">':'</span>},1,length(varied_names));
0628     
0629     <span class="comment">% Varied name-value pairs entered by user</span>
0630     varied_NVPs = fieldnames(options_varied);
0631     
0632     <span class="comment">% See if any of these match actual varied parameters</span>
0633     <span class="keyword">for</span> i =  1:length(varied_NVPs)
0634         ind = find(strcmp(varied_names,varied_NVPs{i}));
0635         <span class="keyword">if</span> length(ind) == 1
0636             chosen_varied{ind} = options_varied.(varied_NVPs{i});
0637             
0638             <span class="comment">% Optional (remove from options_varied)</span>
0639             options_varied = rmfield(options_varied,varied_NVPs{i});
0640         <span class="keyword">elseif</span> length(ind) &gt; 1
0641             error(<span class="string">'Multiple varied arguments found'</span>);
0642         <span class="keyword">else</span>
0643             <span class="comment">% Not a varied variable name</span>
0644         <span class="keyword">end</span>
0645         
0646         
0647     <span class="keyword">end</span>
0648     
0649 <span class="keyword">end</span>
0650 
0651 <a name="_sub13" href="#_subfunctions" class="code">function str_out = variedN_to_axisnames(str_in,ax_names_varied)</a>
0652 
0653         <span class="keyword">if</span> strcmp(str_in(1:min(6,end)),<span class="string">'varied'</span>)        <span class="comment">% User has entered variedX</span>
0654             <span class="comment">% fn is original fieldname (e.g. variedX)</span>
0655             <span class="comment">% fn2 is new field name of varied parameter (e.g. E_Iapp)</span>
0656             str_out = ax_names_varied{str2num(str_in(7:end))};
0657         <span class="keyword">else</span>
0658             str_out = str_in;
0659         <span class="keyword">end</span>
0660     
0661 <span class="keyword">end</span>
0662 
0663 <a name="_sub14" href="#_subfunctions" class="code">function ax_ind_varied = findaxis_varied(xp)</a>
0664     <span class="comment">% Uses metadata to identify a list of varied variables. Then validates</span>
0665     <span class="comment">% that they match the available axis names and returns their index.</span>
0666     varied = xp.meta.dynasim.varied;
0667     ax_names = xp.exportAxisNames;
0668     ax_ind_varied = false(1,length(ax_names));
0669     <span class="keyword">for</span> i = 1:length(varied)
0670         ind = strcmp(varied{i},ax_names);
0671         <span class="keyword">if</span> sum(ind) ~= 1; error(<span class="string">'Varied axis not found OR something wrong with varied label'</span>); <span class="keyword">end</span>
0672         ax_ind_varied = ax_ind_varied | ind;
0673     <span class="keyword">end</span>
0674     
0675     ax_ind_varied = find(ax_ind_varied);
0676 <span class="keyword">end</span>
0677 
0678 <a name="_sub15" href="#_subfunctions" class="code">function dimensions = get_dimensions(ax_names,dims_per_function_handle)</a>
0679     <span class="comment">% Split available axes into the number of dimensions supported by each</span>
0680     <span class="comment">% axis handle</span>
0681 
0682     i = length(dims_per_function_handle);
0683     <span class="keyword">while</span> i &gt; 0 &amp;&amp; ~isempty(ax_names)
0684         
0685         Ndims_curr = dims_per_function_handle(i);
0686         dimensions{i} = ax_names(max(1,end-Ndims_curr+1):end);
0687         ax_names = ax_names(1:end-Ndims_curr);
0688         i=i-1;
0689     <span class="keyword">end</span>
0690     
0691 <span class="keyword">end</span>
0692 
0693 <a name="_sub16" href="#_subfunctions" class="code">function xp2 = reduce_dims(xp2,maxNplotdims)</a>
0694     Nd = ndims(xp2);
0695     <span class="keyword">if</span> Nd &gt; maxNplotdims 
0696         xp2 = xp2.mergeDims( [maxNplotdims:Nd] );
0697         xp2 = xp2.squeeze;
0698         Nd = ndims(xp2);
0699 
0700         <span class="keyword">if</span> Nd ~= maxNplotdims; error(<span class="string">'something wrong'</span>); <span class="keyword">end</span>
0701     <span class="keyword">end</span>
0702 <span class="keyword">end</span>
0703 
0704 <a name="_sub17" href="#_subfunctions" class="code">function varied_names = only_varieds(xp)</a>
0705     <span class="comment">% Get list of varied axis names</span>
0706     varied_names = xp.meta.dynasim.varied;
0707     
0708     <span class="comment">% Make sure that they are acutally in xp.axis.names.</span>
0709     <a href="#_sub14" class="code" title="subfunction ax_ind_varied = findaxis_varied(xp)">findaxis_varied</a>(xp); <span class="comment">% This function will return an error if they are missing!</span>
0710     
0711 <span class="keyword">end</span>
0712 
0713 <a name="_sub18" href="#_subfunctions" class="code">function varied_names = only_varieds_old_deleteme(all_names)</a>
0714     warning(<span class="string">'update this command or possibly merge with findaxis_varied'</span>);
0715     inds = true(1,length(all_names));
0716     inds(strcmp(all_names,<span class="string">'populations'</span>)) = false; 
0717     inds(strcmp(all_names,<span class="string">'variables'</span>)) = false;
0718     varied_names = all_names(inds);
0719 <span class="keyword">end</span>
0720 
0721 <a name="_sub19" href="#_subfunctions" class="code">function mydata_out = do_shift_lastdim (mydata,shift)</a>
0722     sz = size(mydata);
0723     nd = ndims(mydata);
0724     
0725     <span class="keyword">if</span> isempty(shift)
0726         <span class="comment">% Do adaptive shift</span>
0727         upscale_factor = 2;
0728         temp = reshape(mydata,prod(sz(1:nd-1)),sz(nd));
0729         stdevs = nanstd(temp)*upscale_factor;               <span class="comment">% STD ignoring NaNs</span>
0730         sh = [0, stdevs(1:end-1) + stdevs(2:end)]';
0731         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0732     <span class="keyword">else</span>
0733         sh = shift*[0:sz(end)-1]';      <span class="comment">% Fixed shift amount</span>
0734         sh = sh * -1;        <span class="comment">% Forces shifts to be downward (same as subplots)</span>
0735     <span class="keyword">end</span>
0736     
0737     
0738     sh = permute(sh, [2:nd,1]);
0739     <span class="keyword">if</span> length(sz(1:nd-1)) == 1
0740         sh2 = repmat(sh, sz(1:nd-1),1);     <span class="comment">% Special case for scalar input to repmat. When repmat receives a scalar, it repeats BOTH rows and columns instead of just rows</span>
0741     <span class="keyword">else</span>
0742         sh2 = repmat(sh, sz(1:nd-1));
0743     <span class="keyword">end</span>
0744     
0745     mydata_out = mydata + sh2;
0746     
0747 <span class="keyword">end</span>
0748 
0749 <a name="_sub20" href="#_subfunctions" class="code">function leg1 = setup_legends(xp2)</a>
0750     
0751     <span class="comment">% Pull out all metadata names and values</span>
0752     <span class="keyword">for</span> i = 1:length(xp2.meta.datainfo)
0753         mn{i} = xp2.meta.datainfo(i).name;
0754         mv{i} = xp2.meta.datainfo(i).values;
0755     <span class="keyword">end</span>
0756 
0757     <span class="comment">% Convert any numeric entries to cell strings as needed</span>
0758     <span class="keyword">for</span> i = 2:length(xp2.meta.datainfo)
0759         <span class="keyword">if</span> isnumeric(mv{i})
0760             <span class="comment">% If axis is numeric, as in the case with varied parameters, convert to</span>
0761             <span class="comment">% a cell array of strings</span>
0762             mv{i} = cellfun(@num2str,num2cell(mv{i}),<span class="string">'UniformOutput'</span>,0);
0763 
0764             <span class="comment">% Also pre-pend the name of the variable being varied</span>
0765             <span class="keyword">for</span> j = 1:length(mv{i})
0766                 mv{i}{j} = [<a href="../functions/+ds/strrep.html" class="code" title="function str = strrep(str,oldstr,newstr,lpad,rpad, varargin)">strrep</a>(mn{i},<span class="string">'_'</span>,<span class="string">' '</span>) <span class="string">' '</span> mv{i}{j}];
0767             <span class="keyword">end</span>
0768         <span class="keyword">end</span>
0769     <span class="keyword">end</span>
0770     
0771     <span class="keyword">if</span> length(mv) == 2
0772         leg1 = mv{2};
0773     <span class="keyword">elseif</span> length(mv) == 3
0774         <span class="comment">%Cartesean product of mv{2} and mv{3}</span>
0775         k = 0;
0776         <span class="keyword">for</span> j = 1:length(mv{3})
0777             <span class="keyword">for</span> i = 1:length(mv{2})         <span class="comment">% We plot the 2nd dimension 1st; they are grouped together</span>
0778                 k=k+1;
0779                 leg1{k} = [mv{2}{i} <span class="string">' '</span> mv{3}{j}];
0780             <span class="keyword">end</span>
0781         <span class="keyword">end</span>
0782     <span class="keyword">else</span>
0783         error(<span class="string">'should not reach'</span>);
0784     <span class="keyword">end</span>
0785 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 18-May-2017 08:41:34 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>